/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["MediaBundle"] = factory();
	else
		root["MediaBundle"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/axios */ \"./node_modules/axios/lib/axios.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsNEZBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanM/YmMzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/index.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./node_modules/axios/lib/helpers/cookies.js\");\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./node_modules/axios/lib/helpers/parseHeaders.js\");\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\nvar createError = __webpack_require__(/*! ../core/createError */ \"./node_modules/axios/lib/core/createError.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(\n        timeoutErrorMessage,\n        config,\n        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGlFQUFrQjtBQUN2QyxjQUFjLG1CQUFPLENBQUMseUVBQXNCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQywyRUFBdUI7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsNkVBQXVCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN0RCxzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDNUQsa0JBQWtCLG1CQUFPLENBQUMseUVBQXFCOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcz9iNTBkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuLi9jb3JlL2J1aWxkRnVsbFBhdGgnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG4gICAgdmFyIHJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb25maWcuYXV0aC5wYXNzd29yZCkpIDogJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ29ubG9hZGVuZCcgaW4gcmVxdWVzdCkge1xuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgY2FsbCBvbmxvYWRlbmQgb24gdGhlIG5leHQgJ3RpY2snXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgY29uZmlnLnRyYW5zaXRpb25hbCAmJiBjb25maWcudHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyAnRVRJTUVET1VUJyA6ICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/adapters/xhr.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\nvar Axios = __webpack_require__(/*! ./core/Axios */ \"./node_modules/axios/lib/core/Axios.js\");\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"./node_modules/axios/lib/cancel/CancelToken.js\");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \"./node_modules/axios/lib/helpers/spread.js\");\n\n// Expose isAxiosError\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ \"./node_modules/axios/lib/helpers/isAxiosError.js\");\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports[\"default\"] = axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxrREFBUztBQUM3QixXQUFXLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyw0REFBYztBQUNsQyxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBb0I7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLHdEQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrRUFBaUI7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLHNFQUFtQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsb0VBQWtCOztBQUV6QztBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGdGQUF3Qjs7QUFFckQ7O0FBRUE7QUFDQSx5QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanM/Y2VlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGF4aW9zLmRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQXhpb3NFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/axios.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanM/N2E3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/cancel/Cancel.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsMkRBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanM/OGRmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/cancel/CancelToken.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzPzJlNjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/cancel/isCancel.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./node_modules/axios/lib/core/InterceptorManager.js\");\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./node_modules/axios/lib/core/dispatchRequest.js\");\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar validator = __webpack_require__(/*! ../helpers/validator */ \"./node_modules/axios/lib/helpers/validator.js\");\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),\n      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),\n      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyx5RUFBcUI7QUFDNUMseUJBQXlCLG1CQUFPLENBQUMsaUZBQXNCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLDJFQUFtQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBZTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBc0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcz8wYTA2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcbnZhciB2YWxpZGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ZhbGlkYXRvcicpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWw7XG5cbiAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKSxcbiAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4sICcxLjAuMCcpLFxuICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKVxuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgdmFyIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHZhciBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJ1bldoZW4gPT09ICdmdW5jdGlvbicgJiYgaW50ZXJjZXB0b3IucnVuV2hlbihjb25maWcpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcblxuICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdmFyIHByb21pc2U7XG5cbiAgaWYgKCFzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMpIHtcbiAgICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuXG4gICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICBjaGFpbiA9IGNoYWluLmNvbmNhdChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuXG4gICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuXG4gIHZhciBuZXdDb25maWcgPSBjb25maWc7XG4gIHdoaWxlIChyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICB2YXIgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpO1xuICAgIHZhciBvblJlamVjdGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB0cnkge1xuICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25SZWplY3RlZChlcnJvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QobmV3Q29uZmlnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG5cbiAgd2hpbGUgKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/Axios.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanM/ZjZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkLCBvcHRpb25zKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkLFxuICAgIHN5bmNocm9ub3VzOiBvcHRpb25zID8gb3B0aW9ucy5zeW5jaHJvbm91cyA6IGZhbHNlLFxuICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/InterceptorManager.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ \"./node_modules/axios/lib/helpers/isAbsoluteURL.js\");\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ \"./node_modules/axios/lib/helpers/combineURLs.js\");\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBMEI7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXdCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzPzgzYjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/buildFullPath.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMscUVBQWdCOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanM/MmQ4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/createError.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar transformData = __webpack_require__(/*! ./transformData */ \"./node_modules/axios/lib/core/transformData.js\");\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTtBQUNoQyxvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLHVFQUFvQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMseURBQWE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanM/NTI3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgY29uZmlnLFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/dispatchRequest.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcz8zODdmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cblxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZTtcblxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXJyb3I7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/enhanceError.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLG1EQUFVOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJCQUEyQjtBQUMzQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanM/NGE3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ2RhdGEnXTtcbiAgdmFyIG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzID0gWydoZWFkZXJzJywgJ2F1dGgnLCAncHJveHknLCAncGFyYW1zJ107XG4gIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAnYmFzZVVSTCcsICd0cmFuc2Zvcm1SZXF1ZXN0JywgJ3RyYW5zZm9ybVJlc3BvbnNlJywgJ3BhcmFtc1NlcmlhbGl6ZXInLFxuICAgICd0aW1lb3V0JywgJ3RpbWVvdXRNZXNzYWdlJywgJ3dpdGhDcmVkZW50aWFscycsICdhZGFwdGVyJywgJ3Jlc3BvbnNlVHlwZScsICd4c3JmQ29va2llTmFtZScsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJywgJ29uVXBsb2FkUHJvZ3Jlc3MnLCAnb25Eb3dubG9hZFByb2dyZXNzJywgJ2RlY29tcHJlc3MnLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJywgJ21heEJvZHlMZW5ndGgnLCAnbWF4UmVkaXJlY3RzJywgJ3RyYW5zcG9ydCcsICdodHRwQWdlbnQnLFxuICAgICdodHRwc0FnZW50JywgJ2NhbmNlbFRva2VuJywgJ3NvY2tldFBhdGgnLCAncmVzcG9uc2VFbmNvZGluZydcbiAgXTtcbiAgdmFyIGRpcmVjdE1lcmdlS2V5cyA9IFsndmFsaWRhdGVTdGF0dXMnXTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHV0aWxzLmZvckVhY2godmFsdWVGcm9tQ29uZmlnMktleXMsIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICB1dGlscy5mb3JFYWNoKGRlZmF1bHRUb0NvbmZpZzJLZXlzLCBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChkaXJlY3RNZXJnZUtleXMsIGZ1bmN0aW9uIG1lcmdlKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBheGlvc0tleXMgPSB2YWx1ZUZyb21Db25maWcyS2V5c1xuICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cylcbiAgICAuY29uY2F0KGRpcmVjdE1lcmdlS2V5cyk7XG5cbiAgdmFyIG90aGVyS2V5cyA9IE9iamVjdFxuICAgIC5rZXlzKGNvbmZpZzEpXG4gICAgLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlckF4aW9zS2V5cyhrZXkpIHtcbiAgICAgIHJldHVybiBheGlvc0tleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG90aGVyS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/mergeConfig.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar createError = __webpack_require__(/*! ./createError */ \"./node_modules/axios/lib/core/createError.js\");\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLG1FQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcz80NjdmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/settle.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar defaults = __webpack_require__(/*! ./../defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7QUFDaEMsZUFBZSxtQkFBTyxDQUFDLDJEQUFlOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzP2M0MDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICB2YXIgY29udGV4dCA9IHRoaXMgfHwgZGVmYXVsdHM7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuLmNhbGwoY29udGV4dCwgZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/transformData.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ \"./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\nvar enhanceError = __webpack_require__(/*! ./core/enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ./adapters/xhr */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ./adapters/http */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n  },\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxrREFBUztBQUM3QiwwQkFBMEIsbUJBQU8sQ0FBQyw4RkFBK0I7QUFDakUsbUJBQW1CLG1CQUFPLENBQUMsMEVBQXFCOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDdEMsSUFBSTtBQUNKO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGlFQUFpQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcz8yNDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vY29yZS9lbmhhbmNlRXJyb3InKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuXG4gIHRyYW5zaXRpb25hbDoge1xuICAgIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICAgIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IGZhbHNlXG4gIH0sXG5cbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSB8fCAoaGVhZGVycyAmJiBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsO1xuICAgIHZhciBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgdmFyIGZvcmNlZEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5mb3JjZWRKU09OUGFyc2luZztcbiAgICB2YXIgc3RyaWN0SlNPTlBhcnNpbmcgPSAhc2lsZW50SlNPTlBhcnNpbmcgJiYgdGhpcy5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcblxuICAgIGlmIChzdHJpY3RKU09OUGFyc2luZyB8fCAoZm9yY2VkSlNPTlBhcnNpbmcgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgZGF0YS5sZW5ndGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0cmljdEpTT05QYXJzaW5nKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZW5oYW5jZUVycm9yKGUsIHRoaXMsICdFX0pTT05fUEFSU0UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/defaults.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzPzFkMmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/bind.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcz8zMGI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/buildURL.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanM/ZTY4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/combineURLs.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0MsU0FBUzs7QUFFVDtBQUNBLDREQUE0RCx3QkFBd0I7QUFDcEY7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanM/N2FhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/cookies.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcz9kOTI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/isAbsoluteURL.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcz81ZjAyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiAodHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/isAxiosError.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanM/MzkzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/isURLSameOrigin.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsbURBQVU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanM/YzhhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/normalizeHeaderName.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcz9jMzQ1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/parseHeaders.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzPzBkZjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/spread.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar pkg = __webpack_require__(/*! ./../../package.json */ \"./node_modules/axios/package.json\");\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\nvar currentVerArr = pkg.version.split('.');\n\n/**\n * Compare package versions\n * @param {string} version\n * @param {string?} thanVersion\n * @returns {boolean}\n */\nfunction isOlderVersion(version, thanVersion) {\n  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;\n  var destVer = version.split('.');\n  for (var i = 0; i < 3; i++) {\n    if (pkgVersionArr[i] > destVer[i]) {\n      return true;\n    } else if (pkgVersionArr[i] < destVer[i]) {\n      return false;\n    }\n  }\n  return false;\n}\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator\n * @param {string?} version\n * @param {string} message\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  var isDeprecated = version && isOlderVersion(version);\n\n  function formatMessage(opt, desc) {\n    return '[Axios v' + pkg.version + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed in ' + version));\n    }\n\n    if (isDeprecated && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  isOlderVersion: isOlderVersion,\n  assertOptions: assertOptions,\n  validators: validators\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdmFsaWRhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFVBQVUsbUJBQU8sQ0FBQywrREFBc0I7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdmFsaWRhdG9yLmpzPzg0OGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGtnID0gcmVxdWlyZSgnLi8uLi8uLi9wYWNrYWdlLmpzb24nKTtcblxudmFyIHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUsIGkpIHtcbiAgdmFsaWRhdG9yc1t0eXBlXSA9IGZ1bmN0aW9uIHZhbGlkYXRvcih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IHR5cGUgfHwgJ2EnICsgKGkgPCAxID8gJ24gJyA6ICcgJykgKyB0eXBlO1xuICB9O1xufSk7XG5cbnZhciBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcbnZhciBjdXJyZW50VmVyQXJyID0gcGtnLnZlcnNpb24uc3BsaXQoJy4nKTtcblxuLyoqXG4gKiBDb21wYXJlIHBhY2thZ2UgdmVyc2lvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IHRoYW5WZXJzaW9uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNPbGRlclZlcnNpb24odmVyc2lvbiwgdGhhblZlcnNpb24pIHtcbiAgdmFyIHBrZ1ZlcnNpb25BcnIgPSB0aGFuVmVyc2lvbiA/IHRoYW5WZXJzaW9uLnNwbGl0KCcuJykgOiBjdXJyZW50VmVyQXJyO1xuICB2YXIgZGVzdFZlciA9IHZlcnNpb24uc3BsaXQoJy4nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBpZiAocGtnVmVyc2lvbkFycltpXSA+IGRlc3RWZXJbaV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocGtnVmVyc2lvbkFycltpXSA8IGRlc3RWZXJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRyYW5zaXRpb25hbCBvcHRpb24gdmFsaWRhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7c3RyaW5nP30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIHZhciBpc0RlcHJlY2F0ZWQgPSB2ZXJzaW9uICYmIGlzT2xkZXJWZXJzaW9uKHZlcnNpb24pO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBwa2cudmVyc2lvbiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFwnJyArIG9wdCArICdcXCcnICsgZGVzYyArIChtZXNzYWdlID8gJy4gJyArIG1lc3NhZ2UgOiAnJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG9wdCwgb3B0cykge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCBpbiAnICsgdmVyc2lvbikpO1xuICAgIH1cblxuICAgIGlmIChpc0RlcHJlY2F0ZWQgJiYgIWRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdKSB7XG4gICAgICBkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSA9IHRydWU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIG9wdCxcbiAgICAgICAgICAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdicgKyB2ZXJzaW9uICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZWFyIGZ1dHVyZSdcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdG9yID8gdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdHMpIDogdHJ1ZTtcbiAgfTtcbn07XG5cbi8qKlxuICogQXNzZXJ0IG9iamVjdCdzIHByb3BlcnRpZXMgdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGFsbG93VW5rbm93blxuICovXG5cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbnMob3B0aW9ucywgc2NoZW1hLCBhbGxvd1Vua25vd24pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIHZhciBvcHQgPSBrZXlzW2ldO1xuICAgIHZhciB2YWxpZGF0b3IgPSBzY2hlbWFbb3B0XTtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW29wdF07XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiAnICsgb3B0ICsgJyBtdXN0IGJlICcgKyByZXN1bHQpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbGxvd1Vua25vd24gIT09IHRydWUpIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIG9wdGlvbiAnICsgb3B0KTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT2xkZXJWZXJzaW9uOiBpc09sZGVyVmVyc2lvbixcbiAgYXNzZXJ0T3B0aW9uczogYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yczogdmFsaWRhdG9yc1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/validator.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0QkFBNEI7QUFDNUIsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanM/YzUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWwpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQk9NKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT01cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/utils.js\n");

/***/ }),

/***/ "./node_modules/basiclightbox/dist/basicLightbox.min.js":
/*!**************************************************************!*\
  !*** ./node_modules/basiclightbox/dist/basicLightbox.min.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("!function(e){if(true)module.exports=e();else {}}((function(){return function e(n,t,o){function r(c,u){if(!t[c]){if(!n[c]){var s=undefined;if(!u&&s)return require(c,!0);if(i)return i(c,!0);var a=new Error(\"Cannot find module '\"+c+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var l=t[c]={exports:{}};n[c][0].call(l.exports,(function(e){return r(n[c][1][e]||e)}),l,l.exports,e,n,t,o)}return t[c].exports}for(var i=undefined,c=0;c<o.length;c++)r(o[c]);return r}({1:[function(e,n,t){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.create=t.visible=void 0;var o=function(e){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=document.createElement(\"div\");return t.innerHTML=e.trim(),!0===n?t.children:t.firstChild},r=function(e,n){var t=e.children;return 1===t.length&&t[0].tagName===n},i=function(e){return null!=(e=e||document.querySelector(\".basicLightbox\"))&&!0===e.ownerDocument.body.contains(e)};t.visible=i;t.create=function(e,n){var t=function(e,n){var t=o('\\n\\t\\t<div class=\"basicLightbox '.concat(n.className,'\">\\n\\t\\t\\t<div class=\"basicLightbox__placeholder\" role=\"dialog\"></div>\\n\\t\\t</div>\\n\\t')),i=t.querySelector(\".basicLightbox__placeholder\");e.forEach((function(e){return i.appendChild(e)}));var c=r(i,\"IMG\"),u=r(i,\"VIDEO\"),s=r(i,\"IFRAME\");return!0===c&&t.classList.add(\"basicLightbox--img\"),!0===u&&t.classList.add(\"basicLightbox--video\"),!0===s&&t.classList.add(\"basicLightbox--iframe\"),t}(e=function(e){var n=\"string\"==typeof e,t=e instanceof HTMLElement==1;if(!1===n&&!1===t)throw new Error(\"Content must be a DOM element/node or string\");return!0===n?Array.from(o(e,!0)):\"TEMPLATE\"===e.tagName?[e.content.cloneNode(!0)]:Array.from(e.children)}(e),n=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(null==(e=Object.assign({},e)).closable&&(e.closable=!0),null==e.className&&(e.className=\"\"),null==e.onShow&&(e.onShow=function(){}),null==e.onClose&&(e.onClose=function(){}),\"boolean\"!=typeof e.closable)throw new Error(\"Property `closable` must be a boolean\");if(\"string\"!=typeof e.className)throw new Error(\"Property `className` must be a string\");if(\"function\"!=typeof e.onShow)throw new Error(\"Property `onShow` must be a function\");if(\"function\"!=typeof e.onClose)throw new Error(\"Property `onClose` must be a function\");return e}(n)),c=function(e){return!1!==n.onClose(u)&&function(e,n){return e.classList.remove(\"basicLightbox--visible\"),setTimeout((function(){return!1===i(e)||e.parentElement.removeChild(e),n()}),410),!0}(t,(function(){if(\"function\"==typeof e)return e(u)}))};!0===n.closable&&t.addEventListener(\"click\",(function(e){e.target===t&&c()}));var u={element:function(){return t},visible:function(){return i(t)},show:function(e){return!1!==n.onShow(u)&&function(e,n){return document.body.appendChild(e),setTimeout((function(){requestAnimationFrame((function(){return e.classList.add(\"basicLightbox--visible\"),n()}))}),10),!0}(t,(function(){if(\"function\"==typeof e)return e(u)}))},close:c};return u}},{}]},{},[1])(1)}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzaWNsaWdodGJveC9kaXN0L2Jhc2ljTGlnaHRib3gubWluLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsR0FBRyxJQUFvRCxvQkFBb0IsS0FBSyxFQUFzTCxDQUFDLGFBQWEseUJBQXlCLGdCQUFnQixVQUFVLFVBQVUsTUFBTSxTQUFtQyxDQUFDLGdCQUFnQixPQUFDLE9BQU8sb0JBQW9CLDhDQUE4QyxrQ0FBa0MsWUFBWSxZQUFZLG9DQUFvQyx3QkFBd0IsdUJBQXVCLG9CQUFvQixVQUFVLFNBQW1DLEtBQUssV0FBVyxZQUFZLFNBQVMsRUFBRSxtQkFBbUIsYUFBYSxzQ0FBc0MsU0FBUyw0QkFBNEIsa0JBQWtCLDhGQUE4RiwyREFBMkQsaUJBQWlCLGlCQUFpQixzQ0FBc0MsZUFBZSxxR0FBcUcsWUFBWSx1QkFBdUIsb0JBQW9CLDBNQUEwTSx1QkFBdUIsd0JBQXdCLEdBQUcsZ0RBQWdELHVKQUF1SixlQUFlLHVEQUF1RCxrRkFBa0YseUdBQXlHLGlCQUFpQixnRUFBZ0UsNEJBQTRCLHlHQUF5RywwQ0FBMEMsd0ZBQXdGLHlGQUF5Rix1RkFBdUYseUZBQXlGLFNBQVMsbUJBQW1CLHVDQUF1QywyRUFBMkUsb0RBQW9ELFVBQVUsZUFBZSxvQ0FBb0MsSUFBSSx5REFBeUQsa0JBQWtCLEdBQUcsT0FBTyxtQkFBbUIsU0FBUyxvQkFBb0IsWUFBWSxrQkFBa0Isc0NBQXNDLDJEQUEyRCxrQ0FBa0MscURBQXFELEdBQUcsU0FBUyxlQUFlLG9DQUFvQyxHQUFHLFVBQVUsVUFBVSxHQUFHLEVBQUUsR0FBRyxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9ub2RlX21vZHVsZXMvYmFzaWNsaWdodGJveC9kaXN0L2Jhc2ljTGlnaHRib3gubWluLmpzPzJiNTQiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXsoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzKS5iYXNpY0xpZ2h0Ym94PWUoKX19KChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbiBlKG4sdCxvKXtmdW5jdGlvbiByKGMsdSl7aWYoIXRbY10pe2lmKCFuW2NdKXt2YXIgcz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCF1JiZzKXJldHVybiBzKGMsITApO2lmKGkpcmV0dXJuIGkoYywhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitjK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgbD10W2NdPXtleHBvcnRzOnt9fTtuW2NdWzBdLmNhbGwobC5leHBvcnRzLChmdW5jdGlvbihlKXtyZXR1cm4gcihuW2NdWzFdW2VdfHxlKX0pLGwsbC5leHBvcnRzLGUsbix0LG8pfXJldHVybiB0W2NdLmV4cG9ydHN9Zm9yKHZhciBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsYz0wO2M8by5sZW5ndGg7YysrKXIob1tjXSk7cmV0dXJuIHJ9KHsxOltmdW5jdGlvbihlLG4sdCl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGU9dC52aXNpYmxlPXZvaWQgMDt2YXIgbz1mdW5jdGlvbihlKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gdC5pbm5lckhUTUw9ZS50cmltKCksITA9PT1uP3QuY2hpbGRyZW46dC5maXJzdENoaWxkfSxyPWZ1bmN0aW9uKGUsbil7dmFyIHQ9ZS5jaGlsZHJlbjtyZXR1cm4gMT09PXQubGVuZ3RoJiZ0WzBdLnRhZ05hbWU9PT1ufSxpPWZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT0oZT1lfHxkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmJhc2ljTGlnaHRib3hcIikpJiYhMD09PWUub3duZXJEb2N1bWVudC5ib2R5LmNvbnRhaW5zKGUpfTt0LnZpc2libGU9aTt0LmNyZWF0ZT1mdW5jdGlvbihlLG4pe3ZhciB0PWZ1bmN0aW9uKGUsbil7dmFyIHQ9bygnXFxuXFx0XFx0PGRpdiBjbGFzcz1cImJhc2ljTGlnaHRib3ggJy5jb25jYXQobi5jbGFzc05hbWUsJ1wiPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XCJiYXNpY0xpZ2h0Ym94X19wbGFjZWhvbGRlclwiIHJvbGU9XCJkaWFsb2dcIj48L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHQnKSksaT10LnF1ZXJ5U2VsZWN0b3IoXCIuYmFzaWNMaWdodGJveF9fcGxhY2Vob2xkZXJcIik7ZS5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gaS5hcHBlbmRDaGlsZChlKX0pKTt2YXIgYz1yKGksXCJJTUdcIiksdT1yKGksXCJWSURFT1wiKSxzPXIoaSxcIklGUkFNRVwiKTtyZXR1cm4hMD09PWMmJnQuY2xhc3NMaXN0LmFkZChcImJhc2ljTGlnaHRib3gtLWltZ1wiKSwhMD09PXUmJnQuY2xhc3NMaXN0LmFkZChcImJhc2ljTGlnaHRib3gtLXZpZGVvXCIpLCEwPT09cyYmdC5jbGFzc0xpc3QuYWRkKFwiYmFzaWNMaWdodGJveC0taWZyYW1lXCIpLHR9KGU9ZnVuY3Rpb24oZSl7dmFyIG49XCJzdHJpbmdcIj09dHlwZW9mIGUsdD1lIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ9PTE7aWYoITE9PT1uJiYhMT09PXQpdGhyb3cgbmV3IEVycm9yKFwiQ29udGVudCBtdXN0IGJlIGEgRE9NIGVsZW1lbnQvbm9kZSBvciBzdHJpbmdcIik7cmV0dXJuITA9PT1uP0FycmF5LmZyb20obyhlLCEwKSk6XCJURU1QTEFURVwiPT09ZS50YWdOYW1lP1tlLmNvbnRlbnQuY2xvbmVOb2RlKCEwKV06QXJyYXkuZnJvbShlLmNoaWxkcmVuKX0oZSksbj1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtpZihudWxsPT0oZT1PYmplY3QuYXNzaWduKHt9LGUpKS5jbG9zYWJsZSYmKGUuY2xvc2FibGU9ITApLG51bGw9PWUuY2xhc3NOYW1lJiYoZS5jbGFzc05hbWU9XCJcIiksbnVsbD09ZS5vblNob3cmJihlLm9uU2hvdz1mdW5jdGlvbigpe30pLG51bGw9PWUub25DbG9zZSYmKGUub25DbG9zZT1mdW5jdGlvbigpe30pLFwiYm9vbGVhblwiIT10eXBlb2YgZS5jbG9zYWJsZSl0aHJvdyBuZXcgRXJyb3IoXCJQcm9wZXJ0eSBgY2xvc2FibGVgIG11c3QgYmUgYSBib29sZWFuXCIpO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlLmNsYXNzTmFtZSl0aHJvdyBuZXcgRXJyb3IoXCJQcm9wZXJ0eSBgY2xhc3NOYW1lYCBtdXN0IGJlIGEgc3RyaW5nXCIpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUub25TaG93KXRocm93IG5ldyBFcnJvcihcIlByb3BlcnR5IGBvblNob3dgIG11c3QgYmUgYSBmdW5jdGlvblwiKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlLm9uQ2xvc2UpdGhyb3cgbmV3IEVycm9yKFwiUHJvcGVydHkgYG9uQ2xvc2VgIG11c3QgYmUgYSBmdW5jdGlvblwiKTtyZXR1cm4gZX0obikpLGM9ZnVuY3Rpb24oZSl7cmV0dXJuITEhPT1uLm9uQ2xvc2UodSkmJmZ1bmN0aW9uKGUsbil7cmV0dXJuIGUuY2xhc3NMaXN0LnJlbW92ZShcImJhc2ljTGlnaHRib3gtLXZpc2libGVcIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtyZXR1cm4hMT09PWkoZSl8fGUucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlKSxuKCl9KSw0MTApLCEwfSh0LChmdW5jdGlvbigpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpcmV0dXJuIGUodSl9KSl9OyEwPT09bi5jbG9zYWJsZSYmdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwoZnVuY3Rpb24oZSl7ZS50YXJnZXQ9PT10JiZjKCl9KSk7dmFyIHU9e2VsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdmlzaWJsZTpmdW5jdGlvbigpe3JldHVybiBpKHQpfSxzaG93OmZ1bmN0aW9uKGUpe3JldHVybiExIT09bi5vblNob3codSkmJmZ1bmN0aW9uKGUsbil7cmV0dXJuIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKGZ1bmN0aW9uKCl7cmV0dXJuIGUuY2xhc3NMaXN0LmFkZChcImJhc2ljTGlnaHRib3gtLXZpc2libGVcIiksbigpfSkpfSksMTApLCEwfSh0LChmdW5jdGlvbigpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpcmV0dXJuIGUodSl9KSl9LGNsb3NlOmN9O3JldHVybiB1fX0se31dfSx7fSxbMV0pKDEpfSkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/basiclightbox/dist/basicLightbox.min.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-file-metadata/dist/filepond-plugin-file-metadata.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-metadata/dist/filepond-plugin-file-metadata.js ***!
  \******************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginFileMetadata 1.0.8\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : 0;\n})(this, function() {\n  'use strict';\n\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n\n    // get quick reference to Type utils\n    var Type = utils.Type;\n\n    // setup attribute mapping for accept\n    addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', function(map) {\n      return Object.assign(map, {\n        '^fileMetadata': {\n          group: 'fileMetadataObject'\n        }\n      });\n    });\n\n    addFilter('DID_LOAD_ITEM', function(item, _ref2) {\n      var query = _ref2.query;\n      return new Promise(function(resolve) {\n        if (!query('GET_ALLOW_FILE_METADATA')) {\n          return resolve(item);\n        }\n\n        // get default object and add as metadata\n        var data = query('GET_FILE_METADATA_OBJECT');\n        if (typeof data === 'object' && data !== null) {\n          Object.keys(data).forEach(function(key) {\n            item.setMetadata(key, data[key], true);\n          });\n        }\n\n        resolve(item);\n      });\n    });\n\n    return {\n      options: {\n        // Enable or disable file renaming\n        allowFileMetadata: [true, Type.BOOLEAN],\n\n        // A metadata object to add to all files\n        fileMetadataObject: [null, Type.OBJECT]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtbWV0YWRhdGEvZGlzdC9maWxlcG9uZC1wbHVnaW4tZmlsZS1tZXRhZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RDtBQUNBLE1BQU0sQ0FHZ0Q7QUFDdEQsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1maWxlLW1ldGFkYXRhL2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWZpbGUtbWV0YWRhdGEuanM/NDE3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZpbGVQb25kUGx1Z2luRmlsZU1ldGFkYXRhIDEuMC44XG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xuICogUGxlYXNlIHZpc2l0IGh0dHBzOi8vcHFpbmEubmwvZmlsZXBvbmQvIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgPyAobW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkpXG4gICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICA/IGRlZmluZShmYWN0b3J5KVxuICAgIDogKChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiksXG4gICAgICAoZ2xvYmFsLkZpbGVQb25kUGx1Z2luRmlsZU1ldGFkYXRhID0gZmFjdG9yeSgpKSk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBwbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4oX3JlZikge1xuICAgIHZhciBhZGRGaWx0ZXIgPSBfcmVmLmFkZEZpbHRlcixcbiAgICAgIHV0aWxzID0gX3JlZi51dGlscztcblxuICAgIC8vIGdldCBxdWljayByZWZlcmVuY2UgdG8gVHlwZSB1dGlsc1xuICAgIHZhciBUeXBlID0gdXRpbHMuVHlwZTtcblxuICAgIC8vIHNldHVwIGF0dHJpYnV0ZSBtYXBwaW5nIGZvciBhY2NlcHRcbiAgICBhZGRGaWx0ZXIoJ1NFVF9BVFRSSUJVVEVfVE9fT1BUSU9OX01BUCcsIGZ1bmN0aW9uKG1hcCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obWFwLCB7XG4gICAgICAgICdeZmlsZU1ldGFkYXRhJzoge1xuICAgICAgICAgIGdyb3VwOiAnZmlsZU1ldGFkYXRhT2JqZWN0J1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFkZEZpbHRlcignRElEX0xPQURfSVRFTScsIGZ1bmN0aW9uKGl0ZW0sIF9yZWYyKSB7XG4gICAgICB2YXIgcXVlcnkgPSBfcmVmMi5xdWVyeTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX01FVEFEQVRBJykpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBkZWZhdWx0IG9iamVjdCBhbmQgYWRkIGFzIG1ldGFkYXRhXG4gICAgICAgIHZhciBkYXRhID0gcXVlcnkoJ0dFVF9GSUxFX01FVEFEQVRBX09CSkVDVCcpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaXRlbS5zZXRNZXRhZGF0YShrZXksIGRhdGFba2V5XSwgdHJ1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICAvLyBFbmFibGUgb3IgZGlzYWJsZSBmaWxlIHJlbmFtaW5nXG4gICAgICAgIGFsbG93RmlsZU1ldGFkYXRhOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBBIG1ldGFkYXRhIG9iamVjdCB0byBhZGQgdG8gYWxsIGZpbGVzXG4gICAgICAgIGZpbGVNZXRhZGF0YU9iamVjdDogW251bGwsIFR5cGUuT0JKRUNUXVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gZmlyZSBwbHVnaW5sb2FkZWQgZXZlbnQgaWYgcnVubmluZyBpbiBicm93c2VyLCB0aGlzIGFsbG93cyByZWdpc3RlcmluZyB0aGUgcGx1Z2luIHdoZW4gdXNpbmcgYXN5bmMgc2NyaXB0IHRhZ3NcbiAgdmFyIGlzQnJvd3NlciA9XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gIGlmIChpc0Jyb3dzZXIpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IEN1c3RvbUV2ZW50KCdGaWxlUG9uZDpwbHVnaW5sb2FkZWQnLCB7IGRldGFpbDogcGx1Z2luIH0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwbHVnaW47XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-file-metadata/dist/filepond-plugin-file-metadata.js\n");

/***/ }),

/***/ "./node_modules/filepond/dist/filepond.js":
/*!************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/*!\n * FilePond 4.31.1\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n     true\n        ? factory(exports)\n        : 0;\n})(this, function(exports) {\n    'use strict';\n\n    var isNode = function isNode(value) {\n        return value instanceof HTMLElement;\n    };\n\n    var createStore = function createStore(initialState) {\n        var queries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        var actions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        // internal state\n        var state = Object.assign({}, initialState);\n\n        // contains all actions for next frame, is clear when actions are requested\n        var actionQueue = [];\n        var dispatchQueue = [];\n\n        // returns a duplicate of the current state\n        var getState = function getState() {\n            return Object.assign({}, state);\n        };\n\n        // returns a duplicate of the actions array and clears the actions array\n        var processActionQueue = function processActionQueue() {\n            // create copy of actions queue\n            var queue = [].concat(actionQueue);\n\n            // clear actions queue (we don't want no double actions)\n            actionQueue.length = 0;\n\n            return queue;\n        };\n\n        // processes actions that might block the main UI thread\n        var processDispatchQueue = function processDispatchQueue() {\n            // create copy of actions queue\n            var queue = [].concat(dispatchQueue);\n\n            // clear actions queue (we don't want no double actions)\n            dispatchQueue.length = 0;\n\n            // now dispatch these actions\n            queue.forEach(function(_ref) {\n                var type = _ref.type,\n                    data = _ref.data;\n                dispatch(type, data);\n            });\n        };\n\n        // adds a new action, calls its handler and\n        var dispatch = function dispatch(type, data, isBlocking) {\n            // is blocking action (should never block if document is hidden)\n            if (isBlocking && !document.hidden) {\n                dispatchQueue.push({ type: type, data: data });\n                return;\n            }\n\n            // if this action has a handler, handle the action\n            if (actionHandlers[type]) {\n                actionHandlers[type](data);\n            }\n\n            // now add action\n            actionQueue.push({\n                type: type,\n                data: data,\n            });\n        };\n\n        var query = function query(str) {\n            var _queryHandles;\n            for (\n                var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;\n                _key < _len;\n                _key++\n            ) {\n                args[_key - 1] = arguments[_key];\n            }\n            return queryHandles[str]\n                ? (_queryHandles = queryHandles)[str].apply(_queryHandles, args)\n                : null;\n        };\n\n        var api = {\n            getState: getState,\n            processActionQueue: processActionQueue,\n            processDispatchQueue: processDispatchQueue,\n            dispatch: dispatch,\n            query: query,\n        };\n\n        var queryHandles = {};\n        queries.forEach(function(query) {\n            queryHandles = Object.assign({}, query(state), {}, queryHandles);\n        });\n\n        var actionHandlers = {};\n        actions.forEach(function(action) {\n            actionHandlers = Object.assign({}, action(dispatch, query, state), {}, actionHandlers);\n        });\n\n        return api;\n    };\n\n    var defineProperty = function defineProperty(obj, property, definition) {\n        if (typeof definition === 'function') {\n            obj[property] = definition;\n            return;\n        }\n        Object.defineProperty(obj, property, Object.assign({}, definition));\n    };\n\n    var forin = function forin(obj, cb) {\n        for (var key in obj) {\n            if (!obj.hasOwnProperty(key)) {\n                continue;\n            }\n\n            cb(key, obj[key]);\n        }\n    };\n\n    var createObject = function createObject(definition) {\n        var obj = {};\n        forin(definition, function(property) {\n            defineProperty(obj, property, definition[property]);\n        });\n        return obj;\n    };\n\n    var attr = function attr(node, name) {\n        var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        if (value === null) {\n            return node.getAttribute(name) || node.hasAttribute(name);\n        }\n        node.setAttribute(name, value);\n    };\n\n    var ns = 'http://www.w3.org/2000/svg';\n    var svgElements = ['svg', 'path']; // only svg elements used\n\n    var isSVGElement = function isSVGElement(tag) {\n        return svgElements.includes(tag);\n    };\n\n    var createElement = function createElement(tag, className) {\n        var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (typeof className === 'object') {\n            attributes = className;\n            className = null;\n        }\n        var element = isSVGElement(tag)\n            ? document.createElementNS(ns, tag)\n            : document.createElement(tag);\n        if (className) {\n            if (isSVGElement(tag)) {\n                attr(element, 'class', className);\n            } else {\n                element.className = className;\n            }\n        }\n        forin(attributes, function(name, value) {\n            attr(element, name, value);\n        });\n        return element;\n    };\n\n    var appendChild = function appendChild(parent) {\n        return function(child, index) {\n            if (typeof index !== 'undefined' && parent.children[index]) {\n                parent.insertBefore(child, parent.children[index]);\n            } else {\n                parent.appendChild(child);\n            }\n        };\n    };\n\n    var appendChildView = function appendChildView(parent, childViews) {\n        return function(view, index) {\n            if (typeof index !== 'undefined') {\n                childViews.splice(index, 0, view);\n            } else {\n                childViews.push(view);\n            }\n\n            return view;\n        };\n    };\n\n    var removeChildView = function removeChildView(parent, childViews) {\n        return function(view) {\n            // remove from child views\n            childViews.splice(childViews.indexOf(view), 1);\n\n            // remove the element\n            if (view.element.parentNode) {\n                parent.removeChild(view.element);\n            }\n\n            return view;\n        };\n    };\n\n    var IS_BROWSER = (function() {\n        return typeof window !== 'undefined' && typeof window.document !== 'undefined';\n    })();\n    var isBrowser = function isBrowser() {\n        return IS_BROWSER;\n    };\n\n    var testElement = isBrowser() ? createElement('svg') : {};\n    var getChildCount =\n        'children' in testElement\n            ? function(el) {\n                  return el.children.length;\n              }\n            : function(el) {\n                  return el.childNodes.length;\n              };\n\n    var getViewRect = function getViewRect(elementRect, childViews, offset, scale) {\n        var left = offset[0] || elementRect.left;\n        var top = offset[1] || elementRect.top;\n        var right = left + elementRect.width;\n        var bottom = top + elementRect.height * (scale[1] || 1);\n\n        var rect = {\n            // the rectangle of the element itself\n            element: Object.assign({}, elementRect),\n\n            // the rectangle of the element expanded to contain its children, does not include any margins\n            inner: {\n                left: elementRect.left,\n                top: elementRect.top,\n                right: elementRect.right,\n                bottom: elementRect.bottom,\n            },\n\n            // the rectangle of the element expanded to contain its children including own margin and child margins\n            // margins will be added after we've recalculated the size\n            outer: {\n                left: left,\n                top: top,\n                right: right,\n                bottom: bottom,\n            },\n        };\n\n        // expand rect to fit all child rectangles\n        childViews\n            .filter(function(childView) {\n                return !childView.isRectIgnored();\n            })\n            .map(function(childView) {\n                return childView.rect;\n            })\n            .forEach(function(childViewRect) {\n                expandRect(rect.inner, Object.assign({}, childViewRect.inner));\n                expandRect(rect.outer, Object.assign({}, childViewRect.outer));\n            });\n\n        // calculate inner width and height\n        calculateRectSize(rect.inner);\n\n        // append additional margin (top and left margins are included in top and left automatically)\n        rect.outer.bottom += rect.element.marginBottom;\n        rect.outer.right += rect.element.marginRight;\n\n        // calculate outer width and height\n        calculateRectSize(rect.outer);\n\n        return rect;\n    };\n\n    var expandRect = function expandRect(parent, child) {\n        // adjust for parent offset\n        child.top += parent.top;\n        child.right += parent.left;\n        child.bottom += parent.top;\n        child.left += parent.left;\n\n        if (child.bottom > parent.bottom) {\n            parent.bottom = child.bottom;\n        }\n\n        if (child.right > parent.right) {\n            parent.right = child.right;\n        }\n    };\n\n    var calculateRectSize = function calculateRectSize(rect) {\n        rect.width = rect.right - rect.left;\n        rect.height = rect.bottom - rect.top;\n    };\n\n    var isNumber = function isNumber(value) {\n        return typeof value === 'number';\n    };\n\n    /**\n     * Determines if position is at destination\n     * @param position\n     * @param destination\n     * @param velocity\n     * @param errorMargin\n     * @returns {boolean}\n     */\n    var thereYet = function thereYet(position, destination, velocity) {\n        var errorMargin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;\n        return Math.abs(position - destination) < errorMargin && Math.abs(velocity) < errorMargin;\n    };\n\n    /**\n     * Spring animation\n     */\n    var spring =\n        // default options\n        function spring() // method definition\n        {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref$stiffness = _ref.stiffness,\n                stiffness = _ref$stiffness === void 0 ? 0.5 : _ref$stiffness,\n                _ref$damping = _ref.damping,\n                damping = _ref$damping === void 0 ? 0.75 : _ref$damping,\n                _ref$mass = _ref.mass,\n                mass = _ref$mass === void 0 ? 10 : _ref$mass;\n            var target = null;\n            var position = null;\n            var velocity = 0;\n            var resting = false;\n\n            // updates spring state\n            var interpolate = function interpolate(ts, skipToEndState) {\n                // in rest, don't animate\n                if (resting) return;\n\n                // need at least a target or position to do springy things\n                if (!(isNumber(target) && isNumber(position))) {\n                    resting = true;\n                    velocity = 0;\n                    return;\n                }\n\n                // calculate spring force\n                var f = -(position - target) * stiffness;\n\n                // update velocity by adding force based on mass\n                velocity += f / mass;\n\n                // update position by adding velocity\n                position += velocity;\n\n                // slow down based on amount of damping\n                velocity *= damping;\n\n                // we've arrived if we're near target and our velocity is near zero\n                if (thereYet(position, target, velocity) || skipToEndState) {\n                    position = target;\n                    velocity = 0;\n                    resting = true;\n\n                    // we done\n                    api.onupdate(position);\n                    api.oncomplete(position);\n                } else {\n                    // progress update\n                    api.onupdate(position);\n                }\n            };\n\n            /**\n             * Set new target value\n             * @param value\n             */\n            var setTarget = function setTarget(value) {\n                // if currently has no position, set target and position to this value\n                if (isNumber(value) && !isNumber(position)) {\n                    position = value;\n                }\n\n                // next target value will not be animated to\n                if (target === null) {\n                    target = value;\n                    position = value;\n                }\n\n                // let start moving to target\n                target = value;\n\n                // already at target\n                if (position === target || typeof target === 'undefined') {\n                    // now resting as target is current position, stop moving\n                    resting = true;\n                    velocity = 0;\n\n                    // done!\n                    api.onupdate(position);\n                    api.oncomplete(position);\n\n                    return;\n                }\n\n                resting = false;\n            };\n\n            // need 'api' to call onupdate callback\n            var api = createObject({\n                interpolate: interpolate,\n                target: {\n                    set: setTarget,\n                    get: function get() {\n                        return target;\n                    },\n                },\n\n                resting: {\n                    get: function get() {\n                        return resting;\n                    },\n                },\n\n                onupdate: function onupdate(value) {},\n                oncomplete: function oncomplete(value) {},\n            });\n\n            return api;\n        };\n\n    var easeLinear = function easeLinear(t) {\n        return t;\n    };\n    var easeInOutQuad = function easeInOutQuad(t) {\n        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n    };\n\n    var tween =\n        // default values\n        function tween() // method definition\n        {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref$duration = _ref.duration,\n                duration = _ref$duration === void 0 ? 500 : _ref$duration,\n                _ref$easing = _ref.easing,\n                easing = _ref$easing === void 0 ? easeInOutQuad : _ref$easing,\n                _ref$delay = _ref.delay,\n                delay = _ref$delay === void 0 ? 0 : _ref$delay;\n            var start = null;\n            var t;\n            var p;\n            var resting = true;\n            var reverse = false;\n            var target = null;\n\n            var interpolate = function interpolate(ts, skipToEndState) {\n                if (resting || target === null) return;\n\n                if (start === null) {\n                    start = ts;\n                }\n\n                if (ts - start < delay) return;\n\n                t = ts - start - delay;\n\n                if (t >= duration || skipToEndState) {\n                    t = 1;\n                    p = reverse ? 0 : 1;\n                    api.onupdate(p * target);\n                    api.oncomplete(p * target);\n                    resting = true;\n                } else {\n                    p = t / duration;\n                    api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);\n                }\n            };\n\n            // need 'api' to call onupdate callback\n            var api = createObject({\n                interpolate: interpolate,\n                target: {\n                    get: function get() {\n                        return reverse ? 0 : target;\n                    },\n                    set: function set(value) {\n                        // is initial value\n                        if (target === null) {\n                            target = value;\n                            api.onupdate(value);\n                            api.oncomplete(value);\n                            return;\n                        }\n\n                        // want to tween to a smaller value and have a current value\n                        if (value < target) {\n                            target = 1;\n                            reverse = true;\n                        } else {\n                            // not tweening to a smaller value\n                            reverse = false;\n                            target = value;\n                        }\n\n                        // let's go!\n                        resting = false;\n                        start = null;\n                    },\n                },\n\n                resting: {\n                    get: function get() {\n                        return resting;\n                    },\n                },\n\n                onupdate: function onupdate(value) {},\n                oncomplete: function oncomplete(value) {},\n            });\n\n            return api;\n        };\n\n    var animator = {\n        spring: spring,\n        tween: tween,\n    };\n\n    /*\n                       { type: 'spring', stiffness: .5, damping: .75, mass: 10 };\n                       { translation: { type: 'spring', ... }, ... }\n                       { translation: { x: { type: 'spring', ... } } }\n                      */\n    var createAnimator = function createAnimator(definition, category, property) {\n        // default is single definition\n        // we check if transform is set, if so, we check if property is set\n        var def =\n            definition[category] && typeof definition[category][property] === 'object'\n                ? definition[category][property]\n                : definition[category] || definition;\n\n        var type = typeof def === 'string' ? def : def.type;\n        var props = typeof def === 'object' ? Object.assign({}, def) : {};\n\n        return animator[type] ? animator[type](props) : null;\n    };\n\n    var addGetSet = function addGetSet(keys, obj, props) {\n        var overwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        obj = Array.isArray(obj) ? obj : [obj];\n        obj.forEach(function(o) {\n            keys.forEach(function(key) {\n                var name = key;\n                var getter = function getter() {\n                    return props[key];\n                };\n                var setter = function setter(value) {\n                    return (props[key] = value);\n                };\n\n                if (typeof key === 'object') {\n                    name = key.key;\n                    getter = key.getter || getter;\n                    setter = key.setter || setter;\n                }\n\n                if (o[name] && !overwrite) {\n                    return;\n                }\n\n                o[name] = {\n                    get: getter,\n                    set: setter,\n                };\n            });\n        });\n    };\n\n    // add to state,\n    // add getters and setters to internal and external api (if not set)\n    // setup animators\n\n    var animations = function animations(_ref) {\n        var mixinConfig = _ref.mixinConfig,\n            viewProps = _ref.viewProps,\n            viewInternalAPI = _ref.viewInternalAPI,\n            viewExternalAPI = _ref.viewExternalAPI;\n        // initial properties\n        var initialProps = Object.assign({}, viewProps);\n\n        // list of all active animations\n        var animations = [];\n\n        // setup animators\n        forin(mixinConfig, function(property, animation) {\n            var animator = createAnimator(animation);\n            if (!animator) {\n                return;\n            }\n\n            // when the animator updates, update the view state value\n            animator.onupdate = function(value) {\n                viewProps[property] = value;\n            };\n\n            // set animator target\n            animator.target = initialProps[property];\n\n            // when value is set, set the animator target value\n            var prop = {\n                key: property,\n                setter: function setter(value) {\n                    // if already at target, we done!\n                    if (animator.target === value) {\n                        return;\n                    }\n\n                    animator.target = value;\n                },\n                getter: function getter() {\n                    return viewProps[property];\n                },\n            };\n\n            // add getters and setters\n            addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);\n\n            // add it to the list for easy updating from the _write method\n            animations.push(animator);\n        });\n\n        // expose internal write api\n        return {\n            write: function write(ts) {\n                var skipToEndState = document.hidden;\n                var resting = true;\n                animations.forEach(function(animation) {\n                    if (!animation.resting) resting = false;\n                    animation.interpolate(ts, skipToEndState);\n                });\n                return resting;\n            },\n            destroy: function destroy() {},\n        };\n    };\n\n    var addEvent = function addEvent(element) {\n        return function(type, fn) {\n            element.addEventListener(type, fn);\n        };\n    };\n\n    var removeEvent = function removeEvent(element) {\n        return function(type, fn) {\n            element.removeEventListener(type, fn);\n        };\n    };\n\n    // mixin\n    var listeners = function listeners(_ref) {\n        var mixinConfig = _ref.mixinConfig,\n            viewProps = _ref.viewProps,\n            viewInternalAPI = _ref.viewInternalAPI,\n            viewExternalAPI = _ref.viewExternalAPI,\n            viewState = _ref.viewState,\n            view = _ref.view;\n        var events = [];\n\n        var add = addEvent(view.element);\n        var remove = removeEvent(view.element);\n\n        viewExternalAPI.on = function(type, fn) {\n            events.push({\n                type: type,\n                fn: fn,\n            });\n\n            add(type, fn);\n        };\n\n        viewExternalAPI.off = function(type, fn) {\n            events.splice(\n                events.findIndex(function(event) {\n                    return event.type === type && event.fn === fn;\n                }),\n                1\n            );\n\n            remove(type, fn);\n        };\n\n        return {\n            write: function write() {\n                // not busy\n                return true;\n            },\n            destroy: function destroy() {\n                events.forEach(function(event) {\n                    remove(event.type, event.fn);\n                });\n            },\n        };\n    };\n\n    // add to external api and link to props\n\n    var apis = function apis(_ref) {\n        var mixinConfig = _ref.mixinConfig,\n            viewProps = _ref.viewProps,\n            viewExternalAPI = _ref.viewExternalAPI;\n        addGetSet(mixinConfig, viewExternalAPI, viewProps);\n    };\n\n    var isDefined = function isDefined(value) {\n        return value != null;\n    };\n\n    // add to state,\n    // add getters and setters to internal and external api (if not set)\n    // set initial state based on props in viewProps\n    // apply as transforms each frame\n\n    var defaults = {\n        opacity: 1,\n        scaleX: 1,\n        scaleY: 1,\n        translateX: 0,\n        translateY: 0,\n        rotateX: 0,\n        rotateY: 0,\n        rotateZ: 0,\n        originX: 0,\n        originY: 0,\n    };\n\n    var styles = function styles(_ref) {\n        var mixinConfig = _ref.mixinConfig,\n            viewProps = _ref.viewProps,\n            viewInternalAPI = _ref.viewInternalAPI,\n            viewExternalAPI = _ref.viewExternalAPI,\n            view = _ref.view;\n        // initial props\n        var initialProps = Object.assign({}, viewProps);\n\n        // current props\n        var currentProps = {};\n\n        // we will add those properties to the external API and link them to the viewState\n        addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);\n\n        // override rect on internal and external rect getter so it takes in account transforms\n        var getOffset = function getOffset() {\n            return [viewProps['translateX'] || 0, viewProps['translateY'] || 0];\n        };\n\n        var getScale = function getScale() {\n            return [viewProps['scaleX'] || 0, viewProps['scaleY'] || 0];\n        };\n        var getRect = function getRect() {\n            return view.rect\n                ? getViewRect(view.rect, view.childViews, getOffset(), getScale())\n                : null;\n        };\n        viewInternalAPI.rect = { get: getRect };\n        viewExternalAPI.rect = { get: getRect };\n\n        // apply view props\n        mixinConfig.forEach(function(key) {\n            viewProps[key] =\n                typeof initialProps[key] === 'undefined' ? defaults[key] : initialProps[key];\n        });\n\n        // expose api\n        return {\n            write: function write() {\n                // see if props have changed\n                if (!propsHaveChanged(currentProps, viewProps)) {\n                    return;\n                }\n\n                // moves element to correct position on screen\n                applyStyles(view.element, viewProps);\n\n                // store new transforms\n                Object.assign(currentProps, Object.assign({}, viewProps));\n\n                // no longer busy\n                return true;\n            },\n            destroy: function destroy() {},\n        };\n    };\n\n    var propsHaveChanged = function propsHaveChanged(currentProps, newProps) {\n        // different amount of keys\n        if (Object.keys(currentProps).length !== Object.keys(newProps).length) {\n            return true;\n        }\n\n        // lets analyze the individual props\n        for (var prop in newProps) {\n            if (newProps[prop] !== currentProps[prop]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    var applyStyles = function applyStyles(element, _ref2) {\n        var opacity = _ref2.opacity,\n            perspective = _ref2.perspective,\n            translateX = _ref2.translateX,\n            translateY = _ref2.translateY,\n            scaleX = _ref2.scaleX,\n            scaleY = _ref2.scaleY,\n            rotateX = _ref2.rotateX,\n            rotateY = _ref2.rotateY,\n            rotateZ = _ref2.rotateZ,\n            originX = _ref2.originX,\n            originY = _ref2.originY,\n            width = _ref2.width,\n            height = _ref2.height;\n\n        var transforms = '';\n        var styles = '';\n\n        // handle transform origin\n        if (isDefined(originX) || isDefined(originY)) {\n            styles += 'transform-origin: ' + (originX || 0) + 'px ' + (originY || 0) + 'px;';\n        }\n\n        // transform order is relevant\n        // 0. perspective\n        if (isDefined(perspective)) {\n            transforms += 'perspective(' + perspective + 'px) ';\n        }\n\n        // 1. translate\n        if (isDefined(translateX) || isDefined(translateY)) {\n            transforms +=\n                'translate3d(' + (translateX || 0) + 'px, ' + (translateY || 0) + 'px, 0) ';\n        }\n\n        // 2. scale\n        if (isDefined(scaleX) || isDefined(scaleY)) {\n            transforms +=\n                'scale3d(' +\n                (isDefined(scaleX) ? scaleX : 1) +\n                ', ' +\n                (isDefined(scaleY) ? scaleY : 1) +\n                ', 1) ';\n        }\n\n        // 3. rotate\n        if (isDefined(rotateZ)) {\n            transforms += 'rotateZ(' + rotateZ + 'rad) ';\n        }\n\n        if (isDefined(rotateX)) {\n            transforms += 'rotateX(' + rotateX + 'rad) ';\n        }\n\n        if (isDefined(rotateY)) {\n            transforms += 'rotateY(' + rotateY + 'rad) ';\n        }\n\n        // add transforms\n        if (transforms.length) {\n            styles += 'transform:' + transforms + ';';\n        }\n\n        // add opacity\n        if (isDefined(opacity)) {\n            styles += 'opacity:' + opacity + ';';\n\n            // if we reach zero, we make the element inaccessible\n            if (opacity === 0) {\n                styles += 'visibility:hidden;';\n            }\n\n            // if we're below 100% opacity this element can't be clicked\n            if (opacity < 1) {\n                styles += 'pointer-events:none;';\n            }\n        }\n\n        // add height\n        if (isDefined(height)) {\n            styles += 'height:' + height + 'px;';\n        }\n\n        // add width\n        if (isDefined(width)) {\n            styles += 'width:' + width + 'px;';\n        }\n\n        // apply styles\n        var elementCurrentStyle = element.elementCurrentStyle || '';\n\n        // if new styles does not match current styles, lets update!\n        if (styles.length !== elementCurrentStyle.length || styles !== elementCurrentStyle) {\n            element.style.cssText = styles;\n            // store current styles so we can compare them to new styles later on\n            // _not_ getting the style value is faster\n            element.elementCurrentStyle = styles;\n        }\n    };\n\n    var Mixins = {\n        styles: styles,\n        listeners: listeners,\n        animations: animations,\n        apis: apis,\n    };\n\n    var updateRect = function updateRect() {\n        var rect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (!element.layoutCalculated) {\n            rect.paddingTop = parseInt(style.paddingTop, 10) || 0;\n            rect.marginTop = parseInt(style.marginTop, 10) || 0;\n            rect.marginRight = parseInt(style.marginRight, 10) || 0;\n            rect.marginBottom = parseInt(style.marginBottom, 10) || 0;\n            rect.marginLeft = parseInt(style.marginLeft, 10) || 0;\n            element.layoutCalculated = true;\n        }\n\n        rect.left = element.offsetLeft || 0;\n        rect.top = element.offsetTop || 0;\n        rect.width = element.offsetWidth || 0;\n        rect.height = element.offsetHeight || 0;\n\n        rect.right = rect.left + rect.width;\n        rect.bottom = rect.top + rect.height;\n\n        rect.scrollTop = element.scrollTop;\n\n        rect.hidden = element.offsetParent === null;\n\n        return rect;\n    };\n\n    var createView =\n        // default view definition\n        function createView() {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref$tag = _ref.tag,\n                tag = _ref$tag === void 0 ? 'div' : _ref$tag,\n                _ref$name = _ref.name,\n                name = _ref$name === void 0 ? null : _ref$name,\n                _ref$attributes = _ref.attributes,\n                attributes = _ref$attributes === void 0 ? {} : _ref$attributes,\n                _ref$read = _ref.read,\n                read = _ref$read === void 0 ? function() {} : _ref$read,\n                _ref$write = _ref.write,\n                write = _ref$write === void 0 ? function() {} : _ref$write,\n                _ref$create = _ref.create,\n                create = _ref$create === void 0 ? function() {} : _ref$create,\n                _ref$destroy = _ref.destroy,\n                destroy = _ref$destroy === void 0 ? function() {} : _ref$destroy,\n                _ref$filterFrameActio = _ref.filterFrameActionsForChild,\n                filterFrameActionsForChild =\n                    _ref$filterFrameActio === void 0\n                        ? function(child, actions) {\n                              return actions;\n                          }\n                        : _ref$filterFrameActio,\n                _ref$didCreateView = _ref.didCreateView,\n                didCreateView = _ref$didCreateView === void 0 ? function() {} : _ref$didCreateView,\n                _ref$didWriteView = _ref.didWriteView,\n                didWriteView = _ref$didWriteView === void 0 ? function() {} : _ref$didWriteView,\n                _ref$ignoreRect = _ref.ignoreRect,\n                ignoreRect = _ref$ignoreRect === void 0 ? false : _ref$ignoreRect,\n                _ref$ignoreRectUpdate = _ref.ignoreRectUpdate,\n                ignoreRectUpdate = _ref$ignoreRectUpdate === void 0 ? false : _ref$ignoreRectUpdate,\n                _ref$mixins = _ref.mixins,\n                mixins = _ref$mixins === void 0 ? [] : _ref$mixins;\n            return function(\n                // each view requires reference to store\n                store\n            ) {\n                var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                // root element should not be changed\n                var element = createElement(tag, 'filepond--' + name, attributes);\n\n                // style reference should also not be changed\n                var style = window.getComputedStyle(element, null);\n\n                // element rectangle\n                var rect = updateRect();\n                var frameRect = null;\n\n                // rest state\n                var isResting = false;\n\n                // pretty self explanatory\n                var childViews = [];\n\n                // loaded mixins\n                var activeMixins = [];\n\n                // references to created children\n                var ref = {};\n\n                // state used for each instance\n                var state = {};\n\n                // list of writers that will be called to update this view\n                var writers = [\n                    write, // default writer\n                ];\n\n                var readers = [\n                    read, // default reader\n                ];\n\n                var destroyers = [\n                    destroy, // default destroy\n                ];\n\n                // core view methods\n                var getElement = function getElement() {\n                    return element;\n                };\n                var getChildViews = function getChildViews() {\n                    return childViews.concat();\n                };\n                var getReference = function getReference() {\n                    return ref;\n                };\n                var createChildView = function createChildView(store) {\n                    return function(view, props) {\n                        return view(store, props);\n                    };\n                };\n                var getRect = function getRect() {\n                    if (frameRect) {\n                        return frameRect;\n                    }\n                    frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);\n                    return frameRect;\n                };\n                var getStyle = function getStyle() {\n                    return style;\n                };\n\n                /**\n                 * Read data from DOM\n                 * @private\n                 */\n                var _read = function _read() {\n                    frameRect = null;\n\n                    // read child views\n                    childViews.forEach(function(child) {\n                        return child._read();\n                    });\n\n                    var shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);\n                    if (shouldUpdate) {\n                        updateRect(rect, element, style);\n                    }\n\n                    // readers\n                    var api = { root: internalAPI, props: props, rect: rect };\n                    readers.forEach(function(reader) {\n                        return reader(api);\n                    });\n                };\n\n                /**\n                 * Write data to DOM\n                 * @private\n                 */\n                var _write = function _write(ts, frameActions, shouldOptimize) {\n                    // if no actions, we assume that the view is resting\n                    var resting = frameActions.length === 0;\n\n                    // writers\n                    writers.forEach(function(writer) {\n                        var writerResting = writer({\n                            props: props,\n                            root: internalAPI,\n                            actions: frameActions,\n                            timestamp: ts,\n                            shouldOptimize: shouldOptimize,\n                        });\n\n                        if (writerResting === false) {\n                            resting = false;\n                        }\n                    });\n\n                    // run mixins\n                    activeMixins.forEach(function(mixin) {\n                        // if one of the mixins is still busy after write operation, we are not resting\n                        var mixinResting = mixin.write(ts);\n                        if (mixinResting === false) {\n                            resting = false;\n                        }\n                    });\n\n                    // updates child views that are currently attached to the DOM\n                    childViews\n                        .filter(function(child) {\n                            return !!child.element.parentNode;\n                        })\n                        .forEach(function(child) {\n                            // if a child view is not resting, we are not resting\n                            var childResting = child._write(\n                                ts,\n                                filterFrameActionsForChild(child, frameActions),\n                                shouldOptimize\n                            );\n\n                            if (!childResting) {\n                                resting = false;\n                            }\n                        });\n\n                    // append new elements to DOM and update those\n                    childViews\n                        //.filter(child => !child.element.parentNode)\n                        .forEach(function(child, index) {\n                            // skip\n                            if (child.element.parentNode) {\n                                return;\n                            }\n\n                            // append to DOM\n                            internalAPI.appendChild(child.element, index);\n\n                            // call read (need to know the size of these elements)\n                            child._read();\n\n                            // re-call write\n                            child._write(\n                                ts,\n                                filterFrameActionsForChild(child, frameActions),\n                                shouldOptimize\n                            );\n\n                            // we just added somthing to the dom, no rest\n                            resting = false;\n                        });\n\n                    // update resting state\n                    isResting = resting;\n\n                    didWriteView({\n                        props: props,\n                        root: internalAPI,\n                        actions: frameActions,\n                        timestamp: ts,\n                    });\n\n                    // let parent know if we are resting\n                    return resting;\n                };\n\n                var _destroy = function _destroy() {\n                    activeMixins.forEach(function(mixin) {\n                        return mixin.destroy();\n                    });\n                    destroyers.forEach(function(destroyer) {\n                        destroyer({ root: internalAPI, props: props });\n                    });\n                    childViews.forEach(function(child) {\n                        return child._destroy();\n                    });\n                };\n\n                // sharedAPI\n                var sharedAPIDefinition = {\n                    element: {\n                        get: getElement,\n                    },\n\n                    style: {\n                        get: getStyle,\n                    },\n\n                    childViews: {\n                        get: getChildViews,\n                    },\n                };\n\n                // private API definition\n                var internalAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n                    rect: {\n                        get: getRect,\n                    },\n\n                    // access to custom children references\n                    ref: {\n                        get: getReference,\n                    },\n\n                    // dom modifiers\n                    is: function is(needle) {\n                        return name === needle;\n                    },\n                    appendChild: appendChild(element),\n                    createChildView: createChildView(store),\n                    linkView: function linkView(view) {\n                        childViews.push(view);\n                        return view;\n                    },\n                    unlinkView: function unlinkView(view) {\n                        childViews.splice(childViews.indexOf(view), 1);\n                    },\n                    appendChildView: appendChildView(element, childViews),\n                    removeChildView: removeChildView(element, childViews),\n                    registerWriter: function registerWriter(writer) {\n                        return writers.push(writer);\n                    },\n                    registerReader: function registerReader(reader) {\n                        return readers.push(reader);\n                    },\n                    registerDestroyer: function registerDestroyer(destroyer) {\n                        return destroyers.push(destroyer);\n                    },\n                    invalidateLayout: function invalidateLayout() {\n                        return (element.layoutCalculated = false);\n                    },\n\n                    // access to data store\n                    dispatch: store.dispatch,\n                    query: store.query,\n                });\n\n                // public view API methods\n                var externalAPIDefinition = {\n                    element: {\n                        get: getElement,\n                    },\n\n                    childViews: {\n                        get: getChildViews,\n                    },\n\n                    rect: {\n                        get: getRect,\n                    },\n\n                    resting: {\n                        get: function get() {\n                            return isResting;\n                        },\n                    },\n\n                    isRectIgnored: function isRectIgnored() {\n                        return ignoreRect;\n                    },\n                    _read: _read,\n                    _write: _write,\n                    _destroy: _destroy,\n                };\n\n                // mixin API methods\n                var mixinAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n                    rect: {\n                        get: function get() {\n                            return rect;\n                        },\n                    },\n                });\n\n                // add mixin functionality\n                Object.keys(mixins)\n                    .sort(function(a, b) {\n                        // move styles to the back of the mixin list (so adjustments of other mixins are applied to the props correctly)\n                        if (a === 'styles') {\n                            return 1;\n                        } else if (b === 'styles') {\n                            return -1;\n                        }\n                        return 0;\n                    })\n                    .forEach(function(key) {\n                        var mixinAPI = Mixins[key]({\n                            mixinConfig: mixins[key],\n                            viewProps: props,\n                            viewState: state,\n                            viewInternalAPI: internalAPIDefinition,\n                            viewExternalAPI: externalAPIDefinition,\n                            view: createObject(mixinAPIDefinition),\n                        });\n\n                        if (mixinAPI) {\n                            activeMixins.push(mixinAPI);\n                        }\n                    });\n\n                // construct private api\n                var internalAPI = createObject(internalAPIDefinition);\n\n                // create the view\n                create({\n                    root: internalAPI,\n                    props: props,\n                });\n\n                // append created child views to root node\n                var childCount = getChildCount(element); // need to know the current child count so appending happens in correct order\n                childViews.forEach(function(child, index) {\n                    internalAPI.appendChild(child.element, childCount + index);\n                });\n\n                // call did create\n                didCreateView(internalAPI);\n\n                // expose public api\n                return createObject(externalAPIDefinition);\n            };\n        };\n\n    var createPainter = function createPainter(read, write) {\n        var fps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n\n        var name = '__framePainter';\n\n        // set global painter\n        if (window[name]) {\n            window[name].readers.push(read);\n            window[name].writers.push(write);\n            return;\n        }\n\n        window[name] = {\n            readers: [read],\n            writers: [write],\n        };\n\n        var painter = window[name];\n\n        var interval = 1000 / fps;\n        var last = null;\n        var id = null;\n        var requestTick = null;\n        var cancelTick = null;\n\n        var setTimerType = function setTimerType() {\n            if (document.hidden) {\n                requestTick = function requestTick() {\n                    return window.setTimeout(function() {\n                        return tick(performance.now());\n                    }, interval);\n                };\n                cancelTick = function cancelTick() {\n                    return window.clearTimeout(id);\n                };\n            } else {\n                requestTick = function requestTick() {\n                    return window.requestAnimationFrame(tick);\n                };\n                cancelTick = function cancelTick() {\n                    return window.cancelAnimationFrame(id);\n                };\n            }\n        };\n\n        document.addEventListener('visibilitychange', function() {\n            if (cancelTick) cancelTick();\n            setTimerType();\n            tick(performance.now());\n        });\n\n        var tick = function tick(ts) {\n            // queue next tick\n            id = requestTick(tick);\n\n            // limit fps\n            if (!last) {\n                last = ts;\n            }\n\n            var delta = ts - last;\n\n            if (delta <= interval) {\n                // skip frame\n                return;\n            }\n\n            // align next frame\n            last = ts - (delta % interval);\n\n            // update view\n            painter.readers.forEach(function(read) {\n                return read();\n            });\n            painter.writers.forEach(function(write) {\n                return write(ts);\n            });\n        };\n\n        setTimerType();\n        tick(performance.now());\n\n        return {\n            pause: function pause() {\n                cancelTick(id);\n            },\n        };\n    };\n\n    var createRoute = function createRoute(routes, fn) {\n        return function(_ref) {\n            var root = _ref.root,\n                props = _ref.props,\n                _ref$actions = _ref.actions,\n                actions = _ref$actions === void 0 ? [] : _ref$actions,\n                timestamp = _ref.timestamp,\n                shouldOptimize = _ref.shouldOptimize;\n            actions\n                .filter(function(action) {\n                    return routes[action.type];\n                })\n                .forEach(function(action) {\n                    return routes[action.type]({\n                        root: root,\n                        props: props,\n                        action: action.data,\n                        timestamp: timestamp,\n                        shouldOptimize: shouldOptimize,\n                    });\n                });\n\n            if (fn) {\n                fn({\n                    root: root,\n                    props: props,\n                    actions: actions,\n                    timestamp: timestamp,\n                    shouldOptimize: shouldOptimize,\n                });\n            }\n        };\n    };\n\n    var insertBefore = function insertBefore(newNode, referenceNode) {\n        return referenceNode.parentNode.insertBefore(newNode, referenceNode);\n    };\n\n    var insertAfter = function insertAfter(newNode, referenceNode) {\n        return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n    };\n\n    var isArray = function isArray(value) {\n        return Array.isArray(value);\n    };\n\n    var isEmpty = function isEmpty(value) {\n        return value == null;\n    };\n\n    var trim = function trim(str) {\n        return str.trim();\n    };\n\n    var toString = function toString(value) {\n        return '' + value;\n    };\n\n    var toArray = function toArray(value) {\n        var splitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';\n        if (isEmpty(value)) {\n            return [];\n        }\n        if (isArray(value)) {\n            return value;\n        }\n        return toString(value)\n            .split(splitter)\n            .map(trim)\n            .filter(function(str) {\n                return str.length;\n            });\n    };\n\n    var isBoolean = function isBoolean(value) {\n        return typeof value === 'boolean';\n    };\n\n    var toBoolean = function toBoolean(value) {\n        return isBoolean(value) ? value : value === 'true';\n    };\n\n    var isString = function isString(value) {\n        return typeof value === 'string';\n    };\n\n    var toNumber = function toNumber(value) {\n        return isNumber(value)\n            ? value\n            : isString(value)\n            ? toString(value).replace(/[a-z]+/gi, '')\n            : 0;\n    };\n\n    var toInt = function toInt(value) {\n        return parseInt(toNumber(value), 10);\n    };\n\n    var toFloat = function toFloat(value) {\n        return parseFloat(toNumber(value));\n    };\n\n    var isInt = function isInt(value) {\n        return isNumber(value) && isFinite(value) && Math.floor(value) === value;\n    };\n\n    var toBytes = function toBytes(value) {\n        var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n        // is in bytes\n        if (isInt(value)) {\n            return value;\n        }\n\n        // is natural file size\n        var naturalFileSize = toString(value).trim();\n\n        // if is value in megabytes\n        if (/MB$/i.test(naturalFileSize)) {\n            naturalFileSize = naturalFileSize.replace(/MB$i/, '').trim();\n            return toInt(naturalFileSize) * base * base;\n        }\n\n        // if is value in kilobytes\n        if (/KB/i.test(naturalFileSize)) {\n            naturalFileSize = naturalFileSize.replace(/KB$i/, '').trim();\n            return toInt(naturalFileSize) * base;\n        }\n\n        return toInt(naturalFileSize);\n    };\n\n    var isFunction = function isFunction(value) {\n        return typeof value === 'function';\n    };\n\n    var toFunctionReference = function toFunctionReference(string) {\n        var ref = self;\n        var levels = string.split('.');\n        var level = null;\n        while ((level = levels.shift())) {\n            ref = ref[level];\n            if (!ref) {\n                return null;\n            }\n        }\n        return ref;\n    };\n\n    var methods = {\n        process: 'POST',\n        patch: 'PATCH',\n        revert: 'DELETE',\n        fetch: 'GET',\n        restore: 'GET',\n        load: 'GET',\n    };\n\n    var createServerAPI = function createServerAPI(outline) {\n        var api = {};\n\n        api.url = isString(outline) ? outline : outline.url || '';\n        api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;\n        api.headers = outline.headers ? outline.headers : {};\n\n        forin(methods, function(key) {\n            api[key] = createAction(key, outline[key], methods[key], api.timeout, api.headers);\n        });\n\n        // remove process if no url or process on outline\n        api.process = outline.process || isString(outline) || outline.url ? api.process : null;\n\n        // special treatment for remove\n        api.remove = outline.remove || null;\n\n        // remove generic headers from api object\n        delete api.headers;\n\n        return api;\n    };\n\n    var createAction = function createAction(name, outline, method, timeout, headers) {\n        // is explicitely set to null so disable\n        if (outline === null) {\n            return null;\n        }\n\n        // if is custom function, done! Dev handles everything.\n        if (typeof outline === 'function') {\n            return outline;\n        }\n\n        // build action object\n        var action = {\n            url: method === 'GET' || method === 'PATCH' ? '?' + name + '=' : '',\n            method: method,\n            headers: headers,\n            withCredentials: false,\n            timeout: timeout,\n            onload: null,\n            ondata: null,\n            onerror: null,\n        };\n\n        // is a single url\n        if (isString(outline)) {\n            action.url = outline;\n            return action;\n        }\n\n        // overwrite\n        Object.assign(action, outline);\n\n        // see if should reformat headers;\n        if (isString(action.headers)) {\n            var parts = action.headers.split(/:(.+)/);\n            action.headers = {\n                header: parts[0],\n                value: parts[1],\n            };\n        }\n\n        // if is bool withCredentials\n        action.withCredentials = toBoolean(action.withCredentials);\n\n        return action;\n    };\n\n    var toServerAPI = function toServerAPI(value) {\n        return createServerAPI(value);\n    };\n\n    var isNull = function isNull(value) {\n        return value === null;\n    };\n\n    var isObject = function isObject(value) {\n        return typeof value === 'object' && value !== null;\n    };\n\n    var isAPI = function isAPI(value) {\n        return (\n            isObject(value) &&\n            isString(value.url) &&\n            isObject(value.process) &&\n            isObject(value.revert) &&\n            isObject(value.restore) &&\n            isObject(value.fetch)\n        );\n    };\n\n    var getType = function getType(value) {\n        if (isArray(value)) {\n            return 'array';\n        }\n\n        if (isNull(value)) {\n            return 'null';\n        }\n\n        if (isInt(value)) {\n            return 'int';\n        }\n\n        if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {\n            return 'bytes';\n        }\n\n        if (isAPI(value)) {\n            return 'api';\n        }\n\n        return typeof value;\n    };\n\n    var replaceSingleQuotes = function replaceSingleQuotes(str) {\n        return str\n            .replace(/{\\s*'/g, '{\"')\n            .replace(/'\\s*}/g, '\"}')\n            .replace(/'\\s*:/g, '\":')\n            .replace(/:\\s*'/g, ':\"')\n            .replace(/,\\s*'/g, ',\"')\n            .replace(/'\\s*,/g, '\",');\n    };\n\n    var conversionTable = {\n        array: toArray,\n        boolean: toBoolean,\n        int: function int(value) {\n            return getType(value) === 'bytes' ? toBytes(value) : toInt(value);\n        },\n        number: toFloat,\n        float: toFloat,\n        bytes: toBytes,\n        string: function string(value) {\n            return isFunction(value) ? value : toString(value);\n        },\n        function: function _function(value) {\n            return toFunctionReference(value);\n        },\n        serverapi: toServerAPI,\n        object: function object(value) {\n            try {\n                return JSON.parse(replaceSingleQuotes(value));\n            } catch (e) {\n                return null;\n            }\n        },\n    };\n\n    var convertTo = function convertTo(value, type) {\n        return conversionTable[type](value);\n    };\n\n    var getValueByType = function getValueByType(newValue, defaultValue, valueType) {\n        // can always assign default value\n        if (newValue === defaultValue) {\n            return newValue;\n        }\n\n        // get the type of the new value\n        var newValueType = getType(newValue);\n\n        // is valid type?\n        if (newValueType !== valueType) {\n            // is string input, let's attempt to convert\n            var convertedValue = convertTo(newValue, valueType);\n\n            // what is the type now\n            newValueType = getType(convertedValue);\n\n            // no valid conversions found\n            if (convertedValue === null) {\n                throw 'Trying to assign value with incorrect type to \"' +\n                    option +\n                    '\", allowed type: \"' +\n                    valueType +\n                    '\"';\n            } else {\n                newValue = convertedValue;\n            }\n        }\n\n        // assign new value\n        return newValue;\n    };\n\n    var createOption = function createOption(defaultValue, valueType) {\n        var currentValue = defaultValue;\n        return {\n            enumerable: true,\n            get: function get() {\n                return currentValue;\n            },\n            set: function set(newValue) {\n                currentValue = getValueByType(newValue, defaultValue, valueType);\n            },\n        };\n    };\n\n    var createOptions = function createOptions(options) {\n        var obj = {};\n        forin(options, function(prop) {\n            var optionDefinition = options[prop];\n            obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);\n        });\n        return createObject(obj);\n    };\n\n    var createInitialState = function createInitialState(options) {\n        return {\n            // model\n            items: [],\n\n            // timeout used for calling update items\n            listUpdateTimeout: null,\n\n            // timeout used for stacking metadata updates\n            itemUpdateTimeout: null,\n\n            // queue of items waiting to be processed\n            processingQueue: [],\n\n            // options\n            options: createOptions(options),\n        };\n    };\n\n    var fromCamels = function fromCamels(string) {\n        var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n        return string\n            .split(/(?=[A-Z])/)\n            .map(function(part) {\n                return part.toLowerCase();\n            })\n            .join(separator);\n    };\n\n    var createOptionAPI = function createOptionAPI(store, options) {\n        var obj = {};\n        forin(options, function(key) {\n            obj[key] = {\n                get: function get() {\n                    return store.getState().options[key];\n                },\n                set: function set(value) {\n                    store.dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n                        value: value,\n                    });\n                },\n            };\n        });\n        return obj;\n    };\n\n    var createOptionActions = function createOptionActions(options) {\n        return function(dispatch, query, state) {\n            var obj = {};\n            forin(options, function(key) {\n                var name = fromCamels(key, '_').toUpperCase();\n\n                obj['SET_' + name] = function(action) {\n                    try {\n                        state.options[key] = action.value;\n                    } catch (e) {} // nope, failed\n\n                    // we successfully set the value of this option\n                    dispatch('DID_SET_' + name, { value: state.options[key] });\n                };\n            });\n            return obj;\n        };\n    };\n\n    var createOptionQueries = function createOptionQueries(options) {\n        return function(state) {\n            var obj = {};\n            forin(options, function(key) {\n                obj['GET_' + fromCamels(key, '_').toUpperCase()] = function(action) {\n                    return state.options[key];\n                };\n            });\n            return obj;\n        };\n    };\n\n    var InteractionMethod = {\n        API: 1,\n        DROP: 2,\n        BROWSE: 3,\n        PASTE: 4,\n        NONE: 5,\n    };\n\n    var getUniqueId = function getUniqueId() {\n        return Math.random()\n            .toString(36)\n            .substring(2, 11);\n    };\n\n    function _typeof(obj) {\n        if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n            _typeof = function(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof = function(obj) {\n                return obj &&\n                    typeof Symbol === 'function' &&\n                    obj.constructor === Symbol &&\n                    obj !== Symbol.prototype\n                    ? 'symbol'\n                    : typeof obj;\n            };\n        }\n\n        return _typeof(obj);\n    }\n\n    var REACT_ELEMENT_TYPE;\n\n    function _jsx(type, props, key, children) {\n        if (!REACT_ELEMENT_TYPE) {\n            REACT_ELEMENT_TYPE =\n                (typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element')) ||\n                0xeac7;\n        }\n\n        var defaultProps = type && type.defaultProps;\n        var childrenLength = arguments.length - 3;\n\n        if (!props && childrenLength !== 0) {\n            props = {\n                children: void 0,\n            };\n        }\n\n        if (props && defaultProps) {\n            for (var propName in defaultProps) {\n                if (props[propName] === void 0) {\n                    props[propName] = defaultProps[propName];\n                }\n            }\n        } else if (!props) {\n            props = defaultProps || {};\n        }\n\n        if (childrenLength === 1) {\n            props.children = children;\n        } else if (childrenLength > 1) {\n            var childArray = new Array(childrenLength);\n\n            for (var i = 0; i < childrenLength; i++) {\n                childArray[i] = arguments[i + 3];\n            }\n\n            props.children = childArray;\n        }\n\n        return {\n            $$typeof: REACT_ELEMENT_TYPE,\n            type: type,\n            key: key === undefined ? null : '' + key,\n            ref: null,\n            props: props,\n            _owner: null,\n        };\n    }\n\n    function _asyncIterator(iterable) {\n        var method;\n\n        if (typeof Symbol !== 'undefined') {\n            if (Symbol.asyncIterator) {\n                method = iterable[Symbol.asyncIterator];\n                if (method != null) return method.call(iterable);\n            }\n\n            if (Symbol.iterator) {\n                method = iterable[Symbol.iterator];\n                if (method != null) return method.call(iterable);\n            }\n        }\n\n        throw new TypeError('Object is not async iterable');\n    }\n\n    function _AwaitValue(value) {\n        this.wrapped = value;\n    }\n\n    function _AsyncGenerator(gen) {\n        var front, back;\n\n        function send(key, arg) {\n            return new Promise(function(resolve, reject) {\n                var request = {\n                    key: key,\n                    arg: arg,\n                    resolve: resolve,\n                    reject: reject,\n                    next: null,\n                };\n\n                if (back) {\n                    back = back.next = request;\n                } else {\n                    front = back = request;\n                    resume(key, arg);\n                }\n            });\n        }\n\n        function resume(key, arg) {\n            try {\n                var result = gen[key](arg);\n                var value = result.value;\n                var wrappedAwait = value instanceof _AwaitValue;\n                Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n                    function(arg) {\n                        if (wrappedAwait) {\n                            resume('next', arg);\n                            return;\n                        }\n\n                        settle(result.done ? 'return' : 'normal', arg);\n                    },\n                    function(err) {\n                        resume('throw', err);\n                    }\n                );\n            } catch (err) {\n                settle('throw', err);\n            }\n        }\n\n        function settle(type, value) {\n            switch (type) {\n                case 'return':\n                    front.resolve({\n                        value: value,\n                        done: true,\n                    });\n                    break;\n\n                case 'throw':\n                    front.reject(value);\n                    break;\n\n                default:\n                    front.resolve({\n                        value: value,\n                        done: false,\n                    });\n                    break;\n            }\n\n            front = front.next;\n\n            if (front) {\n                resume(front.key, front.arg);\n            } else {\n                back = null;\n            }\n        }\n\n        this._invoke = send;\n\n        if (typeof gen.return !== 'function') {\n            this.return = undefined;\n        }\n    }\n\n    if (typeof Symbol === 'function' && Symbol.asyncIterator) {\n        _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {\n            return this;\n        };\n    }\n\n    _AsyncGenerator.prototype.next = function(arg) {\n        return this._invoke('next', arg);\n    };\n\n    _AsyncGenerator.prototype.throw = function(arg) {\n        return this._invoke('throw', arg);\n    };\n\n    _AsyncGenerator.prototype.return = function(arg) {\n        return this._invoke('return', arg);\n    };\n\n    function _wrapAsyncGenerator(fn) {\n        return function() {\n            return new _AsyncGenerator(fn.apply(this, arguments));\n        };\n    }\n\n    function _awaitAsyncGenerator(value) {\n        return new _AwaitValue(value);\n    }\n\n    function _asyncGeneratorDelegate(inner, awaitWrap) {\n        var iter = {},\n            waiting = false;\n\n        function pump(key, value) {\n            waiting = true;\n            value = new Promise(function(resolve) {\n                resolve(inner[key](value));\n            });\n            return {\n                done: false,\n                value: awaitWrap(value),\n            };\n        }\n\n        if (typeof Symbol === 'function' && Symbol.iterator) {\n            iter[Symbol.iterator] = function() {\n                return this;\n            };\n        }\n\n        iter.next = function(value) {\n            if (waiting) {\n                waiting = false;\n                return value;\n            }\n\n            return pump('next', value);\n        };\n\n        if (typeof inner.throw === 'function') {\n            iter.throw = function(value) {\n                if (waiting) {\n                    waiting = false;\n                    throw value;\n                }\n\n                return pump('throw', value);\n            };\n        }\n\n        if (typeof inner.return === 'function') {\n            iter.return = function(value) {\n                return pump('return', value);\n            };\n        }\n\n        return iter;\n    }\n\n    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n        try {\n            var info = gen[key](arg);\n            var value = info.value;\n        } catch (error) {\n            reject(error);\n            return;\n        }\n\n        if (info.done) {\n            resolve(value);\n        } else {\n            Promise.resolve(value).then(_next, _throw);\n        }\n    }\n\n    function _asyncToGenerator(fn) {\n        return function() {\n            var self = this,\n                args = arguments;\n            return new Promise(function(resolve, reject) {\n                var gen = fn.apply(self, args);\n\n                function _next(value) {\n                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n                }\n\n                function _throw(err) {\n                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n                }\n\n                _next(undefined);\n            });\n        };\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError('Cannot call a class as a function');\n        }\n    }\n\n    function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if ('value' in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n\n    function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n    }\n\n    function _defineEnumerableProperties(obj, descs) {\n        for (var key in descs) {\n            var desc = descs[key];\n            desc.configurable = desc.enumerable = true;\n            if ('value' in desc) desc.writable = true;\n            Object.defineProperty(obj, key, desc);\n        }\n\n        if (Object.getOwnPropertySymbols) {\n            var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n            for (var i = 0; i < objectSymbols.length; i++) {\n                var sym = objectSymbols[i];\n                var desc = descs[sym];\n                desc.configurable = desc.enumerable = true;\n                if ('value' in desc) desc.writable = true;\n                Object.defineProperty(obj, sym, desc);\n            }\n        }\n\n        return obj;\n    }\n\n    function _defaults(obj, defaults) {\n        var keys = Object.getOwnPropertyNames(defaults);\n\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n            if (value && value.configurable && obj[key] === undefined) {\n                Object.defineProperty(obj, key, value);\n            }\n        }\n\n        return obj;\n    }\n\n    function _defineProperty(obj, key, value) {\n        if (key in obj) {\n            Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true,\n            });\n        } else {\n            obj[key] = value;\n        }\n\n        return obj;\n    }\n\n    function _extends() {\n        _extends =\n            Object.assign ||\n            function(target) {\n                for (var i = 1; i < arguments.length; i++) {\n                    var source = arguments[i];\n\n                    for (var key in source) {\n                        if (Object.prototype.hasOwnProperty.call(source, key)) {\n                            target[key] = source[key];\n                        }\n                    }\n                }\n\n                return target;\n            };\n\n        return _extends.apply(this, arguments);\n    }\n\n    function _objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i] != null ? arguments[i] : {};\n            var ownKeys = Object.keys(source);\n\n            if (typeof Object.getOwnPropertySymbols === 'function') {\n                ownKeys = ownKeys.concat(\n                    Object.getOwnPropertySymbols(source).filter(function(sym) {\n                        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n                    })\n                );\n            }\n\n            ownKeys.forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        }\n\n        return target;\n    }\n\n    function ownKeys(object, enumerableOnly) {\n        var keys = Object.keys(object);\n\n        if (Object.getOwnPropertySymbols) {\n            var symbols = Object.getOwnPropertySymbols(object);\n            if (enumerableOnly)\n                symbols = symbols.filter(function(sym) {\n                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n                });\n            keys.push.apply(keys, symbols);\n        }\n\n        return keys;\n    }\n\n    function _objectSpread2(target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i] != null ? arguments[i] : {};\n\n            if (i % 2) {\n                ownKeys(source, true).forEach(function(key) {\n                    _defineProperty(target, key, source[key]);\n                });\n            } else if (Object.getOwnPropertyDescriptors) {\n                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n            } else {\n                ownKeys(source).forEach(function(key) {\n                    Object.defineProperty(\n                        target,\n                        key,\n                        Object.getOwnPropertyDescriptor(source, key)\n                    );\n                });\n            }\n        }\n\n        return target;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== 'function' && superClass !== null) {\n            throw new TypeError('Super expression must either be null or a function');\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                writable: true,\n                configurable: true,\n            },\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n    }\n\n    function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n    }\n\n    function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf\n            ? Object.getPrototypeOf\n            : function _getPrototypeOf(o) {\n                  return o.__proto__ || Object.getPrototypeOf(o);\n              };\n        return _getPrototypeOf(o);\n    }\n\n    function _setPrototypeOf(o, p) {\n        _setPrototypeOf =\n            Object.setPrototypeOf ||\n            function _setPrototypeOf(o, p) {\n                o.__proto__ = p;\n                return o;\n            };\n\n        return _setPrototypeOf(o, p);\n    }\n\n    function isNativeReflectConstruct() {\n        if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\n        if (Reflect.construct.sham) return false;\n        if (typeof Proxy === 'function') return true;\n\n        try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    function _construct(Parent, args, Class) {\n        if (isNativeReflectConstruct()) {\n            _construct = Reflect.construct;\n        } else {\n            _construct = function _construct(Parent, args, Class) {\n                var a = [null];\n                a.push.apply(a, args);\n                var Constructor = Function.bind.apply(Parent, a);\n                var instance = new Constructor();\n                if (Class) _setPrototypeOf(instance, Class.prototype);\n                return instance;\n            };\n        }\n\n        return _construct.apply(null, arguments);\n    }\n\n    function _isNativeFunction(fn) {\n        return Function.toString.call(fn).indexOf('[native code]') !== -1;\n    }\n\n    function _wrapNativeSuper(Class) {\n        var _cache = typeof Map === 'function' ? new Map() : undefined;\n\n        _wrapNativeSuper = function _wrapNativeSuper(Class) {\n            if (Class === null || !_isNativeFunction(Class)) return Class;\n\n            if (typeof Class !== 'function') {\n                throw new TypeError('Super expression must either be null or a function');\n            }\n\n            if (typeof _cache !== 'undefined') {\n                if (_cache.has(Class)) return _cache.get(Class);\n\n                _cache.set(Class, Wrapper);\n            }\n\n            function Wrapper() {\n                return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n            }\n\n            Wrapper.prototype = Object.create(Class.prototype, {\n                constructor: {\n                    value: Wrapper,\n                    enumerable: false,\n                    writable: true,\n                    configurable: true,\n                },\n            });\n            return _setPrototypeOf(Wrapper, Class);\n        };\n\n        return _wrapNativeSuper(Class);\n    }\n\n    function _instanceof(left, right) {\n        if (right != null && typeof Symbol !== 'undefined' && right[Symbol.hasInstance]) {\n            return !!right[Symbol.hasInstance](left);\n        } else {\n            return left instanceof right;\n        }\n    }\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule\n            ? obj\n            : {\n                  default: obj,\n              };\n    }\n\n    function _interopRequireWildcard(obj) {\n        if (obj && obj.__esModule) {\n            return obj;\n        } else {\n            var newObj = {};\n\n            if (obj != null) {\n                for (var key in obj) {\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc =\n                            Object.defineProperty && Object.getOwnPropertyDescriptor\n                                ? Object.getOwnPropertyDescriptor(obj, key)\n                                : {};\n\n                        if (desc.get || desc.set) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n            }\n\n            newObj.default = obj;\n            return newObj;\n        }\n    }\n\n    function _newArrowCheck(innerThis, boundThis) {\n        if (innerThis !== boundThis) {\n            throw new TypeError('Cannot instantiate an arrow function');\n        }\n    }\n\n    function _objectDestructuringEmpty(obj) {\n        if (obj == null) throw new TypeError('Cannot destructure undefined');\n    }\n\n    function _objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n\n        for (i = 0; i < sourceKeys.length; i++) {\n            key = sourceKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n\n        return target;\n    }\n\n    function _objectWithoutProperties(source, excluded) {\n        if (source == null) return {};\n\n        var target = _objectWithoutPropertiesLoose(source, excluded);\n\n        var key, i;\n\n        if (Object.getOwnPropertySymbols) {\n            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n            for (i = 0; i < sourceSymbolKeys.length; i++) {\n                key = sourceSymbolKeys[i];\n                if (excluded.indexOf(key) >= 0) continue;\n                if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                target[key] = source[key];\n            }\n        }\n\n        return target;\n    }\n\n    function _assertThisInitialized(self) {\n        if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n    }\n\n    function _possibleConstructorReturn(self, call) {\n        if (call && (typeof call === 'object' || typeof call === 'function')) {\n            return call;\n        }\n\n        return _assertThisInitialized(self);\n    }\n\n    function _superPropBase(object, property) {\n        while (!Object.prototype.hasOwnProperty.call(object, property)) {\n            object = _getPrototypeOf(object);\n            if (object === null) break;\n        }\n\n        return object;\n    }\n\n    function _get(target, property, receiver) {\n        if (typeof Reflect !== 'undefined' && Reflect.get) {\n            _get = Reflect.get;\n        } else {\n            _get = function _get(target, property, receiver) {\n                var base = _superPropBase(target, property);\n\n                if (!base) return;\n                var desc = Object.getOwnPropertyDescriptor(base, property);\n\n                if (desc.get) {\n                    return desc.get.call(receiver);\n                }\n\n                return desc.value;\n            };\n        }\n\n        return _get(target, property, receiver || target);\n    }\n\n    function set(target, property, value, receiver) {\n        if (typeof Reflect !== 'undefined' && Reflect.set) {\n            set = Reflect.set;\n        } else {\n            set = function set(target, property, value, receiver) {\n                var base = _superPropBase(target, property);\n\n                var desc;\n\n                if (base) {\n                    desc = Object.getOwnPropertyDescriptor(base, property);\n\n                    if (desc.set) {\n                        desc.set.call(receiver, value);\n                        return true;\n                    } else if (!desc.writable) {\n                        return false;\n                    }\n                }\n\n                desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n                if (desc) {\n                    if (!desc.writable) {\n                        return false;\n                    }\n\n                    desc.value = value;\n                    Object.defineProperty(receiver, property, desc);\n                } else {\n                    _defineProperty(receiver, property, value);\n                }\n\n                return true;\n            };\n        }\n\n        return set(target, property, value, receiver);\n    }\n\n    function _set(target, property, value, receiver, isStrict) {\n        var s = set(target, property, value, receiver || target);\n\n        if (!s && isStrict) {\n            throw new Error('failed to set property');\n        }\n\n        return value;\n    }\n\n    function _taggedTemplateLiteral(strings, raw) {\n        if (!raw) {\n            raw = strings.slice(0);\n        }\n\n        return Object.freeze(\n            Object.defineProperties(strings, {\n                raw: {\n                    value: Object.freeze(raw),\n                },\n            })\n        );\n    }\n\n    function _taggedTemplateLiteralLoose(strings, raw) {\n        if (!raw) {\n            raw = strings.slice(0);\n        }\n\n        strings.raw = raw;\n        return strings;\n    }\n\n    function _temporalRef(val, name) {\n        if (val === _temporalUndefined) {\n            throw new ReferenceError(name + ' is not defined - temporal dead zone');\n        } else {\n            return val;\n        }\n    }\n\n    function _readOnlyError(name) {\n        throw new Error('\"' + name + '\" is read-only');\n    }\n\n    function _classNameTDZError(name) {\n        throw new Error('Class \"' + name + '\" cannot be referenced in computed property keys.');\n    }\n\n    var _temporalUndefined = {};\n\n    function _slicedToArray(arr, i) {\n        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n    }\n\n    function _slicedToArrayLoose(arr, i) {\n        return _arrayWithHoles(arr) || _iterableToArrayLimitLoose(arr, i) || _nonIterableRest();\n    }\n\n    function _toArray(arr) {\n        return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n    }\n\n    function _toConsumableArray(arr) {\n        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n    }\n\n    function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr)) {\n            for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n            return arr2;\n        }\n    }\n\n    function _arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n    }\n\n    function _iterableToArray(iter) {\n        if (\n            Symbol.iterator in Object(iter) ||\n            Object.prototype.toString.call(iter) === '[object Arguments]'\n        )\n            return Array.from(iter);\n    }\n\n    function _iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n                _arr.push(_s.value);\n\n                if (i && _arr.length === i) break;\n            }\n        } catch (err) {\n            _d = true;\n            _e = err;\n        } finally {\n            try {\n                if (!_n && _i['return'] != null) _i['return']();\n            } finally {\n                if (_d) throw _e;\n            }\n        }\n\n        return _arr;\n    }\n\n    function _iterableToArrayLimitLoose(arr, i) {\n        var _arr = [];\n\n        for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done; ) {\n            _arr.push(_step.value);\n\n            if (i && _arr.length === i) break;\n        }\n\n        return _arr;\n    }\n\n    function _nonIterableSpread() {\n        throw new TypeError('Invalid attempt to spread non-iterable instance');\n    }\n\n    function _nonIterableRest() {\n        throw new TypeError('Invalid attempt to destructure non-iterable instance');\n    }\n\n    function _skipFirstGeneratorNext(fn) {\n        return function() {\n            var it = fn.apply(this, arguments);\n            it.next();\n            return it;\n        };\n    }\n\n    function _toPrimitive(input, hint) {\n        if (typeof input !== 'object' || input === null) return input;\n        var prim = input[Symbol.toPrimitive];\n\n        if (prim !== undefined) {\n            var res = prim.call(input, hint || 'default');\n            if (typeof res !== 'object') return res;\n            throw new TypeError('@@toPrimitive must return a primitive value.');\n        }\n\n        return (hint === 'string' ? String : Number)(input);\n    }\n\n    function _toPropertyKey(arg) {\n        var key = _toPrimitive(arg, 'string');\n\n        return typeof key === 'symbol' ? key : String(key);\n    }\n\n    function _initializerWarningHelper(descriptor, context) {\n        throw new Error(\n            'Decorating class property failed. Please ensure that ' +\n                'proposal-class-properties is enabled and set to use loose mode. ' +\n                'To use proposal-class-properties in spec mode with decorators, wait for ' +\n                'the next major version of decorators in stage 2.'\n        );\n    }\n\n    function _initializerDefineProperty(target, property, descriptor, context) {\n        if (!descriptor) return;\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n\n    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n        var desc = {};\n        Object.keys(descriptor).forEach(function(key) {\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n\n        if ('value' in desc || desc.initializer) {\n            desc.writable = true;\n        }\n\n        desc = decorators\n            .slice()\n            .reverse()\n            .reduce(function(desc, decorator) {\n                return decorator(target, property, desc) || desc;\n            }, desc);\n\n        if (context && desc.initializer !== void 0) {\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0) {\n            Object.defineProperty(target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n\n    var id = 0;\n\n    function _classPrivateFieldLooseKey(name) {\n        return '__private_' + id++ + '_' + name;\n    }\n\n    function _classPrivateFieldLooseBase(receiver, privateKey) {\n        if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n            throw new TypeError('attempted to use private field on non-instance');\n        }\n\n        return receiver;\n    }\n\n    function _classPrivateFieldGet(receiver, privateMap) {\n        var descriptor = privateMap.get(receiver);\n\n        if (!descriptor) {\n            throw new TypeError('attempted to get private field on non-instance');\n        }\n\n        if (descriptor.get) {\n            return descriptor.get.call(receiver);\n        }\n\n        return descriptor.value;\n    }\n\n    function _classPrivateFieldSet(receiver, privateMap, value) {\n        var descriptor = privateMap.get(receiver);\n\n        if (!descriptor) {\n            throw new TypeError('attempted to set private field on non-instance');\n        }\n\n        if (descriptor.set) {\n            descriptor.set.call(receiver, value);\n        } else {\n            if (!descriptor.writable) {\n                throw new TypeError('attempted to set read only private field');\n            }\n\n            descriptor.value = value;\n        }\n\n        return value;\n    }\n\n    function _classPrivateFieldDestructureSet(receiver, privateMap) {\n        if (!privateMap.has(receiver)) {\n            throw new TypeError('attempted to set private field on non-instance');\n        }\n\n        var descriptor = privateMap.get(receiver);\n\n        if (descriptor.set) {\n            if (!('__destrObj' in descriptor)) {\n                descriptor.__destrObj = {\n                    set value(v) {\n                        descriptor.set.call(receiver, v);\n                    },\n                };\n            }\n\n            return descriptor.__destrObj;\n        } else {\n            if (!descriptor.writable) {\n                throw new TypeError('attempted to set read only private field');\n            }\n\n            return descriptor;\n        }\n    }\n\n    function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n        if (receiver !== classConstructor) {\n            throw new TypeError('Private static access of wrong provenance');\n        }\n\n        return descriptor.value;\n    }\n\n    function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n        if (receiver !== classConstructor) {\n            throw new TypeError('Private static access of wrong provenance');\n        }\n\n        if (!descriptor.writable) {\n            throw new TypeError('attempted to set read only private field');\n        }\n\n        descriptor.value = value;\n        return value;\n    }\n\n    function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n        if (receiver !== classConstructor) {\n            throw new TypeError('Private static access of wrong provenance');\n        }\n\n        return method;\n    }\n\n    function _classStaticPrivateMethodSet() {\n        throw new TypeError('attempted to set read only static private field');\n    }\n\n    function _decorate(decorators, factory, superClass, mixins) {\n        var api = _getDecoratorsApi();\n\n        if (mixins) {\n            for (var i = 0; i < mixins.length; i++) {\n                api = mixins[i](api);\n            }\n        }\n\n        var r = factory(function initialize(O) {\n            api.initializeInstanceElements(O, decorated.elements);\n        }, superClass);\n        var decorated = api.decorateClass(\n            _coalesceClassElements(r.d.map(_createElementDescriptor)),\n            decorators\n        );\n        api.initializeClassElements(r.F, decorated.elements);\n        return api.runClassFinishers(r.F, decorated.finishers);\n    }\n\n    function _getDecoratorsApi() {\n        _getDecoratorsApi = function() {\n            return api;\n        };\n\n        var api = {\n            elementsDefinitionOrder: [['method'], ['field']],\n            initializeInstanceElements: function(O, elements) {\n                ['method', 'field'].forEach(function(kind) {\n                    elements.forEach(function(element) {\n                        if (element.kind === kind && element.placement === 'own') {\n                            this.defineClassElement(O, element);\n                        }\n                    }, this);\n                }, this);\n            },\n            initializeClassElements: function(F, elements) {\n                var proto = F.prototype;\n                ['method', 'field'].forEach(function(kind) {\n                    elements.forEach(function(element) {\n                        var placement = element.placement;\n\n                        if (\n                            element.kind === kind &&\n                            (placement === 'static' || placement === 'prototype')\n                        ) {\n                            var receiver = placement === 'static' ? F : proto;\n                            this.defineClassElement(receiver, element);\n                        }\n                    }, this);\n                }, this);\n            },\n            defineClassElement: function(receiver, element) {\n                var descriptor = element.descriptor;\n\n                if (element.kind === 'field') {\n                    var initializer = element.initializer;\n                    descriptor = {\n                        enumerable: descriptor.enumerable,\n                        writable: descriptor.writable,\n                        configurable: descriptor.configurable,\n                        value: initializer === void 0 ? void 0 : initializer.call(receiver),\n                    };\n                }\n\n                Object.defineProperty(receiver, element.key, descriptor);\n            },\n            decorateClass: function(elements, decorators) {\n                var newElements = [];\n                var finishers = [];\n                var placements = {\n                    static: [],\n                    prototype: [],\n                    own: [],\n                };\n                elements.forEach(function(element) {\n                    this.addElementPlacement(element, placements);\n                }, this);\n                elements.forEach(function(element) {\n                    if (!_hasDecorators(element)) return newElements.push(element);\n                    var elementFinishersExtras = this.decorateElement(element, placements);\n                    newElements.push(elementFinishersExtras.element);\n                    newElements.push.apply(newElements, elementFinishersExtras.extras);\n                    finishers.push.apply(finishers, elementFinishersExtras.finishers);\n                }, this);\n\n                if (!decorators) {\n                    return {\n                        elements: newElements,\n                        finishers: finishers,\n                    };\n                }\n\n                var result = this.decorateConstructor(newElements, decorators);\n                finishers.push.apply(finishers, result.finishers);\n                result.finishers = finishers;\n                return result;\n            },\n            addElementPlacement: function(element, placements, silent) {\n                var keys = placements[element.placement];\n\n                if (!silent && keys.indexOf(element.key) !== -1) {\n                    throw new TypeError('Duplicated element (' + element.key + ')');\n                }\n\n                keys.push(element.key);\n            },\n            decorateElement: function(element, placements) {\n                var extras = [];\n                var finishers = [];\n\n                for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {\n                    var keys = placements[element.placement];\n                    keys.splice(keys.indexOf(element.key), 1);\n                    var elementObject = this.fromElementDescriptor(element);\n                    var elementFinisherExtras = this.toElementFinisherExtras(\n                        (0, decorators[i])(elementObject) || elementObject\n                    );\n                    element = elementFinisherExtras.element;\n                    this.addElementPlacement(element, placements);\n\n                    if (elementFinisherExtras.finisher) {\n                        finishers.push(elementFinisherExtras.finisher);\n                    }\n\n                    var newExtras = elementFinisherExtras.extras;\n\n                    if (newExtras) {\n                        for (var j = 0; j < newExtras.length; j++) {\n                            this.addElementPlacement(newExtras[j], placements);\n                        }\n\n                        extras.push.apply(extras, newExtras);\n                    }\n                }\n\n                return {\n                    element: element,\n                    finishers: finishers,\n                    extras: extras,\n                };\n            },\n            decorateConstructor: function(elements, decorators) {\n                var finishers = [];\n\n                for (var i = decorators.length - 1; i >= 0; i--) {\n                    var obj = this.fromClassDescriptor(elements);\n                    var elementsAndFinisher = this.toClassDescriptor(\n                        (0, decorators[i])(obj) || obj\n                    );\n\n                    if (elementsAndFinisher.finisher !== undefined) {\n                        finishers.push(elementsAndFinisher.finisher);\n                    }\n\n                    if (elementsAndFinisher.elements !== undefined) {\n                        elements = elementsAndFinisher.elements;\n\n                        for (var j = 0; j < elements.length - 1; j++) {\n                            for (var k = j + 1; k < elements.length; k++) {\n                                if (\n                                    elements[j].key === elements[k].key &&\n                                    elements[j].placement === elements[k].placement\n                                ) {\n                                    throw new TypeError(\n                                        'Duplicated element (' + elements[j].key + ')'\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n\n                return {\n                    elements: elements,\n                    finishers: finishers,\n                };\n            },\n            fromElementDescriptor: function(element) {\n                var obj = {\n                    kind: element.kind,\n                    key: element.key,\n                    placement: element.placement,\n                    descriptor: element.descriptor,\n                };\n                var desc = {\n                    value: 'Descriptor',\n                    configurable: true,\n                };\n                Object.defineProperty(obj, Symbol.toStringTag, desc);\n                if (element.kind === 'field') obj.initializer = element.initializer;\n                return obj;\n            },\n            toElementDescriptors: function(elementObjects) {\n                if (elementObjects === undefined) return;\n                return _toArray(elementObjects).map(function(elementObject) {\n                    var element = this.toElementDescriptor(elementObject);\n                    this.disallowProperty(elementObject, 'finisher', 'An element descriptor');\n                    this.disallowProperty(elementObject, 'extras', 'An element descriptor');\n                    return element;\n                }, this);\n            },\n            toElementDescriptor: function(elementObject) {\n                var kind = String(elementObject.kind);\n\n                if (kind !== 'method' && kind !== 'field') {\n                    throw new TypeError(\n                        'An element descriptor\\'s .kind property must be either \"method\" or' +\n                            ' \"field\", but a decorator created an element descriptor with' +\n                            ' .kind \"' +\n                            kind +\n                            '\"'\n                    );\n                }\n\n                var key = _toPropertyKey(elementObject.key);\n\n                var placement = String(elementObject.placement);\n\n                if (placement !== 'static' && placement !== 'prototype' && placement !== 'own') {\n                    throw new TypeError(\n                        'An element descriptor\\'s .placement property must be one of \"static\",' +\n                            ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n                            ' with .placement \"' +\n                            placement +\n                            '\"'\n                    );\n                }\n\n                var descriptor = elementObject.descriptor;\n                this.disallowProperty(elementObject, 'elements', 'An element descriptor');\n                var element = {\n                    kind: kind,\n                    key: key,\n                    placement: placement,\n                    descriptor: Object.assign({}, descriptor),\n                };\n\n                if (kind !== 'field') {\n                    this.disallowProperty(elementObject, 'initializer', 'A method descriptor');\n                } else {\n                    this.disallowProperty(\n                        descriptor,\n                        'get',\n                        'The property descriptor of a field descriptor'\n                    );\n                    this.disallowProperty(\n                        descriptor,\n                        'set',\n                        'The property descriptor of a field descriptor'\n                    );\n                    this.disallowProperty(\n                        descriptor,\n                        'value',\n                        'The property descriptor of a field descriptor'\n                    );\n                    element.initializer = elementObject.initializer;\n                }\n\n                return element;\n            },\n            toElementFinisherExtras: function(elementObject) {\n                var element = this.toElementDescriptor(elementObject);\n\n                var finisher = _optionalCallableProperty(elementObject, 'finisher');\n\n                var extras = this.toElementDescriptors(elementObject.extras);\n                return {\n                    element: element,\n                    finisher: finisher,\n                    extras: extras,\n                };\n            },\n            fromClassDescriptor: function(elements) {\n                var obj = {\n                    kind: 'class',\n                    elements: elements.map(this.fromElementDescriptor, this),\n                };\n                var desc = {\n                    value: 'Descriptor',\n                    configurable: true,\n                };\n                Object.defineProperty(obj, Symbol.toStringTag, desc);\n                return obj;\n            },\n            toClassDescriptor: function(obj) {\n                var kind = String(obj.kind);\n\n                if (kind !== 'class') {\n                    throw new TypeError(\n                        'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n                            ' created a class descriptor with .kind \"' +\n                            kind +\n                            '\"'\n                    );\n                }\n\n                this.disallowProperty(obj, 'key', 'A class descriptor');\n                this.disallowProperty(obj, 'placement', 'A class descriptor');\n                this.disallowProperty(obj, 'descriptor', 'A class descriptor');\n                this.disallowProperty(obj, 'initializer', 'A class descriptor');\n                this.disallowProperty(obj, 'extras', 'A class descriptor');\n\n                var finisher = _optionalCallableProperty(obj, 'finisher');\n\n                var elements = this.toElementDescriptors(obj.elements);\n                return {\n                    elements: elements,\n                    finisher: finisher,\n                };\n            },\n            runClassFinishers: function(constructor, finishers) {\n                for (var i = 0; i < finishers.length; i++) {\n                    var newConstructor = (0, finishers[i])(constructor);\n\n                    if (newConstructor !== undefined) {\n                        if (typeof newConstructor !== 'function') {\n                            throw new TypeError('Finishers must return a constructor.');\n                        }\n\n                        constructor = newConstructor;\n                    }\n                }\n\n                return constructor;\n            },\n            disallowProperty: function(obj, name, objectType) {\n                if (obj[name] !== undefined) {\n                    throw new TypeError(objectType + \" can't have a .\" + name + ' property.');\n                }\n            },\n        };\n        return api;\n    }\n\n    function _createElementDescriptor(def) {\n        var key = _toPropertyKey(def.key);\n\n        var descriptor;\n\n        if (def.kind === 'method') {\n            descriptor = {\n                value: def.value,\n                writable: true,\n                configurable: true,\n                enumerable: false,\n            };\n        } else if (def.kind === 'get') {\n            descriptor = {\n                get: def.value,\n                configurable: true,\n                enumerable: false,\n            };\n        } else if (def.kind === 'set') {\n            descriptor = {\n                set: def.value,\n                configurable: true,\n                enumerable: false,\n            };\n        } else if (def.kind === 'field') {\n            descriptor = {\n                configurable: true,\n                writable: true,\n                enumerable: true,\n            };\n        }\n\n        var element = {\n            kind: def.kind === 'field' ? 'field' : 'method',\n            key: key,\n            placement: def.static ? 'static' : def.kind === 'field' ? 'own' : 'prototype',\n            descriptor: descriptor,\n        };\n        if (def.decorators) element.decorators = def.decorators;\n        if (def.kind === 'field') element.initializer = def.value;\n        return element;\n    }\n\n    function _coalesceGetterSetter(element, other) {\n        if (element.descriptor.get !== undefined) {\n            other.descriptor.get = element.descriptor.get;\n        } else {\n            other.descriptor.set = element.descriptor.set;\n        }\n    }\n\n    function _coalesceClassElements(elements) {\n        var newElements = [];\n\n        var isSameElement = function(other) {\n            return (\n                other.kind === 'method' &&\n                other.key === element.key &&\n                other.placement === element.placement\n            );\n        };\n\n        for (var i = 0; i < elements.length; i++) {\n            var element = elements[i];\n            var other;\n\n            if (element.kind === 'method' && (other = newElements.find(isSameElement))) {\n                if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {\n                    if (_hasDecorators(element) || _hasDecorators(other)) {\n                        throw new ReferenceError(\n                            'Duplicated methods (' + element.key + \") can't be decorated.\"\n                        );\n                    }\n\n                    other.descriptor = element.descriptor;\n                } else {\n                    if (_hasDecorators(element)) {\n                        if (_hasDecorators(other)) {\n                            throw new ReferenceError(\n                                \"Decorators can't be placed on different accessors with for \" +\n                                    'the same property (' +\n                                    element.key +\n                                    ').'\n                            );\n                        }\n\n                        other.decorators = element.decorators;\n                    }\n\n                    _coalesceGetterSetter(element, other);\n                }\n            } else {\n                newElements.push(element);\n            }\n        }\n\n        return newElements;\n    }\n\n    function _hasDecorators(element) {\n        return element.decorators && element.decorators.length;\n    }\n\n    function _isDataDescriptor(desc) {\n        return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);\n    }\n\n    function _optionalCallableProperty(obj, name) {\n        var value = obj[name];\n\n        if (value !== undefined && typeof value !== 'function') {\n            throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n        }\n\n        return value;\n    }\n\n    function _classPrivateMethodGet(receiver, privateSet, fn) {\n        if (!privateSet.has(receiver)) {\n            throw new TypeError('attempted to get private field on non-instance');\n        }\n\n        return fn;\n    }\n\n    function _classPrivateMethodSet() {\n        throw new TypeError('attempted to reassign private method');\n    }\n\n    function _wrapRegExp(re, groups) {\n        _wrapRegExp = function(re, groups) {\n            return new BabelRegExp(re, groups);\n        };\n\n        var _RegExp = _wrapNativeSuper(RegExp);\n\n        var _super = RegExp.prototype;\n\n        var _groups = new WeakMap();\n\n        function BabelRegExp(re, groups) {\n            var _this = _RegExp.call(this, re);\n\n            _groups.set(_this, groups);\n\n            return _this;\n        }\n\n        _inherits(BabelRegExp, _RegExp);\n\n        BabelRegExp.prototype.exec = function(str) {\n            var result = _super.exec.call(this, str);\n\n            if (result) result.groups = buildGroups(result, this);\n            return result;\n        };\n\n        BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n            if (typeof substitution === 'string') {\n                var groups = _groups.get(this);\n\n                return _super[Symbol.replace].call(\n                    this,\n                    str,\n                    substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n                        return '$' + groups[name];\n                    })\n                );\n            } else if (typeof substitution === 'function') {\n                var _this = this;\n\n                return _super[Symbol.replace].call(this, str, function() {\n                    var args = [];\n                    args.push.apply(args, arguments);\n\n                    if (typeof args[args.length - 1] !== 'object') {\n                        args.push(buildGroups(args, _this));\n                    }\n\n                    return substitution.apply(this, args);\n                });\n            } else {\n                return _super[Symbol.replace].call(this, str, substitution);\n            }\n        };\n\n        function buildGroups(result, re) {\n            var g = _groups.get(re);\n\n            return Object.keys(g).reduce(function(groups, name) {\n                groups[name] = result[g[name]];\n                return groups;\n            }, Object.create(null));\n        }\n\n        return _wrapRegExp.apply(this, arguments);\n    }\n\n    var arrayRemove = function arrayRemove(arr, index) {\n        return arr.splice(index, 1);\n    };\n\n    var run = function run(cb, sync) {\n        if (sync) {\n            cb();\n        } else if (document.hidden) {\n            Promise.resolve(1).then(cb);\n        } else {\n            setTimeout(cb, 0);\n        }\n    };\n\n    var on = function on() {\n        var listeners = [];\n        var off = function off(event, cb) {\n            arrayRemove(\n                listeners,\n                listeners.findIndex(function(listener) {\n                    return listener.event === event && (listener.cb === cb || !cb);\n                })\n            );\n        };\n        var _fire = function fire(event, args, sync) {\n            listeners\n                .filter(function(listener) {\n                    return listener.event === event;\n                })\n                .map(function(listener) {\n                    return listener.cb;\n                })\n                .forEach(function(cb) {\n                    return run(function() {\n                        return cb.apply(void 0, _toConsumableArray(args));\n                    }, sync);\n                });\n        };\n        return {\n            fireSync: function fireSync(event) {\n                for (\n                    var _len = arguments.length,\n                        args = new Array(_len > 1 ? _len - 1 : 0),\n                        _key = 1;\n                    _key < _len;\n                    _key++\n                ) {\n                    args[_key - 1] = arguments[_key];\n                }\n                _fire(event, args, true);\n            },\n            fire: function fire(event) {\n                for (\n                    var _len2 = arguments.length,\n                        args = new Array(_len2 > 1 ? _len2 - 1 : 0),\n                        _key2 = 1;\n                    _key2 < _len2;\n                    _key2++\n                ) {\n                    args[_key2 - 1] = arguments[_key2];\n                }\n                _fire(event, args, false);\n            },\n            on: function on(event, cb) {\n                listeners.push({ event: event, cb: cb });\n            },\n            onOnce: function onOnce(event, _cb) {\n                listeners.push({\n                    event: event,\n                    cb: function cb() {\n                        off(event, _cb);\n                        _cb.apply(void 0, arguments);\n                    },\n                });\n            },\n            off: off,\n        };\n    };\n\n    var copyObjectPropertiesToObject = function copyObjectPropertiesToObject(\n        src,\n        target,\n        excluded\n    ) {\n        Object.getOwnPropertyNames(src)\n            .filter(function(property) {\n                return !excluded.includes(property);\n            })\n            .forEach(function(key) {\n                return Object.defineProperty(\n                    target,\n                    key,\n                    Object.getOwnPropertyDescriptor(src, key)\n                );\n            });\n    };\n\n    var PRIVATE = [\n        'fire',\n        'process',\n        'revert',\n        'load',\n        'on',\n        'off',\n        'onOnce',\n        'retryLoad',\n        'extend',\n        'archive',\n        'archived',\n        'release',\n        'released',\n        'requestProcessing',\n        'freeze',\n    ];\n\n    var createItemAPI = function createItemAPI(item) {\n        var api = {};\n        copyObjectPropertiesToObject(item, api, PRIVATE);\n        return api;\n    };\n\n    var removeReleasedItems = function removeReleasedItems(items) {\n        items.forEach(function(item, index) {\n            if (item.released) {\n                arrayRemove(items, index);\n            }\n        });\n    };\n\n    var ItemStatus = {\n        INIT: 1,\n        IDLE: 2,\n        PROCESSING_QUEUED: 9,\n        PROCESSING: 3,\n        PROCESSING_COMPLETE: 5,\n        PROCESSING_ERROR: 6,\n        PROCESSING_REVERT_ERROR: 10,\n        LOADING: 7,\n        LOAD_ERROR: 8,\n    };\n\n    var FileOrigin = {\n        INPUT: 1,\n        LIMBO: 2,\n        LOCAL: 3,\n    };\n\n    var getNonNumeric = function getNonNumeric(str) {\n        return /[^0-9]+/.exec(str);\n    };\n\n    var getDecimalSeparator = function getDecimalSeparator() {\n        return getNonNumeric((1.1).toLocaleString())[0];\n    };\n\n    var getThousandsSeparator = function getThousandsSeparator() {\n        // Added for browsers that do not return the thousands separator (happend on native browser Android 4.4.4)\n        // We check against the normal toString output and if they're the same return a comma when decimal separator is a dot\n        var decimalSeparator = getDecimalSeparator();\n        var thousandsStringWithSeparator = (1000.0).toLocaleString();\n        var thousandsStringWithoutSeparator = (1000.0).toString();\n        if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {\n            return getNonNumeric(thousandsStringWithSeparator)[0];\n        }\n        return decimalSeparator === '.' ? ',' : '.';\n    };\n\n    var Type = {\n        BOOLEAN: 'boolean',\n        INT: 'int',\n        NUMBER: 'number',\n        STRING: 'string',\n        ARRAY: 'array',\n        OBJECT: 'object',\n        FUNCTION: 'function',\n        ACTION: 'action',\n        SERVER_API: 'serverapi',\n        REGEX: 'regex',\n    };\n\n    // all registered filters\n    var filters = [];\n\n    // loops over matching filters and passes options to each filter, returning the mapped results\n    var applyFilterChain = function applyFilterChain(key, value, utils) {\n        return new Promise(function(resolve, reject) {\n            // find matching filters for this key\n            var matchingFilters = filters\n                .filter(function(f) {\n                    return f.key === key;\n                })\n                .map(function(f) {\n                    return f.cb;\n                });\n\n            // resolve now\n            if (matchingFilters.length === 0) {\n                resolve(value);\n                return;\n            }\n\n            // first filter to kick things of\n            var initialFilter = matchingFilters.shift();\n\n            // chain filters\n            matchingFilters\n                .reduce(\n                    // loop over promises passing value to next promise\n                    function(current, next) {\n                        return current.then(function(value) {\n                            return next(value, utils);\n                        });\n                    },\n\n                    // call initial filter, will return a promise\n                    initialFilter(value, utils)\n\n                    // all executed\n                )\n                .then(function(value) {\n                    return resolve(value);\n                })\n                .catch(function(error) {\n                    return reject(error);\n                });\n        });\n    };\n\n    var applyFilters = function applyFilters(key, value, utils) {\n        return filters\n            .filter(function(f) {\n                return f.key === key;\n            })\n            .map(function(f) {\n                return f.cb(value, utils);\n            });\n    };\n\n    // adds a new filter to the list\n    var addFilter = function addFilter(key, cb) {\n        return filters.push({ key: key, cb: cb });\n    };\n\n    var extendDefaultOptions = function extendDefaultOptions(additionalOptions) {\n        return Object.assign(defaultOptions, additionalOptions);\n    };\n\n    var getOptions = function getOptions() {\n        return Object.assign({}, defaultOptions);\n    };\n\n    var setOptions = function setOptions(opts) {\n        forin(opts, function(key, value) {\n            // key does not exist, so this option cannot be set\n            if (!defaultOptions[key]) {\n                return;\n            }\n            defaultOptions[key][0] = getValueByType(\n                value,\n                defaultOptions[key][0],\n                defaultOptions[key][1]\n            );\n        });\n    };\n\n    // default options on app\n    var defaultOptions = {\n        // the id to add to the root element\n        id: [null, Type.STRING],\n\n        // input field name to use\n        name: ['filepond', Type.STRING],\n\n        // disable the field\n        disabled: [false, Type.BOOLEAN],\n\n        // classname to put on wrapper\n        className: [null, Type.STRING],\n\n        // is the field required\n        required: [false, Type.BOOLEAN],\n\n        // Allow media capture when value is set\n        captureMethod: [null, Type.STRING],\n        // - \"camera\", \"microphone\" or \"camcorder\",\n        // - Does not work with multiple on apple devices\n        // - If set, acceptedFileTypes must be made to match with media wildcard \"image/*\", \"audio/*\" or \"video/*\"\n\n        // sync `acceptedFileTypes` property with `accept` attribute\n        allowSyncAcceptAttribute: [true, Type.BOOLEAN],\n\n        // Feature toggles\n        allowDrop: [true, Type.BOOLEAN], // Allow dropping of files\n        allowBrowse: [true, Type.BOOLEAN], // Allow browsing the file system\n        allowPaste: [true, Type.BOOLEAN], // Allow pasting files\n        allowMultiple: [false, Type.BOOLEAN], // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)\n        allowReplace: [true, Type.BOOLEAN], // Allow dropping a file on other file to replace it (only works when multiple is set to false)\n        allowRevert: [true, Type.BOOLEAN], // Allows user to revert file upload\n        allowRemove: [true, Type.BOOLEAN], // Allow user to remove a file\n        allowProcess: [true, Type.BOOLEAN], // Allows user to process a file, when set to false, this removes the file upload button\n        allowReorder: [false, Type.BOOLEAN], // Allow reordering of files\n        allowDirectoriesOnly: [false, Type.BOOLEAN], // Allow only selecting directories with browse (no support for filtering dnd at this point)\n\n        // Try store file if `server` not set\n        storeAsFile: [false, Type.BOOLEAN],\n\n        // Revert mode\n        forceRevert: [false, Type.BOOLEAN], // Set to 'force' to require the file to be reverted before removal\n\n        // Input requirements\n        maxFiles: [null, Type.INT], // Max number of files\n        checkValidity: [false, Type.BOOLEAN], // Enables custom validity messages\n\n        // Where to put file\n        itemInsertLocationFreedom: [true, Type.BOOLEAN], // Set to false to always add items to begin or end of list\n        itemInsertLocation: ['before', Type.STRING], // Default index in list to add items that have been dropped at the top of the list\n        itemInsertInterval: [75, Type.INT],\n\n        // Drag 'n Drop related\n        dropOnPage: [false, Type.BOOLEAN], // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)\n        dropOnElement: [true, Type.BOOLEAN], // Drop needs to happen on element (set to false to also load drops outside of Up)\n        dropValidation: [false, Type.BOOLEAN], // Enable or disable validating files on drop\n        ignoredFiles: [['.ds_store', 'thumbs.db', 'desktop.ini'], Type.ARRAY],\n\n        // Upload related\n        instantUpload: [true, Type.BOOLEAN], // Should upload files immediately on drop\n        maxParallelUploads: [2, Type.INT], // Maximum files to upload in parallel\n        allowMinimumUploadDuration: [true, Type.BOOLEAN], // if true uploads take at least 750 ms, this ensures the user sees the upload progress giving trust the upload actually happened\n\n        // Chunks\n        chunkUploads: [false, Type.BOOLEAN], // Enable chunked uploads\n        chunkForce: [false, Type.BOOLEAN], // Force use of chunk uploads even for files smaller than chunk size\n        chunkSize: [5000000, Type.INT], // Size of chunks (5MB default)\n        chunkRetryDelays: [[500, 1000, 3000], Type.ARRAY], // Amount of times to retry upload of a chunk when it fails\n\n        // The server api end points to use for uploading (see docs)\n        server: [null, Type.SERVER_API],\n\n        // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000\n        fileSizeBase: [1000, Type.INT],\n\n        // Labels and status messages\n        labelFileSizeBytes: ['bytes', Type.STRING],\n        labelFileSizeKilobytes: ['KB', Type.STRING],\n        labelFileSizeMegabytes: ['MB', Type.STRING],\n        labelFileSizeGigabytes: ['GB', Type.STRING],\n\n        labelDecimalSeparator: [getDecimalSeparator(), Type.STRING], // Default is locale separator\n        labelThousandsSeparator: [getThousandsSeparator(), Type.STRING], // Default is locale separator\n\n        labelIdle: [\n            'Drag & Drop your files or <span class=\"filepond--label-action\">Browse</span>',\n            Type.STRING,\n        ],\n\n        labelInvalidField: ['Field contains invalid files', Type.STRING],\n        labelFileWaitingForSize: ['Waiting for size', Type.STRING],\n        labelFileSizeNotAvailable: ['Size not available', Type.STRING],\n        labelFileCountSingular: ['file in list', Type.STRING],\n        labelFileCountPlural: ['files in list', Type.STRING],\n        labelFileLoading: ['Loading', Type.STRING],\n        labelFileAdded: ['Added', Type.STRING], // assistive only\n        labelFileLoadError: ['Error during load', Type.STRING],\n        labelFileRemoved: ['Removed', Type.STRING], // assistive only\n        labelFileRemoveError: ['Error during remove', Type.STRING],\n        labelFileProcessing: ['Uploading', Type.STRING],\n        labelFileProcessingComplete: ['Upload complete', Type.STRING],\n        labelFileProcessingAborted: ['Upload cancelled', Type.STRING],\n        labelFileProcessingError: ['Error during upload', Type.STRING],\n        labelFileProcessingRevertError: ['Error during revert', Type.STRING],\n\n        labelTapToCancel: ['tap to cancel', Type.STRING],\n        labelTapToRetry: ['tap to retry', Type.STRING],\n        labelTapToUndo: ['tap to undo', Type.STRING],\n\n        labelButtonRemoveItem: ['Remove', Type.STRING],\n        labelButtonAbortItemLoad: ['Abort', Type.STRING],\n        labelButtonRetryItemLoad: ['Retry', Type.STRING],\n        labelButtonAbortItemProcessing: ['Cancel', Type.STRING],\n        labelButtonUndoItemProcessing: ['Undo', Type.STRING],\n        labelButtonRetryItemProcessing: ['Retry', Type.STRING],\n        labelButtonProcessItem: ['Upload', Type.STRING],\n\n        // make sure width and height plus viewpox are even numbers so icons are nicely centered\n        iconRemove: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n            Type.STRING,\n        ],\n\n        iconProcess: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z\" fill=\"currentColor\" fill-rule=\"evenodd\"/></svg>',\n            Type.STRING,\n        ],\n\n        iconRetry: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n            Type.STRING,\n        ],\n\n        iconUndo: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n            Type.STRING,\n        ],\n\n        iconDone: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n            Type.STRING,\n        ],\n\n        // event handlers\n        oninit: [null, Type.FUNCTION],\n        onwarning: [null, Type.FUNCTION],\n        onerror: [null, Type.FUNCTION],\n        onactivatefile: [null, Type.FUNCTION],\n        oninitfile: [null, Type.FUNCTION],\n        onaddfilestart: [null, Type.FUNCTION],\n        onaddfileprogress: [null, Type.FUNCTION],\n        onaddfile: [null, Type.FUNCTION],\n        onprocessfilestart: [null, Type.FUNCTION],\n        onprocessfileprogress: [null, Type.FUNCTION],\n        onprocessfileabort: [null, Type.FUNCTION],\n        onprocessfilerevert: [null, Type.FUNCTION],\n        onprocessfile: [null, Type.FUNCTION],\n        onprocessfiles: [null, Type.FUNCTION],\n        onremovefile: [null, Type.FUNCTION],\n        onpreparefile: [null, Type.FUNCTION],\n        onupdatefiles: [null, Type.FUNCTION],\n        onreorderfiles: [null, Type.FUNCTION],\n\n        // hooks\n        beforeDropFile: [null, Type.FUNCTION],\n        beforeAddFile: [null, Type.FUNCTION],\n        beforeRemoveFile: [null, Type.FUNCTION],\n        beforePrepareFile: [null, Type.FUNCTION],\n\n        // styles\n        stylePanelLayout: [null, Type.STRING], // null 'integrated', 'compact', 'circle'\n        stylePanelAspectRatio: [null, Type.STRING], // null or '3:2' or 1\n        styleItemPanelAspectRatio: [null, Type.STRING],\n        styleButtonRemoveItemPosition: ['left', Type.STRING],\n        styleButtonProcessItemPosition: ['right', Type.STRING],\n        styleLoadIndicatorPosition: ['right', Type.STRING],\n        styleProgressIndicatorPosition: ['right', Type.STRING],\n        styleButtonRemoveItemAlign: [false, Type.BOOLEAN],\n\n        // custom initial files array\n        files: [[], Type.ARRAY],\n\n        // show support by displaying credits\n        credits: [['https://pqina.nl/', 'Powered by PQINA'], Type.ARRAY],\n    };\n\n    var getItemByQuery = function getItemByQuery(items, query) {\n        // just return first index\n        if (isEmpty(query)) {\n            return items[0] || null;\n        }\n\n        // query is index\n        if (isInt(query)) {\n            return items[query] || null;\n        }\n\n        // if query is item, get the id\n        if (typeof query === 'object') {\n            query = query.id;\n        }\n\n        // assume query is a string and return item by id\n        return (\n            items.find(function(item) {\n                return item.id === query;\n            }) || null\n        );\n    };\n\n    var getNumericAspectRatioFromString = function getNumericAspectRatioFromString(aspectRatio) {\n        if (isEmpty(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (/:/.test(aspectRatio)) {\n            var parts = aspectRatio.split(':');\n            return parts[1] / parts[0];\n        }\n        return parseFloat(aspectRatio);\n    };\n\n    var getActiveItems = function getActiveItems(items) {\n        return items.filter(function(item) {\n            return !item.archived;\n        });\n    };\n\n    var Status = {\n        EMPTY: 0,\n        IDLE: 1, // waiting\n        ERROR: 2, // a file is in error state\n        BUSY: 3, // busy processing or loading\n        READY: 4, // all files uploaded\n    };\n\n    var res = null;\n    var canUpdateFileInput = function canUpdateFileInput() {\n        if (res === null) {\n            try {\n                var dataTransfer = new DataTransfer();\n                dataTransfer.items.add(new File(['hello world'], 'This_Works.txt'));\n                var el = document.createElement('input');\n                el.setAttribute('type', 'file');\n                el.files = dataTransfer.files;\n                res = el.files.length === 1;\n            } catch (err) {\n                res = false;\n            }\n        }\n        return res;\n    };\n\n    var ITEM_ERROR = [\n        ItemStatus.LOAD_ERROR,\n        ItemStatus.PROCESSING_ERROR,\n        ItemStatus.PROCESSING_REVERT_ERROR,\n    ];\n\n    var ITEM_BUSY = [\n        ItemStatus.LOADING,\n        ItemStatus.PROCESSING,\n        ItemStatus.PROCESSING_QUEUED,\n        ItemStatus.INIT,\n    ];\n\n    var ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];\n\n    var isItemInErrorState = function isItemInErrorState(item) {\n        return ITEM_ERROR.includes(item.status);\n    };\n    var isItemInBusyState = function isItemInBusyState(item) {\n        return ITEM_BUSY.includes(item.status);\n    };\n    var isItemInReadyState = function isItemInReadyState(item) {\n        return ITEM_READY.includes(item.status);\n    };\n\n    var isAsync = function isAsync(state) {\n        return (\n            isObject(state.options.server) &&\n            (isObject(state.options.server.process) || isFunction(state.options.server.process))\n        );\n    };\n\n    var queries = function queries(state) {\n        return {\n            GET_STATUS: function GET_STATUS() {\n                var items = getActiveItems(state.items);\n                var EMPTY = Status.EMPTY,\n                    ERROR = Status.ERROR,\n                    BUSY = Status.BUSY,\n                    IDLE = Status.IDLE,\n                    READY = Status.READY;\n\n                if (items.length === 0) return EMPTY;\n\n                if (items.some(isItemInErrorState)) return ERROR;\n\n                if (items.some(isItemInBusyState)) return BUSY;\n\n                if (items.some(isItemInReadyState)) return READY;\n\n                return IDLE;\n            },\n\n            GET_ITEM: function GET_ITEM(query) {\n                return getItemByQuery(state.items, query);\n            },\n\n            GET_ACTIVE_ITEM: function GET_ACTIVE_ITEM(query) {\n                return getItemByQuery(getActiveItems(state.items), query);\n            },\n\n            GET_ACTIVE_ITEMS: function GET_ACTIVE_ITEMS() {\n                return getActiveItems(state.items);\n            },\n\n            GET_ITEMS: function GET_ITEMS() {\n                return state.items;\n            },\n\n            GET_ITEM_NAME: function GET_ITEM_NAME(query) {\n                var item = getItemByQuery(state.items, query);\n                return item ? item.filename : null;\n            },\n\n            GET_ITEM_SIZE: function GET_ITEM_SIZE(query) {\n                var item = getItemByQuery(state.items, query);\n                return item ? item.fileSize : null;\n            },\n\n            GET_STYLES: function GET_STYLES() {\n                return Object.keys(state.options)\n                    .filter(function(key) {\n                        return /^style/.test(key);\n                    })\n                    .map(function(option) {\n                        return {\n                            name: option,\n                            value: state.options[option],\n                        };\n                    });\n            },\n\n            GET_PANEL_ASPECT_RATIO: function GET_PANEL_ASPECT_RATIO() {\n                var isShapeCircle = /circle/.test(state.options.stylePanelLayout);\n                var aspectRatio = isShapeCircle\n                    ? 1\n                    : getNumericAspectRatioFromString(state.options.stylePanelAspectRatio);\n                return aspectRatio;\n            },\n\n            GET_ITEM_PANEL_ASPECT_RATIO: function GET_ITEM_PANEL_ASPECT_RATIO() {\n                return state.options.styleItemPanelAspectRatio;\n            },\n\n            GET_ITEMS_BY_STATUS: function GET_ITEMS_BY_STATUS(status) {\n                return getActiveItems(state.items).filter(function(item) {\n                    return item.status === status;\n                });\n            },\n\n            GET_TOTAL_ITEMS: function GET_TOTAL_ITEMS() {\n                return getActiveItems(state.items).length;\n            },\n\n            SHOULD_UPDATE_FILE_INPUT: function SHOULD_UPDATE_FILE_INPUT() {\n                return state.options.storeAsFile && canUpdateFileInput() && !isAsync(state);\n            },\n\n            IS_ASYNC: function IS_ASYNC() {\n                return isAsync(state);\n            },\n\n            GET_FILE_SIZE_LABELS: function GET_FILE_SIZE_LABELS(query) {\n                return {\n                    labelBytes: query('GET_LABEL_FILE_SIZE_BYTES') || undefined,\n                    labelKilobytes: query('GET_LABEL_FILE_SIZE_KILOBYTES') || undefined,\n                    labelMegabytes: query('GET_LABEL_FILE_SIZE_MEGABYTES') || undefined,\n                    labelGigabytes: query('GET_LABEL_FILE_SIZE_GIGABYTES') || undefined,\n                };\n            },\n        };\n    };\n\n    var hasRoomForItem = function hasRoomForItem(state) {\n        var count = getActiveItems(state.items).length;\n\n        // if cannot have multiple items, to add one item it should currently not contain items\n        if (!state.options.allowMultiple) {\n            return count === 0;\n        }\n\n        // if allows multiple items, we check if a max item count has been set, if not, there's no limit\n        var maxFileCount = state.options.maxFiles;\n        if (maxFileCount === null) {\n            return true;\n        }\n\n        // we check if the current count is smaller than the max count, if so, another file can still be added\n        if (count < maxFileCount) {\n            return true;\n        }\n\n        // no more room for another file\n        return false;\n    };\n\n    var limit = function limit(value, min, max) {\n        return Math.max(Math.min(max, value), min);\n    };\n\n    var arrayInsert = function arrayInsert(arr, index, item) {\n        return arr.splice(index, 0, item);\n    };\n\n    var insertItem = function insertItem(items, item, index) {\n        if (isEmpty(item)) {\n            return null;\n        }\n\n        // if index is undefined, append\n        if (typeof index === 'undefined') {\n            items.push(item);\n            return item;\n        }\n\n        // limit the index to the size of the items array\n        index = limit(index, 0, items.length);\n\n        // add item to array\n        arrayInsert(items, index, item);\n\n        // expose\n        return item;\n    };\n\n    var isBase64DataURI = function isBase64DataURI(str) {\n        return /^\\s*data:([a-z]+\\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s]*)\\s*$/i.test(\n            str\n        );\n    };\n\n    var getFilenameFromURL = function getFilenameFromURL(url) {\n        return ('' + url)\n            .split('/')\n            .pop()\n            .split('?')\n            .shift();\n    };\n\n    var getExtensionFromFilename = function getExtensionFromFilename(name) {\n        return name.split('.').pop();\n    };\n\n    var guesstimateExtension = function guesstimateExtension(type) {\n        // if no extension supplied, exit here\n        if (typeof type !== 'string') {\n            return '';\n        }\n\n        // get subtype\n        var subtype = type.split('/').pop();\n\n        // is svg subtype\n        if (/svg/.test(subtype)) {\n            return 'svg';\n        }\n\n        if (/zip|compressed/.test(subtype)) {\n            return 'zip';\n        }\n\n        if (/plain/.test(subtype)) {\n            return 'txt';\n        }\n\n        if (/msword/.test(subtype)) {\n            return 'doc';\n        }\n\n        // if is valid subtype\n        if (/[a-z]+/.test(subtype)) {\n            // always use jpg extension\n            if (subtype === 'jpeg') {\n                return 'jpg';\n            }\n\n            // return subtype\n            return subtype;\n        }\n\n        return '';\n    };\n\n    var leftPad = function leftPad(value) {\n        var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        return (padding + value).slice(-padding.length);\n    };\n\n    var getDateString = function getDateString() {\n        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n        return (\n            date.getFullYear() +\n            '-' +\n            leftPad(date.getMonth() + 1, '00') +\n            '-' +\n            leftPad(date.getDate(), '00') +\n            '_' +\n            leftPad(date.getHours(), '00') +\n            '-' +\n            leftPad(date.getMinutes(), '00') +\n            '-' +\n            leftPad(date.getSeconds(), '00')\n        );\n    };\n\n    var getFileFromBlob = function getFileFromBlob(blob, filename) {\n        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        var extension = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var file =\n            typeof type === 'string'\n                ? blob.slice(0, blob.size, type)\n                : blob.slice(0, blob.size, blob.type);\n        file.lastModifiedDate = new Date();\n\n        // copy relative path\n        if (blob._relativePath) file._relativePath = blob._relativePath;\n\n        // if blob has name property, use as filename if no filename supplied\n        if (!isString(filename)) {\n            filename = getDateString();\n        }\n\n        // if filename supplied but no extension and filename has extension\n        if (filename && extension === null && getExtensionFromFilename(filename)) {\n            file.name = filename;\n        } else {\n            extension = extension || guesstimateExtension(file.type);\n            file.name = filename + (extension ? '.' + extension : '');\n        }\n\n        return file;\n    };\n\n    var getBlobBuilder = function getBlobBuilder() {\n        return (window.BlobBuilder =\n            window.BlobBuilder ||\n            window.WebKitBlobBuilder ||\n            window.MozBlobBuilder ||\n            window.MSBlobBuilder);\n    };\n\n    var createBlob = function createBlob(arrayBuffer, mimeType) {\n        var BB = getBlobBuilder();\n\n        if (BB) {\n            var bb = new BB();\n            bb.append(arrayBuffer);\n            return bb.getBlob(mimeType);\n        }\n\n        return new Blob([arrayBuffer], {\n            type: mimeType,\n        });\n    };\n\n    var getBlobFromByteStringWithMimeType = function getBlobFromByteStringWithMimeType(\n        byteString,\n        mimeType\n    ) {\n        var ab = new ArrayBuffer(byteString.length);\n        var ia = new Uint8Array(ab);\n\n        for (var i = 0; i < byteString.length; i++) {\n            ia[i] = byteString.charCodeAt(i);\n        }\n\n        return createBlob(ab, mimeType);\n    };\n\n    var getMimeTypeFromBase64DataURI = function getMimeTypeFromBase64DataURI(dataURI) {\n        return (/^data:(.+);/.exec(dataURI) || [])[1] || null;\n    };\n\n    var getBase64DataFromBase64DataURI = function getBase64DataFromBase64DataURI(dataURI) {\n        // get data part of string (remove data:image/jpeg...,)\n        var data = dataURI.split(',')[1];\n\n        // remove any whitespace as that causes InvalidCharacterError in IE\n        return data.replace(/\\s/g, '');\n    };\n\n    var getByteStringFromBase64DataURI = function getByteStringFromBase64DataURI(dataURI) {\n        return atob(getBase64DataFromBase64DataURI(dataURI));\n    };\n\n    var getBlobFromBase64DataURI = function getBlobFromBase64DataURI(dataURI) {\n        var mimeType = getMimeTypeFromBase64DataURI(dataURI);\n        var byteString = getByteStringFromBase64DataURI(dataURI);\n\n        return getBlobFromByteStringWithMimeType(byteString, mimeType);\n    };\n\n    var getFileFromBase64DataURI = function getFileFromBase64DataURI(dataURI, filename, extension) {\n        return getFileFromBlob(getBlobFromBase64DataURI(dataURI), filename, null, extension);\n    };\n\n    var getFileNameFromHeader = function getFileNameFromHeader(header) {\n        // test if is content disposition header, if not exit\n        if (!/^content-disposition:/i.test(header)) return null;\n\n        // get filename parts\n        var matches = header\n            .split(/filename=|filename\\*=.+''/)\n            .splice(1)\n            .map(function(name) {\n                return name.trim().replace(/^[\"']|[;\"']{0,2}$/g, '');\n            })\n            .filter(function(name) {\n                return name.length;\n            });\n\n        return matches.length ? decodeURI(matches[matches.length - 1]) : null;\n    };\n\n    var getFileSizeFromHeader = function getFileSizeFromHeader(header) {\n        if (/content-length:/i.test(header)) {\n            var size = header.match(/[0-9]+/)[0];\n            return size ? parseInt(size, 10) : null;\n        }\n        return null;\n    };\n\n    var getTranfserIdFromHeader = function getTranfserIdFromHeader(header) {\n        if (/x-content-transfer-id:/i.test(header)) {\n            var id = (header.split(':')[1] || '').trim();\n            return id || null;\n        }\n        return null;\n    };\n\n    var getFileInfoFromHeaders = function getFileInfoFromHeaders(headers) {\n        var info = {\n            source: null,\n            name: null,\n            size: null,\n        };\n\n        var rows = headers.split('\\n');\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n            for (\n                var _iterator = rows[Symbol.iterator](), _step;\n                !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n                _iteratorNormalCompletion = true\n            ) {\n                var header = _step.value;\n\n                var name = getFileNameFromHeader(header);\n                if (name) {\n                    info.name = name;\n                    continue;\n                }\n\n                var size = getFileSizeFromHeader(header);\n                if (size) {\n                    info.size = size;\n                    continue;\n                }\n\n                var source = getTranfserIdFromHeader(header);\n                if (source) {\n                    info.source = source;\n                    continue;\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        return info;\n    };\n\n    var createFileLoader = function createFileLoader(fetchFn) {\n        var state = {\n            source: null,\n            complete: false,\n            progress: 0,\n            size: null,\n            timestamp: null,\n            duration: 0,\n            request: null,\n        };\n\n        var getProgress = function getProgress() {\n            return state.progress;\n        };\n        var abort = function abort() {\n            if (state.request && state.request.abort) {\n                state.request.abort();\n            }\n        };\n\n        // load source\n        var load = function load() {\n            // get quick reference\n            var source = state.source;\n\n            api.fire('init', source);\n\n            // Load Files\n            if (source instanceof File) {\n                api.fire('load', source);\n            } else if (source instanceof Blob) {\n                // Load blobs, set default name to current date\n                api.fire('load', getFileFromBlob(source, source.name));\n            } else if (isBase64DataURI(source)) {\n                // Load base 64, set default name to current date\n                api.fire('load', getFileFromBase64DataURI(source));\n            } else {\n                // Deal as if is external URL, let's load it!\n                loadURL(source);\n            }\n        };\n\n        // loads a url\n        var loadURL = function loadURL(url) {\n            // is remote url and no fetch method supplied\n            if (!fetchFn) {\n                api.fire('error', {\n                    type: 'error',\n                    body: \"Can't load URL\",\n                    code: 400,\n                });\n\n                return;\n            }\n\n            // set request start\n            state.timestamp = Date.now();\n\n            // load file\n            state.request = fetchFn(\n                url,\n                function(response) {\n                    // update duration\n                    state.duration = Date.now() - state.timestamp;\n\n                    // done!\n                    state.complete = true;\n\n                    // turn blob response into a file\n                    if (response instanceof Blob) {\n                        response = getFileFromBlob(\n                            response,\n                            response.name || getFilenameFromURL(url)\n                        );\n                    }\n\n                    api.fire(\n                        'load',\n                        // if has received blob, we go with blob, if no response, we return null\n                        response instanceof Blob ? response : response ? response.body : null\n                    );\n                },\n                function(error) {\n                    api.fire(\n                        'error',\n                        typeof error === 'string'\n                            ? {\n                                  type: 'error',\n                                  code: 0,\n                                  body: error,\n                              }\n                            : error\n                    );\n                },\n                function(computable, current, total) {\n                    // collected some meta data already\n                    if (total) {\n                        state.size = total;\n                    }\n\n                    // update duration\n                    state.duration = Date.now() - state.timestamp;\n\n                    // if we can't compute progress, we're not going to fire progress events\n                    if (!computable) {\n                        state.progress = null;\n                        return;\n                    }\n\n                    // update progress percentage\n                    state.progress = current / total;\n\n                    // expose\n                    api.fire('progress', state.progress);\n                },\n                function() {\n                    api.fire('abort');\n                },\n                function(response) {\n                    var fileinfo = getFileInfoFromHeaders(\n                        typeof response === 'string' ? response : response.headers\n                    );\n                    api.fire('meta', {\n                        size: state.size || fileinfo.size,\n                        filename: fileinfo.name,\n                        source: fileinfo.source,\n                    });\n                }\n            );\n        };\n\n        var api = Object.assign({}, on(), {\n            setSource: function setSource(source) {\n                return (state.source = source);\n            },\n            getProgress: getProgress, // file load progress\n            abort: abort, // abort file load\n            load: load, // start load\n        });\n\n        return api;\n    };\n\n    var isGet = function isGet(method) {\n        return /GET|HEAD/.test(method);\n    };\n\n    var sendRequest = function sendRequest(data, url, options) {\n        var api = {\n            onheaders: function onheaders() {},\n            onprogress: function onprogress() {},\n            onload: function onload() {},\n            ontimeout: function ontimeout() {},\n            onerror: function onerror() {},\n            onabort: function onabort() {},\n            abort: function abort() {\n                aborted = true;\n                xhr.abort();\n            },\n        };\n\n        // timeout identifier, only used when timeout is defined\n        var aborted = false;\n        var headersReceived = false;\n\n        // set default options\n        options = Object.assign(\n            {\n                method: 'POST',\n                headers: {},\n                withCredentials: false,\n            },\n            options\n        );\n\n        // encode url\n        url = encodeURI(url);\n\n        // if method is GET, add any received data to url\n\n        if (isGet(options.method) && data) {\n            url =\n                '' +\n                url +\n                encodeURIComponent(typeof data === 'string' ? data : JSON.stringify(data));\n        }\n\n        // create request\n        var xhr = new XMLHttpRequest();\n\n        // progress of load\n        var process = isGet(options.method) ? xhr : xhr.upload;\n        process.onprogress = function(e) {\n            // no progress event when aborted ( onprogress is called once after abort() )\n            if (aborted) {\n                return;\n            }\n\n            api.onprogress(e.lengthComputable, e.loaded, e.total);\n        };\n\n        // tries to get header info to the app as fast as possible\n        xhr.onreadystatechange = function() {\n            // not interesting in these states ('unsent' and 'openend' as they don't give us any additional info)\n            if (xhr.readyState < 2) {\n                return;\n            }\n\n            // no server response\n            if (xhr.readyState === 4 && xhr.status === 0) {\n                return;\n            }\n\n            if (headersReceived) {\n                return;\n            }\n\n            headersReceived = true;\n\n            // we've probably received some useful data in response headers\n            api.onheaders(xhr);\n        };\n\n        // load successful\n        xhr.onload = function() {\n            // is classified as valid response\n            if (xhr.status >= 200 && xhr.status < 300) {\n                api.onload(xhr);\n            } else {\n                api.onerror(xhr);\n            }\n        };\n\n        // error during load\n        xhr.onerror = function() {\n            return api.onerror(xhr);\n        };\n\n        // request aborted\n        xhr.onabort = function() {\n            aborted = true;\n            api.onabort();\n        };\n\n        // request timeout\n        xhr.ontimeout = function() {\n            return api.ontimeout(xhr);\n        };\n\n        // open up open up!\n        xhr.open(options.method, url, true);\n\n        // set timeout if defined (do it after open so IE11 plays ball)\n        if (isInt(options.timeout)) {\n            xhr.timeout = options.timeout;\n        }\n\n        // add headers\n        Object.keys(options.headers).forEach(function(key) {\n            var value = unescape(encodeURIComponent(options.headers[key]));\n            xhr.setRequestHeader(key, value);\n        });\n\n        // set type of response\n        if (options.responseType) {\n            xhr.responseType = options.responseType;\n        }\n\n        // set credentials\n        if (options.withCredentials) {\n            xhr.withCredentials = true;\n        }\n\n        // let's send our data\n        xhr.send(data);\n\n        return api;\n    };\n\n    var createResponse = function createResponse(type, code, body, headers) {\n        return {\n            type: type,\n            code: code,\n            body: body,\n            headers: headers,\n        };\n    };\n\n    var createTimeoutResponse = function createTimeoutResponse(cb) {\n        return function(xhr) {\n            cb(createResponse('error', 0, 'Timeout', xhr.getAllResponseHeaders()));\n        };\n    };\n\n    var hasQS = function hasQS(str) {\n        return /\\?/.test(str);\n    };\n    var buildURL = function buildURL() {\n        var url = '';\n        for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {\n            parts[_key] = arguments[_key];\n        }\n        parts.forEach(function(part) {\n            url += hasQS(url) && hasQS(part) ? part.replace(/\\?/, '&') : part;\n        });\n        return url;\n    };\n\n    var createFetchFunction = function createFetchFunction() {\n        var apiUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var action = arguments.length > 1 ? arguments[1] : undefined;\n        // custom handler (should also handle file, load, error, progress and abort)\n        if (typeof action === 'function') {\n            return action;\n        }\n\n        // no action supplied\n        if (!action || !isString(action.url)) {\n            return null;\n        }\n\n        // set onload hanlder\n        var onload =\n            action.onload ||\n            function(res) {\n                return res;\n            };\n        var onerror =\n            action.onerror ||\n            function(res) {\n                return null;\n            };\n\n        // internal handler\n        return function(url, load, error, progress, abort, headers) {\n            // do local or remote request based on if the url is external\n            var request = sendRequest(\n                url,\n                buildURL(apiUrl, action.url),\n                Object.assign({}, action, {\n                    responseType: 'blob',\n                })\n            );\n\n            request.onload = function(xhr) {\n                // get headers\n                var headers = xhr.getAllResponseHeaders();\n\n                // get filename\n                var filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n                // create response\n                load(\n                    createResponse(\n                        'load',\n                        xhr.status,\n                        action.method === 'HEAD'\n                            ? null\n                            : getFileFromBlob(onload(xhr.response), filename),\n                        headers\n                    )\n                );\n            };\n\n            request.onerror = function(xhr) {\n                error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.onheaders = function(xhr) {\n                headers(createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders()));\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n            request.onprogress = progress;\n            request.onabort = abort;\n\n            // should return request\n            return request;\n        };\n    };\n\n    var ChunkStatus = {\n        QUEUED: 0,\n        COMPLETE: 1,\n        PROCESSING: 2,\n        ERROR: 3,\n        WAITING: 4,\n    };\n\n    /*\n                                                       function signature:\n                                                         (file, metadata, load, error, progress, abort, transfer, options) => {\n                                                           return {\n                                                           abort:() => {}\n                                                         }\n                                                       }\n                                                       */\n\n    // apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options\n    var processFileChunked = function processFileChunked(\n        apiUrl,\n        action,\n        name,\n        file,\n        metadata,\n        load,\n        error,\n        progress,\n        abort,\n        transfer,\n        options\n    ) {\n        // all chunks\n        var chunks = [];\n        var chunkTransferId = options.chunkTransferId,\n            chunkServer = options.chunkServer,\n            chunkSize = options.chunkSize,\n            chunkRetryDelays = options.chunkRetryDelays;\n\n        // default state\n        var state = {\n            serverId: chunkTransferId,\n            aborted: false,\n        };\n\n        // set onload handlers\n        var ondata =\n            action.ondata ||\n            function(fd) {\n                return fd;\n            };\n        var onload =\n            action.onload ||\n            function(xhr, method) {\n                return method === 'HEAD' ? xhr.getResponseHeader('Upload-Offset') : xhr.response;\n            };\n        var onerror =\n            action.onerror ||\n            function(res) {\n                return null;\n            };\n\n        // create server hook\n        var requestTransferId = function requestTransferId(cb) {\n            var formData = new FormData();\n\n            // add metadata under same name\n            if (isObject(metadata)) formData.append(name, JSON.stringify(metadata));\n\n            var headers =\n                typeof action.headers === 'function'\n                    ? action.headers(file, metadata)\n                    : Object.assign({}, action.headers, {\n                          'Upload-Length': file.size,\n                      });\n\n            var requestParams = Object.assign({}, action, {\n                headers: headers,\n            });\n\n            // send request object\n            var request = sendRequest(\n                ondata(formData),\n                buildURL(apiUrl, action.url),\n                requestParams\n            );\n\n            request.onload = function(xhr) {\n                return cb(onload(xhr, requestParams.method));\n            };\n\n            request.onerror = function(xhr) {\n                return error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n        };\n\n        var requestTransferOffset = function requestTransferOffset(cb) {\n            var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n            var headers =\n                typeof action.headers === 'function'\n                    ? action.headers(state.serverId)\n                    : Object.assign({}, action.headers);\n\n            var requestParams = {\n                headers: headers,\n                method: 'HEAD',\n            };\n\n            var request = sendRequest(null, requestUrl, requestParams);\n\n            request.onload = function(xhr) {\n                return cb(onload(xhr, requestParams.method));\n            };\n\n            request.onerror = function(xhr) {\n                return error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n        };\n\n        // create chunks\n        var lastChunkIndex = Math.floor(file.size / chunkSize);\n        for (var i = 0; i <= lastChunkIndex; i++) {\n            var offset = i * chunkSize;\n            var data = file.slice(offset, offset + chunkSize, 'application/offset+octet-stream');\n            chunks[i] = {\n                index: i,\n                size: data.size,\n                offset: offset,\n                data: data,\n                file: file,\n                progress: 0,\n                retries: _toConsumableArray(chunkRetryDelays),\n                status: ChunkStatus.QUEUED,\n                error: null,\n                request: null,\n                timeout: null,\n            };\n        }\n\n        var completeProcessingChunks = function completeProcessingChunks() {\n            return load(state.serverId);\n        };\n\n        var canProcessChunk = function canProcessChunk(chunk) {\n            return chunk.status === ChunkStatus.QUEUED || chunk.status === ChunkStatus.ERROR;\n        };\n\n        var processChunk = function processChunk(chunk) {\n            // processing is paused, wait here\n            if (state.aborted) return;\n\n            // get next chunk to process\n            chunk = chunk || chunks.find(canProcessChunk);\n\n            // no more chunks to process\n            if (!chunk) {\n                // all done?\n                if (\n                    chunks.every(function(chunk) {\n                        return chunk.status === ChunkStatus.COMPLETE;\n                    })\n                ) {\n                    completeProcessingChunks();\n                }\n\n                // no chunk to handle\n                return;\n            }\n\n            // now processing this chunk\n            chunk.status = ChunkStatus.PROCESSING;\n            chunk.progress = null;\n\n            // allow parsing of formdata\n            var ondata =\n                chunkServer.ondata ||\n                function(fd) {\n                    return fd;\n                };\n            var onerror =\n                chunkServer.onerror ||\n                function(res) {\n                    return null;\n                };\n\n            // send request object\n            var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n            var headers =\n                typeof chunkServer.headers === 'function'\n                    ? chunkServer.headers(chunk)\n                    : Object.assign({}, chunkServer.headers, {\n                          'Content-Type': 'application/offset+octet-stream',\n                          'Upload-Offset': chunk.offset,\n                          'Upload-Length': file.size,\n                          'Upload-Name': file.name,\n                      });\n\n            var request = (chunk.request = sendRequest(\n                ondata(chunk.data),\n                requestUrl,\n                Object.assign({}, chunkServer, {\n                    headers: headers,\n                })\n            ));\n\n            request.onload = function() {\n                // done!\n                chunk.status = ChunkStatus.COMPLETE;\n\n                // remove request reference\n                chunk.request = null;\n\n                // start processing more chunks\n                processChunks();\n            };\n\n            request.onprogress = function(lengthComputable, loaded, total) {\n                chunk.progress = lengthComputable ? loaded : null;\n                updateTotalProgress();\n            };\n\n            request.onerror = function(xhr) {\n                chunk.status = ChunkStatus.ERROR;\n                chunk.request = null;\n                chunk.error = onerror(xhr.response) || xhr.statusText;\n                if (!retryProcessChunk(chunk)) {\n                    error(\n                        createResponse(\n                            'error',\n                            xhr.status,\n                            onerror(xhr.response) || xhr.statusText,\n                            xhr.getAllResponseHeaders()\n                        )\n                    );\n                }\n            };\n\n            request.ontimeout = function(xhr) {\n                chunk.status = ChunkStatus.ERROR;\n                chunk.request = null;\n                if (!retryProcessChunk(chunk)) {\n                    createTimeoutResponse(error)(xhr);\n                }\n            };\n\n            request.onabort = function() {\n                chunk.status = ChunkStatus.QUEUED;\n                chunk.request = null;\n                abort();\n            };\n        };\n\n        var retryProcessChunk = function retryProcessChunk(chunk) {\n            // no more retries left\n            if (chunk.retries.length === 0) return false;\n\n            // new retry\n            chunk.status = ChunkStatus.WAITING;\n            clearTimeout(chunk.timeout);\n            chunk.timeout = setTimeout(function() {\n                processChunk(chunk);\n            }, chunk.retries.shift());\n\n            // we're going to retry\n            return true;\n        };\n\n        var updateTotalProgress = function updateTotalProgress() {\n            // calculate total progress fraction\n            var totalBytesTransfered = chunks.reduce(function(p, chunk) {\n                if (p === null || chunk.progress === null) return null;\n                return p + chunk.progress;\n            }, 0);\n\n            // can't compute progress\n            if (totalBytesTransfered === null) return progress(false, 0, 0);\n\n            // calculate progress values\n            var totalSize = chunks.reduce(function(total, chunk) {\n                return total + chunk.size;\n            }, 0);\n\n            // can update progress indicator\n            progress(true, totalBytesTransfered, totalSize);\n        };\n\n        // process new chunks\n        var processChunks = function processChunks() {\n            var totalProcessing = chunks.filter(function(chunk) {\n                return chunk.status === ChunkStatus.PROCESSING;\n            }).length;\n            if (totalProcessing >= 1) return;\n            processChunk();\n        };\n\n        var abortChunks = function abortChunks() {\n            chunks.forEach(function(chunk) {\n                clearTimeout(chunk.timeout);\n                if (chunk.request) {\n                    chunk.request.abort();\n                }\n            });\n        };\n\n        // let's go!\n        if (!state.serverId) {\n            requestTransferId(function(serverId) {\n                // stop here if aborted, might have happened in between request and callback\n                if (state.aborted) return;\n\n                // pass back to item so we can use it if something goes wrong\n                transfer(serverId);\n\n                // store internally\n                state.serverId = serverId;\n                processChunks();\n            });\n        } else {\n            requestTransferOffset(function(offset) {\n                // stop here if aborted, might have happened in between request and callback\n                if (state.aborted) return;\n\n                // mark chunks with lower offset as complete\n                chunks\n                    .filter(function(chunk) {\n                        return chunk.offset < offset;\n                    })\n                    .forEach(function(chunk) {\n                        chunk.status = ChunkStatus.COMPLETE;\n                        chunk.progress = chunk.size;\n                    });\n\n                // continue processing\n                processChunks();\n            });\n        }\n\n        return {\n            abort: function abort() {\n                state.aborted = true;\n                abortChunks();\n            },\n        };\n    };\n\n    /*\n                                                               function signature:\n                                                                 (file, metadata, load, error, progress, abort) => {\n                                                                   return {\n                                                                   abort:() => {}\n                                                                 }\n                                                               }\n                                                               */\n    var createFileProcessorFunction = function createFileProcessorFunction(\n        apiUrl,\n        action,\n        name,\n        options\n    ) {\n        return function(file, metadata, load, error, progress, abort, transfer) {\n            // no file received\n            if (!file) return;\n\n            // if was passed a file, and we can chunk it, exit here\n            var canChunkUpload = options.chunkUploads;\n            var shouldChunkUpload = canChunkUpload && file.size > options.chunkSize;\n            var willChunkUpload = canChunkUpload && (shouldChunkUpload || options.chunkForce);\n            if (file instanceof Blob && willChunkUpload)\n                return processFileChunked(\n                    apiUrl,\n                    action,\n                    name,\n                    file,\n                    metadata,\n                    load,\n                    error,\n                    progress,\n                    abort,\n                    transfer,\n                    options\n                );\n\n            // set handlers\n            var ondata =\n                action.ondata ||\n                function(fd) {\n                    return fd;\n                };\n            var onload =\n                action.onload ||\n                function(res) {\n                    return res;\n                };\n            var onerror =\n                action.onerror ||\n                function(res) {\n                    return null;\n                };\n\n            var headers =\n                typeof action.headers === 'function'\n                    ? action.headers(file, metadata) || {}\n                    : Object.assign(\n                          {},\n\n                          action.headers\n                      );\n\n            var requestParams = Object.assign({}, action, {\n                headers: headers,\n            });\n\n            // create formdata object\n            var formData = new FormData();\n\n            // add metadata under same name\n            if (isObject(metadata)) {\n                formData.append(name, JSON.stringify(metadata));\n            }\n\n            // Turn into an array of objects so no matter what the input, we can handle it the same way\n            (file instanceof Blob ? [{ name: null, file: file }] : file).forEach(function(item) {\n                formData.append(\n                    name,\n                    item.file,\n                    item.name === null ? item.file.name : '' + item.name + item.file.name\n                );\n            });\n\n            // send request object\n            var request = sendRequest(\n                ondata(formData),\n                buildURL(apiUrl, action.url),\n                requestParams\n            );\n            request.onload = function(xhr) {\n                load(\n                    createResponse(\n                        'load',\n                        xhr.status,\n                        onload(xhr.response),\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.onerror = function(xhr) {\n                error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n            request.onprogress = progress;\n            request.onabort = abort;\n\n            // should return request\n            return request;\n        };\n    };\n\n    var createProcessorFunction = function createProcessorFunction() {\n        var apiUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var action = arguments.length > 1 ? arguments[1] : undefined;\n        var name = arguments.length > 2 ? arguments[2] : undefined;\n        var options = arguments.length > 3 ? arguments[3] : undefined;\n\n        // custom handler (should also handle file, load, error, progress and abort)\n        if (typeof action === 'function')\n            return function() {\n                for (\n                    var _len = arguments.length, params = new Array(_len), _key = 0;\n                    _key < _len;\n                    _key++\n                ) {\n                    params[_key] = arguments[_key];\n                }\n                return action.apply(void 0, [name].concat(params, [options]));\n            };\n\n        // no action supplied\n        if (!action || !isString(action.url)) return null;\n\n        // internal handler\n        return createFileProcessorFunction(apiUrl, action, name, options);\n    };\n\n    /*\n                                                      function signature:\n                                                      (uniqueFileId, load, error) => { }\n                                                      */\n    var createRevertFunction = function createRevertFunction() {\n        var apiUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var action = arguments.length > 1 ? arguments[1] : undefined;\n        // is custom implementation\n        if (typeof action === 'function') {\n            return action;\n        }\n\n        // no action supplied, return stub function, interface will work, but file won't be removed\n        if (!action || !isString(action.url)) {\n            return function(uniqueFileId, load) {\n                return load();\n            };\n        }\n\n        // set onload hanlder\n        var onload =\n            action.onload ||\n            function(res) {\n                return res;\n            };\n        var onerror =\n            action.onerror ||\n            function(res) {\n                return null;\n            };\n\n        // internal implementation\n        return function(uniqueFileId, load, error) {\n            var request = sendRequest(\n                uniqueFileId,\n                apiUrl + action.url,\n                action // contains method, headers and withCredentials properties\n            );\n            request.onload = function(xhr) {\n                load(\n                    createResponse(\n                        'load',\n                        xhr.status,\n                        onload(xhr.response),\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.onerror = function(xhr) {\n                error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n\n            return request;\n        };\n    };\n\n    var getRandomNumber = function getRandomNumber() {\n        var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        return min + Math.random() * (max - min);\n    };\n\n    var createPerceivedPerformanceUpdater = function createPerceivedPerformanceUpdater(cb) {\n        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var tickMin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 25;\n        var tickMax = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;\n        var timeout = null;\n        var start = Date.now();\n\n        var tick = function tick() {\n            var runtime = Date.now() - start;\n            var delay = getRandomNumber(tickMin, tickMax);\n\n            if (runtime + delay > duration) {\n                delay = runtime + delay - duration;\n            }\n\n            var progress = runtime / duration;\n            if (progress >= 1 || document.hidden) {\n                cb(1);\n                return;\n            }\n\n            cb(progress);\n\n            timeout = setTimeout(tick, delay);\n        };\n\n        if (duration > 0) tick();\n\n        return {\n            clear: function clear() {\n                clearTimeout(timeout);\n            },\n        };\n    };\n\n    var createFileProcessor = function createFileProcessor(processFn, options) {\n        var state = {\n            complete: false,\n            perceivedProgress: 0,\n            perceivedPerformanceUpdater: null,\n            progress: null,\n            timestamp: null,\n            perceivedDuration: 0,\n            duration: 0,\n            request: null,\n            response: null,\n        };\n        var allowMinimumUploadDuration = options.allowMinimumUploadDuration;\n\n        var process = function process(file, metadata) {\n            var progressFn = function progressFn() {\n                // we've not yet started the real download, stop here\n                // the request might not go through, for instance, there might be some server trouble\n                // if state.progress is null, the server does not allow computing progress and we show the spinner instead\n                if (state.duration === 0 || state.progress === null) return;\n\n                // as we're now processing, fire the progress event\n                api.fire('progress', api.getProgress());\n            };\n\n            var completeFn = function completeFn() {\n                state.complete = true;\n                api.fire('load-perceived', state.response.body);\n            };\n\n            // let's start processing\n            api.fire('start');\n\n            // set request start\n            state.timestamp = Date.now();\n\n            // create perceived performance progress indicator\n            state.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(\n                function(progress) {\n                    state.perceivedProgress = progress;\n                    state.perceivedDuration = Date.now() - state.timestamp;\n\n                    progressFn();\n\n                    // if fake progress is done, and a response has been received,\n                    // and we've not yet called the complete method\n                    if (state.response && state.perceivedProgress === 1 && !state.complete) {\n                        // we done!\n                        completeFn();\n                    }\n                },\n                // random delay as in a list of files you start noticing\n                // files uploading at the exact same speed\n                allowMinimumUploadDuration ? getRandomNumber(750, 1500) : 0\n            );\n\n            // remember request so we can abort it later\n            state.request = processFn(\n                // the file to process\n                file,\n\n                // the metadata to send along\n                metadata,\n\n                // callbacks (load, error, progress, abort, transfer)\n                // load expects the body to be a server id if\n                // you want to make use of revert\n                function(response) {\n                    // we put the response in state so we can access\n                    // it outside of this method\n                    state.response = isObject(response)\n                        ? response\n                        : {\n                              type: 'load',\n                              code: 200,\n                              body: '' + response,\n                              headers: {},\n                          };\n\n                    // update duration\n                    state.duration = Date.now() - state.timestamp;\n\n                    // force progress to 1 as we're now done\n                    state.progress = 1;\n\n                    // actual load is done let's share results\n                    api.fire('load', state.response.body);\n\n                    // we are really done\n                    // if perceived progress is 1 ( wait for perceived progress to complete )\n                    // or if server does not support progress ( null )\n                    if (\n                        !allowMinimumUploadDuration ||\n                        (allowMinimumUploadDuration && state.perceivedProgress === 1)\n                    ) {\n                        completeFn();\n                    }\n                },\n\n                // error is expected to be an object with type, code, body\n                function(error) {\n                    // cancel updater\n                    state.perceivedPerformanceUpdater.clear();\n\n                    // update others about this error\n                    api.fire(\n                        'error',\n                        isObject(error)\n                            ? error\n                            : {\n                                  type: 'error',\n                                  code: 0,\n                                  body: '' + error,\n                              }\n                    );\n                },\n\n                // actual processing progress\n                function(computable, current, total) {\n                    // update actual duration\n                    state.duration = Date.now() - state.timestamp;\n\n                    // update actual progress\n                    state.progress = computable ? current / total : null;\n\n                    progressFn();\n                },\n\n                // abort does not expect a value\n                function() {\n                    // stop updater\n                    state.perceivedPerformanceUpdater.clear();\n\n                    // fire the abort event so we can switch visuals\n                    api.fire('abort', state.response ? state.response.body : null);\n                },\n\n                // register the id for this transfer\n                function(transferId) {\n                    api.fire('transfer', transferId);\n                }\n            );\n        };\n\n        var abort = function abort() {\n            // no request running, can't abort\n            if (!state.request) return;\n\n            // stop updater\n            state.perceivedPerformanceUpdater.clear();\n\n            // abort actual request\n            if (state.request.abort) state.request.abort();\n\n            // if has response object, we've completed the request\n            state.complete = true;\n        };\n\n        var reset = function reset() {\n            abort();\n            state.complete = false;\n            state.perceivedProgress = 0;\n            state.progress = 0;\n            state.timestamp = null;\n            state.perceivedDuration = 0;\n            state.duration = 0;\n            state.request = null;\n            state.response = null;\n        };\n\n        var getProgress = allowMinimumUploadDuration\n            ? function() {\n                  return state.progress ? Math.min(state.progress, state.perceivedProgress) : null;\n              }\n            : function() {\n                  return state.progress || null;\n              };\n\n        var getDuration = allowMinimumUploadDuration\n            ? function() {\n                  return Math.min(state.duration, state.perceivedDuration);\n              }\n            : function() {\n                  return state.duration;\n              };\n\n        var api = Object.assign({}, on(), {\n            process: process, // start processing file\n            abort: abort, // abort active process request\n            getProgress: getProgress,\n            getDuration: getDuration,\n            reset: reset,\n        });\n\n        return api;\n    };\n\n    var getFilenameWithoutExtension = function getFilenameWithoutExtension(name) {\n        return name.substring(0, name.lastIndexOf('.')) || name;\n    };\n\n    var createFileStub = function createFileStub(source) {\n        var data = [source.name, source.size, source.type];\n\n        // is blob or base64, then we need to set the name\n        if (source instanceof Blob || isBase64DataURI(source)) {\n            data[0] = source.name || getDateString();\n        } else if (isBase64DataURI(source)) {\n            // if is base64 data uri we need to determine the average size and type\n            data[1] = source.length;\n            data[2] = getMimeTypeFromBase64DataURI(source);\n        } else if (isString(source)) {\n            // url\n            data[0] = getFilenameFromURL(source);\n            data[1] = 0;\n            data[2] = 'application/octet-stream';\n        }\n\n        return {\n            name: data[0],\n            size: data[1],\n            type: data[2],\n        };\n    };\n\n    var isFile = function isFile(value) {\n        return !!(value instanceof File || (value instanceof Blob && value.name));\n    };\n\n    var deepCloneObject = function deepCloneObject(src) {\n        if (!isObject(src)) return src;\n        var target = isArray(src) ? [] : {};\n        for (var key in src) {\n            if (!src.hasOwnProperty(key)) continue;\n            var v = src[key];\n            target[key] = v && isObject(v) ? deepCloneObject(v) : v;\n        }\n        return target;\n    };\n\n    var createItem = function createItem() {\n        var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var serverFileReference =\n            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        // unique id for this item, is used to identify the item across views\n        var id = getUniqueId();\n\n        /**\n         * Internal item state\n         */\n        var state = {\n            // is archived\n            archived: false,\n\n            // if is frozen, no longer fires events\n            frozen: false,\n\n            // removed from view\n            released: false,\n\n            // original source\n            source: null,\n\n            // file model reference\n            file: file,\n\n            // id of file on server\n            serverFileReference: serverFileReference,\n\n            // id of file transfer on server\n            transferId: null,\n\n            // is aborted\n            processingAborted: false,\n\n            // current item status\n            status: serverFileReference ? ItemStatus.PROCESSING_COMPLETE : ItemStatus.INIT,\n\n            // active processes\n            activeLoader: null,\n            activeProcessor: null,\n        };\n\n        // callback used when abort processing is called to link back to the resolve method\n        var abortProcessingRequestComplete = null;\n\n        /**\n         * Externally added item metadata\n         */\n        var metadata = {};\n\n        // item data\n        var setStatus = function setStatus(status) {\n            return (state.status = status);\n        };\n\n        // fire event unless the item has been archived\n        var fire = function fire(event) {\n            if (state.released || state.frozen) return;\n            for (\n                var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1;\n                _key < _len;\n                _key++\n            ) {\n                params[_key - 1] = arguments[_key];\n            }\n            api.fire.apply(api, [event].concat(params));\n        };\n\n        // file data\n        var getFileExtension = function getFileExtension() {\n            return getExtensionFromFilename(state.file.name);\n        };\n        var getFileType = function getFileType() {\n            return state.file.type;\n        };\n        var getFileSize = function getFileSize() {\n            return state.file.size;\n        };\n        var getFile = function getFile() {\n            return state.file;\n        };\n\n        //\n        // logic to load a file\n        //\n        var load = function load(source, loader, onload) {\n            // remember the original item source\n            state.source = source;\n\n            // source is known\n            api.fireSync('init');\n\n            // file stub is already there\n            if (state.file) {\n                api.fireSync('load-skip');\n                return;\n            }\n\n            // set a stub file object while loading the actual data\n            state.file = createFileStub(source);\n\n            // starts loading\n            loader.on('init', function() {\n                fire('load-init');\n            });\n\n            // we'eve received a size indication, let's update the stub\n            loader.on('meta', function(meta) {\n                // set size of file stub\n                state.file.size = meta.size;\n\n                // set name of file stub\n                state.file.filename = meta.filename;\n\n                // if has received source, we done\n                if (meta.source) {\n                    origin = FileOrigin.LIMBO;\n                    state.serverFileReference = meta.source;\n                    state.status = ItemStatus.PROCESSING_COMPLETE;\n                }\n\n                // size has been updated\n                fire('load-meta');\n            });\n\n            // the file is now loading we need to update the progress indicators\n            loader.on('progress', function(progress) {\n                setStatus(ItemStatus.LOADING);\n\n                fire('load-progress', progress);\n            });\n\n            // an error was thrown while loading the file, we need to switch to error state\n            loader.on('error', function(error) {\n                setStatus(ItemStatus.LOAD_ERROR);\n\n                fire('load-request-error', error);\n            });\n\n            // user or another process aborted the file load (cannot retry)\n            loader.on('abort', function() {\n                setStatus(ItemStatus.INIT);\n                fire('load-abort');\n            });\n\n            // done loading\n            loader.on('load', function(file) {\n                // as we've now loaded the file the loader is no longer required\n                state.activeLoader = null;\n\n                // called when file has loaded succesfully\n                var success = function success(result) {\n                    // set (possibly) transformed file\n                    state.file = isFile(result) ? result : state.file;\n\n                    // file received\n                    if (origin === FileOrigin.LIMBO && state.serverFileReference) {\n                        setStatus(ItemStatus.PROCESSING_COMPLETE);\n                    } else {\n                        setStatus(ItemStatus.IDLE);\n                    }\n\n                    fire('load');\n                };\n\n                var error = function error(result) {\n                    // set original file\n                    state.file = file;\n                    fire('load-meta');\n\n                    setStatus(ItemStatus.LOAD_ERROR);\n                    fire('load-file-error', result);\n                };\n\n                // if we already have a server file reference, we don't need to call the onload method\n                if (state.serverFileReference) {\n                    success(file);\n                    return;\n                }\n\n                // no server id, let's give this file the full treatment\n                onload(file, success, error);\n            });\n\n            // set loader source data\n            loader.setSource(source);\n\n            // set as active loader\n            state.activeLoader = loader;\n\n            // load the source data\n            loader.load();\n        };\n\n        var retryLoad = function retryLoad() {\n            if (!state.activeLoader) {\n                return;\n            }\n            state.activeLoader.load();\n        };\n\n        var abortLoad = function abortLoad() {\n            if (state.activeLoader) {\n                state.activeLoader.abort();\n                return;\n            }\n            setStatus(ItemStatus.INIT);\n            fire('load-abort');\n        };\n\n        //\n        // logic to process a file\n        //\n        var process = function process(processor, onprocess) {\n            // processing was aborted\n            if (state.processingAborted) {\n                state.processingAborted = false;\n                return;\n            }\n\n            // now processing\n            setStatus(ItemStatus.PROCESSING);\n\n            // reset abort callback\n            abortProcessingRequestComplete = null;\n\n            // if no file loaded we'll wait for the load event\n            if (!(state.file instanceof Blob)) {\n                api.on('load', function() {\n                    process(processor, onprocess);\n                });\n                return;\n            }\n\n            // setup processor\n            processor.on('load', function(serverFileReference) {\n                // need this id to be able to revert the upload\n                state.transferId = null;\n                state.serverFileReference = serverFileReference;\n            });\n\n            // register transfer id\n            processor.on('transfer', function(transferId) {\n                // need this id to be able to revert the upload\n                state.transferId = transferId;\n            });\n\n            processor.on('load-perceived', function(serverFileReference) {\n                // no longer required\n                state.activeProcessor = null;\n\n                // need this id to be able to rever the upload\n                state.transferId = null;\n                state.serverFileReference = serverFileReference;\n\n                setStatus(ItemStatus.PROCESSING_COMPLETE);\n                fire('process-complete', serverFileReference);\n            });\n\n            processor.on('start', function() {\n                fire('process-start');\n            });\n\n            processor.on('error', function(error) {\n                state.activeProcessor = null;\n                setStatus(ItemStatus.PROCESSING_ERROR);\n                fire('process-error', error);\n            });\n\n            processor.on('abort', function(serverFileReference) {\n                state.activeProcessor = null;\n\n                // if file was uploaded but processing was cancelled during perceived processor time store file reference\n                state.serverFileReference = serverFileReference;\n\n                setStatus(ItemStatus.IDLE);\n                fire('process-abort');\n\n                // has timeout so doesn't interfere with remove action\n                if (abortProcessingRequestComplete) {\n                    abortProcessingRequestComplete();\n                }\n            });\n\n            processor.on('progress', function(progress) {\n                fire('process-progress', progress);\n            });\n\n            // when successfully transformed\n            var success = function success(file) {\n                // if was archived in the mean time, don't process\n                if (state.archived) return;\n\n                // process file!\n                processor.process(file, Object.assign({}, metadata));\n            };\n\n            // something went wrong during transform phase\n            var error = console.error;\n\n            // start processing the file\n            onprocess(state.file, success, error);\n\n            // set as active processor\n            state.activeProcessor = processor;\n        };\n\n        var requestProcessing = function requestProcessing() {\n            state.processingAborted = false;\n            setStatus(ItemStatus.PROCESSING_QUEUED);\n        };\n\n        var abortProcessing = function abortProcessing() {\n            return new Promise(function(resolve) {\n                if (!state.activeProcessor) {\n                    state.processingAborted = true;\n\n                    setStatus(ItemStatus.IDLE);\n                    fire('process-abort');\n\n                    resolve();\n                    return;\n                }\n\n                abortProcessingRequestComplete = function abortProcessingRequestComplete() {\n                    resolve();\n                };\n\n                state.activeProcessor.abort();\n            });\n        };\n\n        //\n        // logic to revert a processed file\n        //\n        var revert = function revert(revertFileUpload, forceRevert) {\n            return new Promise(function(resolve, reject) {\n                // a completed upload will have a serverFileReference, a failed chunked upload where\n                // getting a serverId succeeded but >=0 chunks have been uploaded will have transferId set\n                var serverTransferId =\n                    state.serverFileReference !== null\n                        ? state.serverFileReference\n                        : state.transferId;\n\n                // cannot revert without a server id for this process\n                if (serverTransferId === null) {\n                    resolve();\n                    return;\n                }\n\n                // revert the upload (fire and forget)\n                revertFileUpload(\n                    serverTransferId,\n                    function() {\n                        // reset file server id and transfer id as now it's not available on the server\n                        state.serverFileReference = null;\n                        state.transferId = null;\n                        resolve();\n                    },\n                    function(error) {\n                        // don't set error state when reverting is optional, it will always resolve\n                        if (!forceRevert) {\n                            resolve();\n                            return;\n                        }\n\n                        // oh no errors\n                        setStatus(ItemStatus.PROCESSING_REVERT_ERROR);\n                        fire('process-revert-error');\n                        reject(error);\n                    }\n                );\n\n                // fire event\n                setStatus(ItemStatus.IDLE);\n                fire('process-revert');\n            });\n        };\n\n        // exposed methods\n        var _setMetadata = function setMetadata(key, value, silent) {\n            var keys = key.split('.');\n            var root = keys[0];\n            var last = keys.pop();\n            var data = metadata;\n            keys.forEach(function(key) {\n                return (data = data[key]);\n            });\n\n            // compare old value against new value, if they're the same, we're not updating\n            if (JSON.stringify(data[last]) === JSON.stringify(value)) return;\n\n            // update value\n            data[last] = value;\n\n            // fire update\n            fire('metadata-update', {\n                key: root,\n                value: metadata[root],\n                silent: silent,\n            });\n        };\n\n        var getMetadata = function getMetadata(key) {\n            return deepCloneObject(key ? metadata[key] : metadata);\n        };\n\n        var api = Object.assign(\n            {\n                id: {\n                    get: function get() {\n                        return id;\n                    },\n                },\n                origin: {\n                    get: function get() {\n                        return origin;\n                    },\n                    set: function set(value) {\n                        return (origin = value);\n                    },\n                },\n                serverId: {\n                    get: function get() {\n                        return state.serverFileReference;\n                    },\n                },\n                transferId: {\n                    get: function get() {\n                        return state.transferId;\n                    },\n                },\n                status: {\n                    get: function get() {\n                        return state.status;\n                    },\n                },\n                filename: {\n                    get: function get() {\n                        return state.file.name;\n                    },\n                },\n                filenameWithoutExtension: {\n                    get: function get() {\n                        return getFilenameWithoutExtension(state.file.name);\n                    },\n                },\n                fileExtension: { get: getFileExtension },\n                fileType: { get: getFileType },\n                fileSize: { get: getFileSize },\n                file: { get: getFile },\n                relativePath: {\n                    get: function get() {\n                        return state.file._relativePath;\n                    },\n                },\n\n                source: {\n                    get: function get() {\n                        return state.source;\n                    },\n                },\n\n                getMetadata: getMetadata,\n                setMetadata: function setMetadata(key, value, silent) {\n                    if (isObject(key)) {\n                        var data = key;\n                        Object.keys(data).forEach(function(key) {\n                            _setMetadata(key, data[key], value);\n                        });\n                        return key;\n                    }\n                    _setMetadata(key, value, silent);\n                    return value;\n                },\n\n                extend: function extend(name, handler) {\n                    return (itemAPI[name] = handler);\n                },\n\n                abortLoad: abortLoad,\n                retryLoad: retryLoad,\n                requestProcessing: requestProcessing,\n                abortProcessing: abortProcessing,\n\n                load: load,\n                process: process,\n                revert: revert,\n            },\n\n            on(),\n            {\n                freeze: function freeze() {\n                    return (state.frozen = true);\n                },\n\n                release: function release() {\n                    return (state.released = true);\n                },\n                released: {\n                    get: function get() {\n                        return state.released;\n                    },\n                },\n\n                archive: function archive() {\n                    return (state.archived = true);\n                },\n                archived: {\n                    get: function get() {\n                        return state.archived;\n                    },\n                },\n\n                // replace source and file object\n                setFile: function setFile(file) {\n                    return (state.file = file);\n                },\n            }\n        );\n\n        // create it here instead of returning it instantly so we can extend it later\n        var itemAPI = createObject(api);\n\n        return itemAPI;\n    };\n\n    var getItemIndexByQuery = function getItemIndexByQuery(items, query) {\n        // just return first index\n        if (isEmpty(query)) {\n            return 0;\n        }\n\n        // invalid queries\n        if (!isString(query)) {\n            return -1;\n        }\n\n        // return item by id (or -1 if not found)\n        return items.findIndex(function(item) {\n            return item.id === query;\n        });\n    };\n\n    var getItemById = function getItemById(items, itemId) {\n        var index = getItemIndexByQuery(items, itemId);\n        if (index < 0) {\n            return;\n        }\n        return items[index] || null;\n    };\n\n    var fetchBlob = function fetchBlob(url, load, error, progress, abort, headers) {\n        var request = sendRequest(null, url, {\n            method: 'GET',\n            responseType: 'blob',\n        });\n\n        request.onload = function(xhr) {\n            // get headers\n            var headers = xhr.getAllResponseHeaders();\n\n            // get filename\n            var filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n            // create response\n            load(\n                createResponse('load', xhr.status, getFileFromBlob(xhr.response, filename), headers)\n            );\n        };\n\n        request.onerror = function(xhr) {\n            error(createResponse('error', xhr.status, xhr.statusText, xhr.getAllResponseHeaders()));\n        };\n\n        request.onheaders = function(xhr) {\n            headers(createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders()));\n        };\n\n        request.ontimeout = createTimeoutResponse(error);\n        request.onprogress = progress;\n        request.onabort = abort;\n\n        // should return request\n        return request;\n    };\n\n    var getDomainFromURL = function getDomainFromURL(url) {\n        if (url.indexOf('//') === 0) {\n            url = location.protocol + url;\n        }\n        return url\n            .toLowerCase()\n            .replace('blob:', '')\n            .replace(/([a-z])?:\\/\\//, '$1')\n            .split('/')[0];\n    };\n\n    var isExternalURL = function isExternalURL(url) {\n        return (\n            (url.indexOf(':') > -1 || url.indexOf('//') > -1) &&\n            getDomainFromURL(location.href) !== getDomainFromURL(url)\n        );\n    };\n\n    var dynamicLabel = function dynamicLabel(label) {\n        return function() {\n            return isFunction(label) ? label.apply(void 0, arguments) : label;\n        };\n    };\n\n    var isMockItem = function isMockItem(item) {\n        return !isFile(item.file);\n    };\n\n    var listUpdated = function listUpdated(dispatch, state) {\n        clearTimeout(state.listUpdateTimeout);\n        state.listUpdateTimeout = setTimeout(function() {\n            dispatch('DID_UPDATE_ITEMS', { items: getActiveItems(state.items) });\n        }, 0);\n    };\n\n    var optionalPromise = function optionalPromise(fn) {\n        for (\n            var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1;\n            _key < _len;\n            _key++\n        ) {\n            params[_key - 1] = arguments[_key];\n        }\n        return new Promise(function(resolve) {\n            if (!fn) {\n                return resolve(true);\n            }\n\n            var result = fn.apply(void 0, params);\n\n            if (result == null) {\n                return resolve(true);\n            }\n\n            if (typeof result === 'boolean') {\n                return resolve(result);\n            }\n\n            if (typeof result.then === 'function') {\n                result.then(resolve);\n            }\n        });\n    };\n\n    var sortItems = function sortItems(state, compare) {\n        state.items.sort(function(a, b) {\n            return compare(createItemAPI(a), createItemAPI(b));\n        });\n    };\n\n    // returns item based on state\n    var getItemByQueryFromState = function getItemByQueryFromState(state, itemHandler) {\n        return function() {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            var query = _ref.query,\n                _ref$success = _ref.success,\n                success = _ref$success === void 0 ? function() {} : _ref$success,\n                _ref$failure = _ref.failure,\n                failure = _ref$failure === void 0 ? function() {} : _ref$failure,\n                options = _objectWithoutProperties(_ref, ['query', 'success', 'failure']);\n            var item = getItemByQuery(state.items, query);\n            if (!item) {\n                failure({\n                    error: createResponse('error', 0, 'Item not found'),\n                    file: null,\n                });\n\n                return;\n            }\n            itemHandler(item, success, failure, options || {});\n        };\n    };\n\n    var actions = function actions(dispatch, query, state) {\n        return {\n            /**\n             * Aborts all ongoing processes\n             */\n            ABORT_ALL: function ABORT_ALL() {\n                getActiveItems(state.items).forEach(function(item) {\n                    item.freeze();\n                    item.abortLoad();\n                    item.abortProcessing();\n                });\n            },\n\n            /**\n             * Sets initial files\n             */\n            DID_SET_FILES: function DID_SET_FILES(_ref2) {\n                var _ref2$value = _ref2.value,\n                    value = _ref2$value === void 0 ? [] : _ref2$value;\n                // map values to file objects\n                var files = value.map(function(file) {\n                    return {\n                        source: file.source ? file.source : file,\n                        options: file.options,\n                    };\n                });\n\n                // loop over files, if file is in list, leave it be, if not, remove\n                // test if items should be moved\n                var activeItems = getActiveItems(state.items);\n\n                activeItems.forEach(function(item) {\n                    // if item not is in new value, remove\n                    if (\n                        !files.find(function(file) {\n                            return file.source === item.source || file.source === item.file;\n                        })\n                    ) {\n                        dispatch('REMOVE_ITEM', { query: item, remove: false });\n                    }\n                });\n\n                // add new files\n                activeItems = getActiveItems(state.items);\n                files.forEach(function(file, index) {\n                    // if file is already in list\n                    if (\n                        activeItems.find(function(item) {\n                            return item.source === file.source || item.file === file.source;\n                        })\n                    )\n                        return;\n\n                    // not in list, add\n                    dispatch(\n                        'ADD_ITEM',\n                        Object.assign({}, file, {\n                            interactionMethod: InteractionMethod.NONE,\n                            index: index,\n                        })\n                    );\n                });\n            },\n\n            DID_UPDATE_ITEM_METADATA: function DID_UPDATE_ITEM_METADATA(_ref3) {\n                var id = _ref3.id,\n                    action = _ref3.action,\n                    change = _ref3.change;\n                // don't do anything\n                if (change.silent) return;\n\n                // if is called multiple times in close succession we combined all calls together to save resources\n                clearTimeout(state.itemUpdateTimeout);\n                state.itemUpdateTimeout = setTimeout(function() {\n                    var item = getItemById(state.items, id);\n\n                    // only revert and attempt to upload when we're uploading to a server\n                    if (!query('IS_ASYNC')) {\n                        // should we update the output data\n                        applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n                            item: item,\n                            query: query,\n                            action: action,\n                            change: change,\n                        }).then(function(shouldPrepareOutput) {\n                            // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n                            var beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');\n                            if (beforePrepareFile)\n                                shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);\n\n                            if (!shouldPrepareOutput) return;\n\n                            dispatch(\n                                'REQUEST_PREPARE_OUTPUT',\n                                {\n                                    query: id,\n                                    item: item,\n                                    success: function success(file) {\n                                        dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                                    },\n                                },\n\n                                true\n                            );\n                        });\n\n                        return;\n                    }\n\n                    // if is local item we need to enable upload button so change can be propagated to server\n                    if (item.origin === FileOrigin.LOCAL) {\n                        dispatch('DID_LOAD_ITEM', {\n                            id: item.id,\n                            error: null,\n                            serverFileReference: item.source,\n                        });\n                    }\n\n                    // for async scenarios\n                    var upload = function upload() {\n                        // we push this forward a bit so the interface is updated correctly\n                        setTimeout(function() {\n                            dispatch('REQUEST_ITEM_PROCESSING', { query: id });\n                        }, 32);\n                    };\n\n                    var revert = function revert(doUpload) {\n                        item.revert(\n                            createRevertFunction(\n                                state.options.server.url,\n                                state.options.server.revert\n                            ),\n                            query('GET_FORCE_REVERT')\n                        )\n                            .then(doUpload ? upload : function() {})\n                            .catch(function() {});\n                    };\n\n                    var abort = function abort(doUpload) {\n                        item.abortProcessing().then(doUpload ? upload : function() {});\n                    };\n\n                    // if we should re-upload the file immediately\n                    if (item.status === ItemStatus.PROCESSING_COMPLETE) {\n                        return revert(state.options.instantUpload);\n                    }\n\n                    // if currently uploading, cancel upload\n                    if (item.status === ItemStatus.PROCESSING) {\n                        return abort(state.options.instantUpload);\n                    }\n\n                    if (state.options.instantUpload) {\n                        upload();\n                    }\n                }, 0);\n            },\n\n            MOVE_ITEM: function MOVE_ITEM(_ref4) {\n                var query = _ref4.query,\n                    index = _ref4.index;\n                var item = getItemByQuery(state.items, query);\n                if (!item) return;\n                var currentIndex = state.items.indexOf(item);\n                index = limit(index, 0, state.items.length - 1);\n                if (currentIndex === index) return;\n                state.items.splice(index, 0, state.items.splice(currentIndex, 1)[0]);\n            },\n\n            SORT: function SORT(_ref5) {\n                var compare = _ref5.compare;\n                sortItems(state, compare);\n                dispatch('DID_SORT_ITEMS', {\n                    items: query('GET_ACTIVE_ITEMS'),\n                });\n            },\n\n            ADD_ITEMS: function ADD_ITEMS(_ref6) {\n                var items = _ref6.items,\n                    index = _ref6.index,\n                    interactionMethod = _ref6.interactionMethod,\n                    _ref6$success = _ref6.success,\n                    success = _ref6$success === void 0 ? function() {} : _ref6$success,\n                    _ref6$failure = _ref6.failure,\n                    failure = _ref6$failure === void 0 ? function() {} : _ref6$failure;\n                var currentIndex = index;\n\n                if (index === -1 || typeof index === 'undefined') {\n                    var insertLocation = query('GET_ITEM_INSERT_LOCATION');\n                    var totalItems = query('GET_TOTAL_ITEMS');\n                    currentIndex = insertLocation === 'before' ? 0 : totalItems;\n                }\n\n                var ignoredFiles = query('GET_IGNORED_FILES');\n                var isValidFile = function isValidFile(source) {\n                    return isFile(source)\n                        ? !ignoredFiles.includes(source.name.toLowerCase())\n                        : !isEmpty(source);\n                };\n                var validItems = items.filter(isValidFile);\n\n                var promises = validItems.map(function(source) {\n                    return new Promise(function(resolve, reject) {\n                        dispatch('ADD_ITEM', {\n                            interactionMethod: interactionMethod,\n                            source: source.source || source,\n                            success: resolve,\n                            failure: reject,\n                            index: currentIndex++,\n                            options: source.options || {},\n                        });\n                    });\n                });\n\n                Promise.all(promises)\n                    .then(success)\n                    .catch(failure);\n            },\n\n            /**\n             * @param source\n             * @param index\n             * @param interactionMethod\n             */\n            ADD_ITEM: function ADD_ITEM(_ref7) {\n                var source = _ref7.source,\n                    _ref7$index = _ref7.index,\n                    index = _ref7$index === void 0 ? -1 : _ref7$index,\n                    interactionMethod = _ref7.interactionMethod,\n                    _ref7$success = _ref7.success,\n                    success = _ref7$success === void 0 ? function() {} : _ref7$success,\n                    _ref7$failure = _ref7.failure,\n                    failure = _ref7$failure === void 0 ? function() {} : _ref7$failure,\n                    _ref7$options = _ref7.options,\n                    options = _ref7$options === void 0 ? {} : _ref7$options;\n                // if no source supplied\n                if (isEmpty(source)) {\n                    failure({\n                        error: createResponse('error', 0, 'No source'),\n                        file: null,\n                    });\n\n                    return;\n                }\n\n                // filter out invalid file items, used to filter dropped directory contents\n                if (\n                    isFile(source) &&\n                    state.options.ignoredFiles.includes(source.name.toLowerCase())\n                ) {\n                    // fail silently\n                    return;\n                }\n\n                // test if there's still room in the list of files\n                if (!hasRoomForItem(state)) {\n                    // if multiple allowed, we can't replace\n                    // or if only a single item is allowed but we're not allowed to replace it we exit\n                    if (\n                        state.options.allowMultiple ||\n                        (!state.options.allowMultiple && !state.options.allowReplace)\n                    ) {\n                        var error = createResponse('warning', 0, 'Max files');\n\n                        dispatch('DID_THROW_MAX_FILES', {\n                            source: source,\n                            error: error,\n                        });\n\n                        failure({ error: error, file: null });\n\n                        return;\n                    }\n\n                    // let's replace the item\n                    // id of first item we're about to remove\n                    var _item = getActiveItems(state.items)[0];\n\n                    // if has been processed remove it from the server as well\n                    if (\n                        _item.status === ItemStatus.PROCESSING_COMPLETE ||\n                        _item.status === ItemStatus.PROCESSING_REVERT_ERROR\n                    ) {\n                        var forceRevert = query('GET_FORCE_REVERT');\n                        _item\n                            .revert(\n                                createRevertFunction(\n                                    state.options.server.url,\n                                    state.options.server.revert\n                                ),\n                                forceRevert\n                            )\n                            .then(function() {\n                                if (!forceRevert) return;\n\n                                // try to add now\n                                dispatch('ADD_ITEM', {\n                                    source: source,\n                                    index: index,\n                                    interactionMethod: interactionMethod,\n                                    success: success,\n                                    failure: failure,\n                                    options: options,\n                                });\n                            })\n                            .catch(function() {}); // no need to handle this catch state for now\n\n                        if (forceRevert) return;\n                    }\n\n                    // remove first item as it will be replaced by this item\n                    dispatch('REMOVE_ITEM', { query: _item.id });\n                }\n\n                // where did the file originate\n                var origin =\n                    options.type === 'local'\n                        ? FileOrigin.LOCAL\n                        : options.type === 'limbo'\n                        ? FileOrigin.LIMBO\n                        : FileOrigin.INPUT;\n\n                // create a new blank item\n                var item = createItem(\n                    // where did this file come from\n                    origin,\n\n                    // an input file never has a server file reference\n                    origin === FileOrigin.INPUT ? null : source,\n\n                    // file mock data, if defined\n                    options.file\n                );\n\n                // set initial meta data\n                Object.keys(options.metadata || {}).forEach(function(key) {\n                    item.setMetadata(key, options.metadata[key]);\n                });\n\n                // created the item, let plugins add methods\n                applyFilters('DID_CREATE_ITEM', item, { query: query, dispatch: dispatch });\n\n                // where to insert new items\n                var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n\n                // adjust index if is not allowed to pick location\n                if (!state.options.itemInsertLocationFreedom) {\n                    index = itemInsertLocation === 'before' ? -1 : state.items.length;\n                }\n\n                // add item to list\n                insertItem(state.items, item, index);\n\n                // sort items in list\n                if (isFunction(itemInsertLocation) && source) {\n                    sortItems(state, itemInsertLocation);\n                }\n\n                // get a quick reference to the item id\n                var id = item.id;\n\n                // observe item events\n                item.on('init', function() {\n                    dispatch('DID_INIT_ITEM', { id: id });\n                });\n\n                item.on('load-init', function() {\n                    dispatch('DID_START_ITEM_LOAD', { id: id });\n                });\n\n                item.on('load-meta', function() {\n                    dispatch('DID_UPDATE_ITEM_META', { id: id });\n                });\n\n                item.on('load-progress', function(progress) {\n                    dispatch('DID_UPDATE_ITEM_LOAD_PROGRESS', { id: id, progress: progress });\n                });\n\n                item.on('load-request-error', function(error) {\n                    var mainStatus = dynamicLabel(state.options.labelFileLoadError)(error);\n\n                    // is client error, no way to recover\n                    if (error.code >= 400 && error.code < 500) {\n                        dispatch('DID_THROW_ITEM_INVALID', {\n                            id: id,\n                            error: error,\n                            status: {\n                                main: mainStatus,\n                                sub: error.code + ' (' + error.body + ')',\n                            },\n                        });\n\n                        // reject the file so can be dealt with through API\n                        failure({ error: error, file: createItemAPI(item) });\n                        return;\n                    }\n\n                    // is possible server error, so might be possible to retry\n                    dispatch('DID_THROW_ITEM_LOAD_ERROR', {\n                        id: id,\n                        error: error,\n                        status: {\n                            main: mainStatus,\n                            sub: state.options.labelTapToRetry,\n                        },\n                    });\n                });\n\n                item.on('load-file-error', function(error) {\n                    dispatch('DID_THROW_ITEM_INVALID', {\n                        id: id,\n                        error: error.status,\n                        status: error.status,\n                    });\n\n                    failure({ error: error.status, file: createItemAPI(item) });\n                });\n\n                item.on('load-abort', function() {\n                    dispatch('REMOVE_ITEM', { query: id });\n                });\n\n                item.on('load-skip', function() {\n                    item.on('metadata-update', function(change) {\n                        if (!isFile(item.file)) return;\n                        dispatch('DID_UPDATE_ITEM_METADATA', { id: id, change: change });\n                    });\n\n                    dispatch('COMPLETE_LOAD_ITEM', {\n                        query: id,\n                        item: item,\n                        data: {\n                            source: source,\n                            success: success,\n                        },\n                    });\n                });\n\n                item.on('load', function() {\n                    var handleAdd = function handleAdd(shouldAdd) {\n                        // no should not add this file\n                        if (!shouldAdd) {\n                            dispatch('REMOVE_ITEM', {\n                                query: id,\n                            });\n\n                            return;\n                        }\n\n                        // now interested in metadata updates\n                        item.on('metadata-update', function(change) {\n                            dispatch('DID_UPDATE_ITEM_METADATA', { id: id, change: change });\n                        });\n\n                        // let plugins decide if the output data should be prepared at this point\n                        // means we'll do this and wait for idle state\n                        applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n                            item: item,\n                            query: query,\n                        }).then(function(shouldPrepareOutput) {\n                            // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n                            var beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');\n                            if (beforePrepareFile)\n                                shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);\n\n                            var loadComplete = function loadComplete() {\n                                dispatch('COMPLETE_LOAD_ITEM', {\n                                    query: id,\n                                    item: item,\n                                    data: {\n                                        source: source,\n                                        success: success,\n                                    },\n                                });\n\n                                listUpdated(dispatch, state);\n                            };\n\n                            // exit\n                            if (shouldPrepareOutput) {\n                                // wait for idle state and then run PREPARE_OUTPUT\n                                dispatch(\n                                    'REQUEST_PREPARE_OUTPUT',\n                                    {\n                                        query: id,\n                                        item: item,\n                                        success: function success(file) {\n                                            dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                                            loadComplete();\n                                        },\n                                    },\n\n                                    true\n                                );\n\n                                return;\n                            }\n\n                            loadComplete();\n                        });\n                    };\n\n                    // item loaded, allow plugins to\n                    // - read data (quickly)\n                    // - add metadata\n                    applyFilterChain('DID_LOAD_ITEM', item, { query: query, dispatch: dispatch })\n                        .then(function() {\n                            optionalPromise(query('GET_BEFORE_ADD_FILE'), createItemAPI(item)).then(\n                                handleAdd\n                            );\n                        })\n                        .catch(function(e) {\n                            if (!e || !e.error || !e.status) return handleAdd(false);\n                            dispatch('DID_THROW_ITEM_INVALID', {\n                                id: id,\n                                error: e.error,\n                                status: e.status,\n                            });\n                        });\n                });\n\n                item.on('process-start', function() {\n                    dispatch('DID_START_ITEM_PROCESSING', { id: id });\n                });\n\n                item.on('process-progress', function(progress) {\n                    dispatch('DID_UPDATE_ITEM_PROCESS_PROGRESS', { id: id, progress: progress });\n                });\n\n                item.on('process-error', function(error) {\n                    dispatch('DID_THROW_ITEM_PROCESSING_ERROR', {\n                        id: id,\n                        error: error,\n                        status: {\n                            main: dynamicLabel(state.options.labelFileProcessingError)(error),\n                            sub: state.options.labelTapToRetry,\n                        },\n                    });\n                });\n\n                item.on('process-revert-error', function(error) {\n                    dispatch('DID_THROW_ITEM_PROCESSING_REVERT_ERROR', {\n                        id: id,\n                        error: error,\n                        status: {\n                            main: dynamicLabel(state.options.labelFileProcessingRevertError)(error),\n                            sub: state.options.labelTapToRetry,\n                        },\n                    });\n                });\n\n                item.on('process-complete', function(serverFileReference) {\n                    dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n                        id: id,\n                        error: null,\n                        serverFileReference: serverFileReference,\n                    });\n\n                    dispatch('DID_DEFINE_VALUE', { id: id, value: serverFileReference });\n                });\n\n                item.on('process-abort', function() {\n                    dispatch('DID_ABORT_ITEM_PROCESSING', { id: id });\n                });\n\n                item.on('process-revert', function() {\n                    dispatch('DID_REVERT_ITEM_PROCESSING', { id: id });\n                    dispatch('DID_DEFINE_VALUE', { id: id, value: null });\n                });\n\n                // let view know the item has been inserted\n                dispatch('DID_ADD_ITEM', {\n                    id: id,\n                    index: index,\n                    interactionMethod: interactionMethod,\n                });\n\n                listUpdated(dispatch, state);\n\n                // start loading the source\n                var _ref8 = state.options.server || {},\n                    url = _ref8.url,\n                    load = _ref8.load,\n                    restore = _ref8.restore,\n                    fetch = _ref8.fetch;\n\n                item.load(\n                    source,\n\n                    // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)\n                    createFileLoader(\n                        origin === FileOrigin.INPUT\n                            ? // input, if is remote, see if should use custom fetch, else use default fetchBlob\n                              isString(source) && isExternalURL(source)\n                                ? fetch\n                                    ? createFetchFunction(url, fetch)\n                                    : fetchBlob // remote url\n                                : fetchBlob // try to fetch url\n                            : // limbo or local\n                            origin === FileOrigin.LIMBO\n                            ? createFetchFunction(url, restore) // limbo\n                            : createFetchFunction(url, load) // local\n                    ),\n\n                    // called when the file is loaded so it can be piped through the filters\n                    function(file, success, error) {\n                        // let's process the file\n                        applyFilterChain('LOAD_FILE', file, { query: query })\n                            .then(success)\n                            .catch(error);\n                    }\n                );\n            },\n\n            REQUEST_PREPARE_OUTPUT: function REQUEST_PREPARE_OUTPUT(_ref9) {\n                var item = _ref9.item,\n                    success = _ref9.success,\n                    _ref9$failure = _ref9.failure,\n                    failure = _ref9$failure === void 0 ? function() {} : _ref9$failure;\n                // error response if item archived\n                var err = {\n                    error: createResponse('error', 0, 'Item not found'),\n                    file: null,\n                };\n\n                // don't handle archived items, an item could have been archived (load aborted) while waiting to be prepared\n                if (item.archived) return failure(err);\n\n                // allow plugins to alter the file data\n                applyFilterChain('PREPARE_OUTPUT', item.file, { query: query, item: item }).then(\n                    function(result) {\n                        applyFilterChain('COMPLETE_PREPARE_OUTPUT', result, {\n                            query: query,\n                            item: item,\n                        }).then(function(result) {\n                            // don't handle archived items, an item could have been archived (load aborted) while being prepared\n                            if (item.archived) return failure(err);\n\n                            // we done!\n                            success(result);\n                        });\n                    }\n                );\n            },\n\n            COMPLETE_LOAD_ITEM: function COMPLETE_LOAD_ITEM(_ref10) {\n                var item = _ref10.item,\n                    data = _ref10.data;\n                var success = data.success,\n                    source = data.source;\n\n                // sort items in list\n                var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n                if (isFunction(itemInsertLocation) && source) {\n                    sortItems(state, itemInsertLocation);\n                }\n\n                // let interface know the item has loaded\n                dispatch('DID_LOAD_ITEM', {\n                    id: item.id,\n                    error: null,\n                    serverFileReference: item.origin === FileOrigin.INPUT ? null : source,\n                });\n\n                // item has been successfully loaded and added to the\n                // list of items so can now be safely returned for use\n                success(createItemAPI(item));\n\n                // if this is a local server file we need to show a different state\n                if (item.origin === FileOrigin.LOCAL) {\n                    dispatch('DID_LOAD_LOCAL_ITEM', { id: item.id });\n                    return;\n                }\n\n                // if is a temp server file we prevent async upload call here (as the file is already on the server)\n                if (item.origin === FileOrigin.LIMBO) {\n                    dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n                        id: item.id,\n                        error: null,\n                        serverFileReference: source,\n                    });\n\n                    dispatch('DID_DEFINE_VALUE', {\n                        id: item.id,\n                        value: item.serverId || source,\n                    });\n\n                    return;\n                }\n\n                // id we are allowed to upload the file immediately, lets do it\n                if (query('IS_ASYNC') && state.options.instantUpload) {\n                    dispatch('REQUEST_ITEM_PROCESSING', { query: item.id });\n                }\n            },\n\n            RETRY_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n                // try loading the source one more time\n                item.retryLoad();\n            }),\n\n            REQUEST_ITEM_PREPARE: getItemByQueryFromState(state, function(item, _success, failure) {\n                dispatch(\n                    'REQUEST_PREPARE_OUTPUT',\n                    {\n                        query: item.id,\n                        item: item,\n                        success: function success(file) {\n                            dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n                            _success({\n                                file: item,\n                                output: file,\n                            });\n                        },\n                        failure: failure,\n                    },\n\n                    true\n                );\n            }),\n\n            REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state, function(\n                item,\n                success,\n                failure\n            ) {\n                // cannot be queued (or is already queued)\n                var itemCanBeQueuedForProcessing =\n                    // waiting for something\n                    item.status === ItemStatus.IDLE ||\n                    // processing went wrong earlier\n                    item.status === ItemStatus.PROCESSING_ERROR;\n\n                // not ready to be processed\n                if (!itemCanBeQueuedForProcessing) {\n                    var processNow = function processNow() {\n                        return dispatch('REQUEST_ITEM_PROCESSING', {\n                            query: item,\n                            success: success,\n                            failure: failure,\n                        });\n                    };\n\n                    var process = function process() {\n                        return document.hidden ? processNow() : setTimeout(processNow, 32);\n                    };\n\n                    // if already done processing or tried to revert but didn't work, try again\n                    if (\n                        item.status === ItemStatus.PROCESSING_COMPLETE ||\n                        item.status === ItemStatus.PROCESSING_REVERT_ERROR\n                    ) {\n                        item.revert(\n                            createRevertFunction(\n                                state.options.server.url,\n                                state.options.server.revert\n                            ),\n                            query('GET_FORCE_REVERT')\n                        )\n                            .then(process)\n                            .catch(function() {}); // don't continue with processing if something went wrong\n                    } else if (item.status === ItemStatus.PROCESSING) {\n                        item.abortProcessing().then(process);\n                    }\n\n                    return;\n                }\n\n                // already queued for processing\n                if (item.status === ItemStatus.PROCESSING_QUEUED) return;\n\n                item.requestProcessing();\n\n                dispatch('DID_REQUEST_ITEM_PROCESSING', { id: item.id });\n\n                dispatch('PROCESS_ITEM', { query: item, success: success, failure: failure }, true);\n            }),\n\n            PROCESS_ITEM: getItemByQueryFromState(state, function(item, success, failure) {\n                var maxParallelUploads = query('GET_MAX_PARALLEL_UPLOADS');\n                var totalCurrentUploads = query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING)\n                    .length;\n\n                // queue and wait till queue is freed up\n                if (totalCurrentUploads === maxParallelUploads) {\n                    // queue for later processing\n                    state.processingQueue.push({\n                        id: item.id,\n                        success: success,\n                        failure: failure,\n                    });\n\n                    // stop it!\n                    return;\n                }\n\n                // if was not queued or is already processing exit here\n                if (item.status === ItemStatus.PROCESSING) return;\n\n                var processNext = function processNext() {\n                    // process queueud items\n                    var queueEntry = state.processingQueue.shift();\n\n                    // no items left\n                    if (!queueEntry) return;\n\n                    // get item reference\n                    var id = queueEntry.id,\n                        success = queueEntry.success,\n                        failure = queueEntry.failure;\n                    var itemReference = getItemByQuery(state.items, id);\n\n                    // if item was archived while in queue, jump to next\n                    if (!itemReference || itemReference.archived) {\n                        processNext();\n                        return;\n                    }\n\n                    // process queued item\n                    dispatch(\n                        'PROCESS_ITEM',\n                        { query: id, success: success, failure: failure },\n                        true\n                    );\n                };\n\n                // we done function\n                item.onOnce('process-complete', function() {\n                    success(createItemAPI(item));\n                    processNext();\n\n                    // if origin is local, and we're instant uploading, trigger remove of original\n                    // as revert will remove file from list\n                    var server = state.options.server;\n                    var instantUpload = state.options.instantUpload;\n                    if (\n                        instantUpload &&\n                        item.origin === FileOrigin.LOCAL &&\n                        isFunction(server.remove)\n                    ) {\n                        var noop = function noop() {};\n                        item.origin = FileOrigin.LIMBO;\n                        state.options.server.remove(item.source, noop, noop);\n                    }\n\n                    // All items processed? No errors?\n                    var allItemsProcessed =\n                        query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING_COMPLETE).length ===\n                        state.items.length;\n                    if (allItemsProcessed) {\n                        dispatch('DID_COMPLETE_ITEM_PROCESSING_ALL');\n                    }\n                });\n\n                // we error function\n                item.onOnce('process-error', function(error) {\n                    failure({ error: error, file: createItemAPI(item) });\n                    processNext();\n                });\n\n                // start file processing\n                var options = state.options;\n                item.process(\n                    createFileProcessor(\n                        createProcessorFunction(\n                            options.server.url,\n                            options.server.process,\n                            options.name,\n                            {\n                                chunkTransferId: item.transferId,\n                                chunkServer: options.server.patch,\n                                chunkUploads: options.chunkUploads,\n                                chunkForce: options.chunkForce,\n                                chunkSize: options.chunkSize,\n                                chunkRetryDelays: options.chunkRetryDelays,\n                            }\n                        ),\n\n                        {\n                            allowMinimumUploadDuration: query('GET_ALLOW_MINIMUM_UPLOAD_DURATION'),\n                        }\n                    ),\n\n                    // called when the file is about to be processed so it can be piped through the transform filters\n                    function(file, success, error) {\n                        // allow plugins to alter the file data\n                        applyFilterChain('PREPARE_OUTPUT', file, { query: query, item: item })\n                            .then(function(file) {\n                                dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n\n                                success(file);\n                            })\n                            .catch(error);\n                    }\n                );\n            }),\n\n            RETRY_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n                dispatch('REQUEST_ITEM_PROCESSING', { query: item });\n            }),\n\n            REQUEST_REMOVE_ITEM: getItemByQueryFromState(state, function(item) {\n                optionalPromise(query('GET_BEFORE_REMOVE_FILE'), createItemAPI(item)).then(function(\n                    shouldRemove\n                ) {\n                    if (!shouldRemove) {\n                        return;\n                    }\n                    dispatch('REMOVE_ITEM', { query: item });\n                });\n            }),\n\n            RELEASE_ITEM: getItemByQueryFromState(state, function(item) {\n                item.release();\n            }),\n\n            REMOVE_ITEM: getItemByQueryFromState(state, function(item, success, failure, options) {\n                var removeFromView = function removeFromView() {\n                    // get id reference\n                    var id = item.id;\n\n                    // archive the item, this does not remove it from the list\n                    getItemById(state.items, id).archive();\n\n                    // tell the view the item has been removed\n                    dispatch('DID_REMOVE_ITEM', { error: null, id: id, item: item });\n\n                    // now the list has been modified\n                    listUpdated(dispatch, state);\n\n                    // correctly removed\n                    success(createItemAPI(item));\n                };\n\n                // if this is a local file and the `server.remove` function has been configured,\n                // send source there so dev can remove file from server\n                var server = state.options.server;\n                if (\n                    item.origin === FileOrigin.LOCAL &&\n                    server &&\n                    isFunction(server.remove) &&\n                    options.remove !== false\n                ) {\n                    dispatch('DID_START_ITEM_REMOVE', { id: item.id });\n\n                    server.remove(\n                        item.source,\n                        function() {\n                            return removeFromView();\n                        },\n                        function(status) {\n                            dispatch('DID_THROW_ITEM_REMOVE_ERROR', {\n                                id: item.id,\n                                error: createResponse('error', 0, status, null),\n                                status: {\n                                    main: dynamicLabel(state.options.labelFileRemoveError)(status),\n                                    sub: state.options.labelTapToRetry,\n                                },\n                            });\n                        }\n                    );\n                } else {\n                    // if is requesting revert and can revert need to call revert handler (not calling request_ because that would also trigger beforeRemoveHook)\n                    if (\n                        (options.revert &&\n                            item.origin !== FileOrigin.LOCAL &&\n                            item.serverId !== null) ||\n                        // if chunked uploads are enabled and we're uploading in chunks for this specific file\n                        // or if the file isn't big enough for chunked uploads but chunkForce is set then call\n                        // revert before removing from the view...\n                        (state.options.chunkUploads && item.file.size > state.options.chunkSize) ||\n                        (state.options.chunkUploads && state.options.chunkForce)\n                    ) {\n                        item.revert(\n                            createRevertFunction(\n                                state.options.server.url,\n                                state.options.server.revert\n                            ),\n                            query('GET_FORCE_REVERT')\n                        );\n                    }\n\n                    // can now safely remove from view\n                    removeFromView();\n                }\n            }),\n\n            ABORT_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n                item.abortLoad();\n            }),\n\n            ABORT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n                // test if is already processed\n                if (item.serverId) {\n                    dispatch('REVERT_ITEM_PROCESSING', { id: item.id });\n                    return;\n                }\n\n                // abort\n                item.abortProcessing().then(function() {\n                    var shouldRemove = state.options.instantUpload;\n                    if (shouldRemove) {\n                        dispatch('REMOVE_ITEM', { query: item.id });\n                    }\n                });\n            }),\n\n            REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n                // not instant uploading, revert immediately\n                if (!state.options.instantUpload) {\n                    dispatch('REVERT_ITEM_PROCESSING', { query: item });\n                    return;\n                }\n\n                // if we're instant uploading the file will also be removed if we revert,\n                // so if a before remove file hook is defined we need to run it now\n                var handleRevert = function handleRevert(shouldRevert) {\n                    if (!shouldRevert) return;\n                    dispatch('REVERT_ITEM_PROCESSING', { query: item });\n                };\n\n                var fn = query('GET_BEFORE_REMOVE_FILE');\n                if (!fn) {\n                    return handleRevert(true);\n                }\n\n                var requestRemoveResult = fn(createItemAPI(item));\n                if (requestRemoveResult == null) {\n                    // undefined or null\n                    return handleRevert(true);\n                }\n\n                if (typeof requestRemoveResult === 'boolean') {\n                    return handleRevert(requestRemoveResult);\n                }\n\n                if (typeof requestRemoveResult.then === 'function') {\n                    requestRemoveResult.then(handleRevert);\n                }\n            }),\n\n            REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n                item.revert(\n                    createRevertFunction(state.options.server.url, state.options.server.revert),\n                    query('GET_FORCE_REVERT')\n                )\n                    .then(function() {\n                        var shouldRemove = state.options.instantUpload || isMockItem(item);\n                        if (shouldRemove) {\n                            dispatch('REMOVE_ITEM', { query: item.id });\n                        }\n                    })\n                    .catch(function() {});\n            }),\n\n            SET_OPTIONS: function SET_OPTIONS(_ref11) {\n                var options = _ref11.options;\n                // get all keys passed\n                var optionKeys = Object.keys(options);\n\n                // get prioritized keyed to include (remove once not in options object)\n                var prioritizedOptionKeys = PrioritizedOptions.filter(function(key) {\n                    return optionKeys.includes(key);\n                });\n\n                // order the keys, prioritized first, then rest\n                var orderedOptionKeys = [].concat(\n                    _toConsumableArray(prioritizedOptionKeys),\n                    _toConsumableArray(\n                        Object.keys(options).filter(function(key) {\n                            return !prioritizedOptionKeys.includes(key);\n                        })\n                    )\n                );\n\n                // dispatch set event for each option\n                orderedOptionKeys.forEach(function(key) {\n                    dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n                        value: options[key],\n                    });\n                });\n            },\n        };\n    };\n\n    var PrioritizedOptions = ['server'];\n\n    var formatFilename = function formatFilename(name) {\n        return name;\n    };\n\n    var createElement$1 = function createElement(tagName) {\n        return document.createElement(tagName);\n    };\n\n    var text = function text(node, value) {\n        var textNode = node.childNodes[0];\n        if (!textNode) {\n            textNode = document.createTextNode(value);\n            node.appendChild(textNode);\n        } else if (value !== textNode.nodeValue) {\n            textNode.nodeValue = value;\n        }\n    };\n\n    var polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n        var angleInRadians = (((angleInDegrees % 360) - 90) * Math.PI) / 180.0;\n        return {\n            x: centerX + radius * Math.cos(angleInRadians),\n            y: centerY + radius * Math.sin(angleInRadians),\n        };\n    };\n\n    var describeArc = function describeArc(x, y, radius, startAngle, endAngle, arcSweep) {\n        var start = polarToCartesian(x, y, radius, endAngle);\n        var end = polarToCartesian(x, y, radius, startAngle);\n        return ['M', start.x, start.y, 'A', radius, radius, 0, arcSweep, 0, end.x, end.y].join(' ');\n    };\n\n    var percentageArc = function percentageArc(x, y, radius, from, to) {\n        var arcSweep = 1;\n        if (to > from && to - from <= 0.5) {\n            arcSweep = 0;\n        }\n        if (from > to && from - to >= 0.5) {\n            arcSweep = 0;\n        }\n        return describeArc(\n            x,\n            y,\n            radius,\n            Math.min(0.9999, from) * 360,\n            Math.min(0.9999, to) * 360,\n            arcSweep\n        );\n    };\n\n    var create = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        // start at 0\n        props.spin = false;\n        props.progress = 0;\n        props.opacity = 0;\n\n        // svg\n        var svg = createElement('svg');\n        root.ref.path = createElement('path', {\n            'stroke-width': 2,\n            'stroke-linecap': 'round',\n        });\n\n        svg.appendChild(root.ref.path);\n\n        root.ref.svg = svg;\n\n        root.appendChild(svg);\n    };\n\n    var write = function write(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        if (props.opacity === 0) {\n            return;\n        }\n\n        if (props.align) {\n            root.element.dataset.align = props.align;\n        }\n\n        // get width of stroke\n        var ringStrokeWidth = parseInt(attr(root.ref.path, 'stroke-width'), 10);\n\n        // calculate size of ring\n        var size = root.rect.element.width * 0.5;\n\n        // ring state\n        var ringFrom = 0;\n        var ringTo = 0;\n\n        // now in busy mode\n        if (props.spin) {\n            ringFrom = 0;\n            ringTo = 0.5;\n        } else {\n            ringFrom = 0;\n            ringTo = props.progress;\n        }\n\n        // get arc path\n        var coordinates = percentageArc(size, size, size - ringStrokeWidth, ringFrom, ringTo);\n\n        // update progress bar\n        attr(root.ref.path, 'd', coordinates);\n\n        // hide while contains 0 value\n        attr(root.ref.path, 'stroke-opacity', props.spin || props.progress > 0 ? 1 : 0);\n    };\n\n    var progressIndicator = createView({\n        tag: 'div',\n        name: 'progress-indicator',\n        ignoreRectUpdate: true,\n        ignoreRect: true,\n        create: create,\n        write: write,\n        mixins: {\n            apis: ['progress', 'spin', 'align'],\n            styles: ['opacity'],\n            animations: {\n                opacity: { type: 'tween', duration: 500 },\n                progress: {\n                    type: 'spring',\n                    stiffness: 0.95,\n                    damping: 0.65,\n                    mass: 10,\n                },\n            },\n        },\n    });\n\n    var create$1 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        root.element.innerHTML = (props.icon || '') + ('<span>' + props.label + '</span>');\n\n        props.isDisabled = false;\n    };\n\n    var write$1 = function write(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        var isDisabled = props.isDisabled;\n        var shouldDisable = root.query('GET_DISABLED') || props.opacity === 0;\n\n        if (shouldDisable && !isDisabled) {\n            props.isDisabled = true;\n            attr(root.element, 'disabled', 'disabled');\n        } else if (!shouldDisable && isDisabled) {\n            props.isDisabled = false;\n            root.element.removeAttribute('disabled');\n        }\n    };\n\n    var fileActionButton = createView({\n        tag: 'button',\n        attributes: {\n            type: 'button',\n        },\n\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        name: 'file-action-button',\n        mixins: {\n            apis: ['label'],\n            styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n            animations: {\n                scaleX: 'spring',\n                scaleY: 'spring',\n                translateX: 'spring',\n                translateY: 'spring',\n                opacity: { type: 'tween', duration: 250 },\n            },\n\n            listeners: true,\n        },\n\n        create: create$1,\n        write: write$1,\n    });\n\n    var toNaturalFileSize = function toNaturalFileSize(bytes) {\n        var decimalSeparator =\n            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';\n        var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        var _options$labelBytes = options.labelBytes,\n            labelBytes = _options$labelBytes === void 0 ? 'bytes' : _options$labelBytes,\n            _options$labelKilobyt = options.labelKilobytes,\n            labelKilobytes = _options$labelKilobyt === void 0 ? 'KB' : _options$labelKilobyt,\n            _options$labelMegabyt = options.labelMegabytes,\n            labelMegabytes = _options$labelMegabyt === void 0 ? 'MB' : _options$labelMegabyt,\n            _options$labelGigabyt = options.labelGigabytes,\n            labelGigabytes = _options$labelGigabyt === void 0 ? 'GB' : _options$labelGigabyt;\n\n        // no negative byte sizes\n        bytes = Math.round(Math.abs(bytes));\n\n        var KB = base;\n        var MB = base * base;\n        var GB = base * base * base;\n\n        // just bytes\n        if (bytes < KB) {\n            return bytes + ' ' + labelBytes;\n        }\n\n        // kilobytes\n        if (bytes < MB) {\n            return Math.floor(bytes / KB) + ' ' + labelKilobytes;\n        }\n\n        // megabytes\n        if (bytes < GB) {\n            return removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator) + ' ' + labelMegabytes;\n        }\n\n        // gigabytes\n        return removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator) + ' ' + labelGigabytes;\n    };\n\n    var removeDecimalsWhenZero = function removeDecimalsWhenZero(value, decimalCount, separator) {\n        return value\n            .toFixed(decimalCount)\n            .split('.')\n            .filter(function(part) {\n                return part !== '0';\n            })\n            .join(separator);\n    };\n\n    var create$2 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        // filename\n        var fileName = createElement$1('span');\n        fileName.className = 'filepond--file-info-main';\n        // hide for screenreaders\n        // the file is contained in a fieldset with legend that contains the filename\n        // no need to read it twice\n        attr(fileName, 'aria-hidden', 'true');\n        root.appendChild(fileName);\n        root.ref.fileName = fileName;\n\n        // filesize\n        var fileSize = createElement$1('span');\n        fileSize.className = 'filepond--file-info-sub';\n        root.appendChild(fileSize);\n        root.ref.fileSize = fileSize;\n\n        // set initial values\n        text(fileSize, root.query('GET_LABEL_FILE_WAITING_FOR_SIZE'));\n        text(fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n    };\n\n    var updateFile = function updateFile(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        text(\n            root.ref.fileSize,\n            toNaturalFileSize(\n                root.query('GET_ITEM_SIZE', props.id),\n                '.',\n                root.query('GET_FILE_SIZE_BASE'),\n                root.query('GET_FILE_SIZE_LABELS', root.query)\n            )\n        );\n\n        text(root.ref.fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n    };\n\n    var updateFileSizeOnError = function updateFileSizeOnError(_ref3) {\n        var root = _ref3.root,\n            props = _ref3.props;\n        // if size is available don't fallback to unknown size message\n        if (isInt(root.query('GET_ITEM_SIZE', props.id))) {\n            updateFile({ root: root, props: props });\n            return;\n        }\n\n        text(root.ref.fileSize, root.query('GET_LABEL_FILE_SIZE_NOT_AVAILABLE'));\n    };\n\n    var fileInfo = createView({\n        name: 'file-info',\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        write: createRoute({\n            DID_LOAD_ITEM: updateFile,\n            DID_UPDATE_ITEM_META: updateFile,\n            DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,\n            DID_THROW_ITEM_INVALID: updateFileSizeOnError,\n        }),\n\n        didCreateView: function didCreateView(root) {\n            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n        },\n        create: create$2,\n        mixins: {\n            styles: ['translateX', 'translateY'],\n            animations: {\n                translateX: 'spring',\n                translateY: 'spring',\n            },\n        },\n    });\n\n    var toPercentage = function toPercentage(value) {\n        return Math.round(value * 100);\n    };\n\n    var create$3 = function create(_ref) {\n        var root = _ref.root;\n\n        // main status\n        var main = createElement$1('span');\n        main.className = 'filepond--file-status-main';\n        root.appendChild(main);\n        root.ref.main = main;\n\n        // sub status\n        var sub = createElement$1('span');\n        sub.className = 'filepond--file-status-sub';\n        root.appendChild(sub);\n        root.ref.sub = sub;\n\n        didSetItemLoadProgress({ root: root, action: { progress: null } });\n    };\n\n    var didSetItemLoadProgress = function didSetItemLoadProgress(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        var title =\n            action.progress === null\n                ? root.query('GET_LABEL_FILE_LOADING')\n                : root.query('GET_LABEL_FILE_LOADING') + ' ' + toPercentage(action.progress) + '%';\n\n        text(root.ref.main, title);\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n    };\n\n    var didSetItemProcessProgress = function didSetItemProcessProgress(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        var title =\n            action.progress === null\n                ? root.query('GET_LABEL_FILE_PROCESSING')\n                : root.query('GET_LABEL_FILE_PROCESSING') +\n                  ' ' +\n                  toPercentage(action.progress) +\n                  '%';\n\n        text(root.ref.main, title);\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n    };\n\n    var didRequestItemProcessing = function didRequestItemProcessing(_ref4) {\n        var root = _ref4.root;\n        text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING'));\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n    };\n\n    var didAbortItemProcessing = function didAbortItemProcessing(_ref5) {\n        var root = _ref5.root;\n        text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_ABORTED'));\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_RETRY'));\n    };\n\n    var didCompleteItemProcessing = function didCompleteItemProcessing(_ref6) {\n        var root = _ref6.root;\n        text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_COMPLETE'));\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_UNDO'));\n    };\n\n    var clear = function clear(_ref7) {\n        var root = _ref7.root;\n        text(root.ref.main, '');\n        text(root.ref.sub, '');\n    };\n\n    var error = function error(_ref8) {\n        var root = _ref8.root,\n            action = _ref8.action;\n        text(root.ref.main, action.status.main);\n        text(root.ref.sub, action.status.sub);\n    };\n\n    var fileStatus = createView({\n        name: 'file-status',\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        write: createRoute({\n            DID_LOAD_ITEM: clear,\n            DID_REVERT_ITEM_PROCESSING: clear,\n            DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,\n            DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,\n            DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,\n            DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,\n            DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,\n            DID_THROW_ITEM_LOAD_ERROR: error,\n            DID_THROW_ITEM_INVALID: error,\n            DID_THROW_ITEM_PROCESSING_ERROR: error,\n            DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,\n            DID_THROW_ITEM_REMOVE_ERROR: error,\n        }),\n\n        didCreateView: function didCreateView(root) {\n            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n        },\n        create: create$3,\n        mixins: {\n            styles: ['translateX', 'translateY', 'opacity'],\n            animations: {\n                opacity: { type: 'tween', duration: 250 },\n                translateX: 'spring',\n                translateY: 'spring',\n            },\n        },\n    });\n\n    /**\n     * Button definitions for the file view\n     */\n\n    var Buttons = {\n        AbortItemLoad: {\n            label: 'GET_LABEL_BUTTON_ABORT_ITEM_LOAD',\n            action: 'ABORT_ITEM_LOAD',\n            className: 'filepond--action-abort-item-load',\n            align: 'LOAD_INDICATOR_POSITION', // right\n        },\n        RetryItemLoad: {\n            label: 'GET_LABEL_BUTTON_RETRY_ITEM_LOAD',\n            action: 'RETRY_ITEM_LOAD',\n            icon: 'GET_ICON_RETRY',\n            className: 'filepond--action-retry-item-load',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n        RemoveItem: {\n            label: 'GET_LABEL_BUTTON_REMOVE_ITEM',\n            action: 'REQUEST_REMOVE_ITEM',\n            icon: 'GET_ICON_REMOVE',\n            className: 'filepond--action-remove-item',\n            align: 'BUTTON_REMOVE_ITEM_POSITION', // left\n        },\n        ProcessItem: {\n            label: 'GET_LABEL_BUTTON_PROCESS_ITEM',\n            action: 'REQUEST_ITEM_PROCESSING',\n            icon: 'GET_ICON_PROCESS',\n            className: 'filepond--action-process-item',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n        AbortItemProcessing: {\n            label: 'GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING',\n            action: 'ABORT_ITEM_PROCESSING',\n            className: 'filepond--action-abort-item-processing',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n        RetryItemProcessing: {\n            label: 'GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING',\n            action: 'RETRY_ITEM_PROCESSING',\n            icon: 'GET_ICON_RETRY',\n            className: 'filepond--action-retry-item-processing',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n        RevertItemProcessing: {\n            label: 'GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING',\n            action: 'REQUEST_REVERT_ITEM_PROCESSING',\n            icon: 'GET_ICON_UNDO',\n            className: 'filepond--action-revert-item-processing',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n    };\n\n    // make a list of buttons, we can then remove buttons from this list if they're disabled\n    var ButtonKeys = [];\n    forin(Buttons, function(key) {\n        ButtonKeys.push(key);\n    });\n\n    var calculateFileInfoOffset = function calculateFileInfoOffset(root) {\n        if (getRemoveIndicatorAligment(root) === 'right') return 0;\n        var buttonRect = root.ref.buttonRemoveItem.rect.element;\n        return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;\n    };\n\n    var calculateButtonWidth = function calculateButtonWidth(root) {\n        var buttonRect = root.ref.buttonAbortItemLoad.rect.element;\n        return buttonRect.width;\n    };\n\n    // Force on full pixels so text stays crips\n    var calculateFileVerticalCenterOffset = function calculateFileVerticalCenterOffset(root) {\n        return Math.floor(root.ref.buttonRemoveItem.rect.element.height / 4);\n    };\n    var calculateFileHorizontalCenterOffset = function calculateFileHorizontalCenterOffset(root) {\n        return Math.floor(root.ref.buttonRemoveItem.rect.element.left / 2);\n    };\n\n    var getLoadIndicatorAlignment = function getLoadIndicatorAlignment(root) {\n        return root.query('GET_STYLE_LOAD_INDICATOR_POSITION');\n    };\n    var getProcessIndicatorAlignment = function getProcessIndicatorAlignment(root) {\n        return root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION');\n    };\n    var getRemoveIndicatorAligment = function getRemoveIndicatorAligment(root) {\n        return root.query('GET_STYLE_BUTTON_REMOVE_ITEM_POSITION');\n    };\n\n    var DefaultStyle = {\n        buttonAbortItemLoad: { opacity: 0 },\n        buttonRetryItemLoad: { opacity: 0 },\n        buttonRemoveItem: { opacity: 0 },\n        buttonProcessItem: { opacity: 0 },\n        buttonAbortItemProcessing: { opacity: 0 },\n        buttonRetryItemProcessing: { opacity: 0 },\n        buttonRevertItemProcessing: { opacity: 0 },\n        loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },\n        processProgressIndicator: { opacity: 0, align: getProcessIndicatorAlignment },\n        processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },\n        info: { translateX: 0, translateY: 0, opacity: 0 },\n        status: { translateX: 0, translateY: 0, opacity: 0 },\n    };\n\n    var IdleStyle = {\n        buttonRemoveItem: { opacity: 1 },\n        buttonProcessItem: { opacity: 1 },\n        info: { translateX: calculateFileInfoOffset },\n        status: { translateX: calculateFileInfoOffset },\n    };\n\n    var ProcessingStyle = {\n        buttonAbortItemProcessing: { opacity: 1 },\n        processProgressIndicator: { opacity: 1 },\n        status: { opacity: 1 },\n    };\n\n    var StyleMap = {\n        DID_THROW_ITEM_INVALID: {\n            buttonRemoveItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { translateX: calculateFileInfoOffset, opacity: 1 },\n        },\n\n        DID_START_ITEM_LOAD: {\n            buttonAbortItemLoad: { opacity: 1 },\n            loadProgressIndicator: { opacity: 1 },\n            status: { opacity: 1 },\n        },\n\n        DID_THROW_ITEM_LOAD_ERROR: {\n            buttonRetryItemLoad: { opacity: 1 },\n            buttonRemoveItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { opacity: 1 },\n        },\n\n        DID_START_ITEM_REMOVE: {\n            processProgressIndicator: { opacity: 1, align: getRemoveIndicatorAligment },\n            info: { translateX: calculateFileInfoOffset },\n            status: { opacity: 0 },\n        },\n\n        DID_THROW_ITEM_REMOVE_ERROR: {\n            processProgressIndicator: { opacity: 0, align: getRemoveIndicatorAligment },\n            buttonRemoveItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { opacity: 1, translateX: calculateFileInfoOffset },\n        },\n\n        DID_LOAD_ITEM: IdleStyle,\n        DID_LOAD_LOCAL_ITEM: {\n            buttonRemoveItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { translateX: calculateFileInfoOffset },\n        },\n\n        DID_START_ITEM_PROCESSING: ProcessingStyle,\n        DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,\n        DID_COMPLETE_ITEM_PROCESSING: {\n            buttonRevertItemProcessing: { opacity: 1 },\n            info: { opacity: 1 },\n            status: { opacity: 1 },\n        },\n\n        DID_THROW_ITEM_PROCESSING_ERROR: {\n            buttonRemoveItem: { opacity: 1 },\n            buttonRetryItemProcessing: { opacity: 1 },\n            status: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n        },\n\n        DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {\n            buttonRevertItemProcessing: { opacity: 1 },\n            status: { opacity: 1 },\n            info: { opacity: 1 },\n        },\n\n        DID_ABORT_ITEM_PROCESSING: {\n            buttonRemoveItem: { opacity: 1 },\n            buttonProcessItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { opacity: 1 },\n        },\n\n        DID_REVERT_ITEM_PROCESSING: IdleStyle,\n    };\n\n    // complete indicator view\n    var processingCompleteIndicatorView = createView({\n        create: function create(_ref) {\n            var root = _ref.root;\n            root.element.innerHTML = root.query('GET_ICON_DONE');\n        },\n        name: 'processing-complete-indicator',\n        ignoreRect: true,\n        mixins: {\n            styles: ['scaleX', 'scaleY', 'opacity'],\n            animations: {\n                scaleX: 'spring',\n                scaleY: 'spring',\n                opacity: { type: 'tween', duration: 250 },\n            },\n        },\n    });\n\n    /**\n     * Creates the file view\n     */\n    var create$4 = function create(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        // copy Buttons object\n        var LocalButtons = Object.keys(Buttons).reduce(function(prev, curr) {\n            prev[curr] = Object.assign({}, Buttons[curr]);\n            return prev;\n        }, {});\n        var id = props.id;\n\n        // allow reverting upload\n        var allowRevert = root.query('GET_ALLOW_REVERT');\n\n        // allow remove file\n        var allowRemove = root.query('GET_ALLOW_REMOVE');\n\n        // allow processing upload\n        var allowProcess = root.query('GET_ALLOW_PROCESS');\n\n        // is instant uploading, need this to determine the icon of the undo button\n        var instantUpload = root.query('GET_INSTANT_UPLOAD');\n\n        // is async set up\n        var isAsync = root.query('IS_ASYNC');\n\n        // should align remove item buttons\n        var alignRemoveItemButton = root.query('GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN');\n\n        // enabled buttons array\n        var buttonFilter;\n        if (isAsync) {\n            if (allowProcess && !allowRevert) {\n                // only remove revert button\n                buttonFilter = function buttonFilter(key) {\n                    return !/RevertItemProcessing/.test(key);\n                };\n            } else if (!allowProcess && allowRevert) {\n                // only remove process button\n                buttonFilter = function buttonFilter(key) {\n                    return !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(key);\n                };\n            } else if (!allowProcess && !allowRevert) {\n                // remove all process buttons\n                buttonFilter = function buttonFilter(key) {\n                    return !/Process/.test(key);\n                };\n            }\n        } else {\n            // no process controls available\n            buttonFilter = function buttonFilter(key) {\n                return !/Process/.test(key);\n            };\n        }\n\n        var enabledButtons = buttonFilter ? ButtonKeys.filter(buttonFilter) : ButtonKeys.concat();\n\n        // update icon and label for revert button when instant uploading\n        if (instantUpload && allowRevert) {\n            LocalButtons['RevertItemProcessing'].label = 'GET_LABEL_BUTTON_REMOVE_ITEM';\n            LocalButtons['RevertItemProcessing'].icon = 'GET_ICON_REMOVE';\n        }\n\n        // remove last button (revert) if not allowed\n        if (isAsync && !allowRevert) {\n            var map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n            map.info.translateX = calculateFileHorizontalCenterOffset;\n            map.info.translateY = calculateFileVerticalCenterOffset;\n            map.status.translateY = calculateFileVerticalCenterOffset;\n            map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n        }\n\n        // should align center\n        if (isAsync && !allowProcess) {\n            [\n                'DID_START_ITEM_PROCESSING',\n                'DID_REQUEST_ITEM_PROCESSING',\n                'DID_UPDATE_ITEM_PROCESS_PROGRESS',\n                'DID_THROW_ITEM_PROCESSING_ERROR',\n            ].forEach(function(key) {\n                StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;\n            });\n            StyleMap['DID_THROW_ITEM_PROCESSING_ERROR'].status.translateX = calculateButtonWidth;\n        }\n\n        // move remove button to right\n        if (alignRemoveItemButton && allowRevert) {\n            LocalButtons['RevertItemProcessing'].align = 'BUTTON_REMOVE_ITEM_POSITION';\n            var _map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n            _map.info.translateX = calculateFileInfoOffset;\n            _map.status.translateY = calculateFileVerticalCenterOffset;\n            _map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n        }\n\n        // show/hide RemoveItem button\n        if (!allowRemove) {\n            LocalButtons['RemoveItem'].disabled = true;\n        }\n\n        // create the button views\n        forin(LocalButtons, function(key, definition) {\n            // create button\n            var buttonView = root.createChildView(fileActionButton, {\n                label: root.query(definition.label),\n                icon: root.query(definition.icon),\n                opacity: 0,\n            });\n\n            // should be appended?\n            if (enabledButtons.includes(key)) {\n                root.appendChildView(buttonView);\n            }\n\n            // toggle\n            if (definition.disabled) {\n                buttonView.element.setAttribute('disabled', 'disabled');\n                buttonView.element.setAttribute('hidden', 'hidden');\n            }\n\n            // add position attribute\n            buttonView.element.dataset.align = root.query('GET_STYLE_' + definition.align);\n\n            // add class\n            buttonView.element.classList.add(definition.className);\n\n            // handle interactions\n            buttonView.on('click', function(e) {\n                e.stopPropagation();\n                if (definition.disabled) return;\n                root.dispatch(definition.action, { query: id });\n            });\n\n            // set reference\n            root.ref['button' + key] = buttonView;\n        });\n\n        // checkmark\n        root.ref.processingCompleteIndicator = root.appendChildView(\n            root.createChildView(processingCompleteIndicatorView)\n        );\n\n        root.ref.processingCompleteIndicator.element.dataset.align = root.query(\n            'GET_STYLE_BUTTON_PROCESS_ITEM_POSITION'\n        );\n\n        // create file info view\n        root.ref.info = root.appendChildView(root.createChildView(fileInfo, { id: id }));\n\n        // create file status view\n        root.ref.status = root.appendChildView(root.createChildView(fileStatus, { id: id }));\n\n        // add progress indicators\n        var loadIndicatorView = root.appendChildView(\n            root.createChildView(progressIndicator, {\n                opacity: 0,\n                align: root.query('GET_STYLE_LOAD_INDICATOR_POSITION'),\n            })\n        );\n\n        loadIndicatorView.element.classList.add('filepond--load-indicator');\n        root.ref.loadProgressIndicator = loadIndicatorView;\n\n        var progressIndicatorView = root.appendChildView(\n            root.createChildView(progressIndicator, {\n                opacity: 0,\n                align: root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION'),\n            })\n        );\n\n        progressIndicatorView.element.classList.add('filepond--process-indicator');\n        root.ref.processProgressIndicator = progressIndicatorView;\n\n        // current active styles\n        root.ref.activeStyles = [];\n    };\n\n    var write$2 = function write(_ref3) {\n        var root = _ref3.root,\n            actions = _ref3.actions,\n            props = _ref3.props;\n        // route actions\n        route({ root: root, actions: actions, props: props });\n\n        // select last state change action\n        var action = actions\n            .concat()\n            .filter(function(action) {\n                return /^DID_/.test(action.type);\n            })\n            .reverse()\n            .find(function(action) {\n                return StyleMap[action.type];\n            });\n\n        // a new action happened, let's get the matching styles\n        if (action) {\n            // define new active styles\n            root.ref.activeStyles = [];\n\n            var stylesToApply = StyleMap[action.type];\n            forin(DefaultStyle, function(name, defaultStyles) {\n                // get reference to control\n                var control = root.ref[name];\n\n                // loop over all styles for this control\n                forin(defaultStyles, function(key, defaultValue) {\n                    var value =\n                        stylesToApply[name] && typeof stylesToApply[name][key] !== 'undefined'\n                            ? stylesToApply[name][key]\n                            : defaultValue;\n                    root.ref.activeStyles.push({ control: control, key: key, value: value });\n                });\n            });\n        }\n\n        // apply active styles to element\n        root.ref.activeStyles.forEach(function(_ref4) {\n            var control = _ref4.control,\n                key = _ref4.key,\n                value = _ref4.value;\n            control[key] = typeof value === 'function' ? value(root) : value;\n        });\n    };\n\n    var route = createRoute({\n        DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: function DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING(\n            _ref5\n        ) {\n            var root = _ref5.root,\n                action = _ref5.action;\n            root.ref.buttonAbortItemProcessing.label = action.value;\n        },\n        DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: function DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD(_ref6) {\n            var root = _ref6.root,\n                action = _ref6.action;\n            root.ref.buttonAbortItemLoad.label = action.value;\n        },\n        DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: function DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL(\n            _ref7\n        ) {\n            var root = _ref7.root,\n                action = _ref7.action;\n            root.ref.buttonAbortItemRemoval.label = action.value;\n        },\n        DID_REQUEST_ITEM_PROCESSING: function DID_REQUEST_ITEM_PROCESSING(_ref8) {\n            var root = _ref8.root;\n            root.ref.processProgressIndicator.spin = true;\n            root.ref.processProgressIndicator.progress = 0;\n        },\n        DID_START_ITEM_LOAD: function DID_START_ITEM_LOAD(_ref9) {\n            var root = _ref9.root;\n            root.ref.loadProgressIndicator.spin = true;\n            root.ref.loadProgressIndicator.progress = 0;\n        },\n        DID_START_ITEM_REMOVE: function DID_START_ITEM_REMOVE(_ref10) {\n            var root = _ref10.root;\n            root.ref.processProgressIndicator.spin = true;\n            root.ref.processProgressIndicator.progress = 0;\n        },\n        DID_UPDATE_ITEM_LOAD_PROGRESS: function DID_UPDATE_ITEM_LOAD_PROGRESS(_ref11) {\n            var root = _ref11.root,\n                action = _ref11.action;\n            root.ref.loadProgressIndicator.spin = false;\n            root.ref.loadProgressIndicator.progress = action.progress;\n        },\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: function DID_UPDATE_ITEM_PROCESS_PROGRESS(_ref12) {\n            var root = _ref12.root,\n                action = _ref12.action;\n            root.ref.processProgressIndicator.spin = false;\n            root.ref.processProgressIndicator.progress = action.progress;\n        },\n    });\n\n    var file = createView({\n        create: create$4,\n        write: write$2,\n        didCreateView: function didCreateView(root) {\n            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n        },\n        name: 'file',\n    });\n\n    /**\n     * Creates the file view\n     */\n    var create$5 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n\n        // filename\n        root.ref.fileName = createElement$1('legend');\n        root.appendChild(root.ref.fileName);\n\n        // file appended\n        root.ref.file = root.appendChildView(root.createChildView(file, { id: props.id }));\n\n        // data has moved to data.js\n        root.ref.data = false;\n    };\n\n    /**\n     * Data storage\n     */\n    var didLoadItem = function didLoadItem(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        // updates the legend of the fieldset so screenreaders can better group buttons\n        text(root.ref.fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n    };\n\n    var fileWrapper = createView({\n        create: create$5,\n        ignoreRect: true,\n        write: createRoute({\n            DID_LOAD_ITEM: didLoadItem,\n        }),\n\n        didCreateView: function didCreateView(root) {\n            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n        },\n        tag: 'fieldset',\n        name: 'file-wrapper',\n    });\n\n    var PANEL_SPRING_PROPS = { type: 'spring', damping: 0.6, mass: 7 };\n\n    var create$6 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        [\n            {\n                name: 'top',\n            },\n\n            {\n                name: 'center',\n                props: {\n                    translateY: null,\n                    scaleY: null,\n                },\n\n                mixins: {\n                    animations: {\n                        scaleY: PANEL_SPRING_PROPS,\n                    },\n\n                    styles: ['translateY', 'scaleY'],\n                },\n            },\n\n            {\n                name: 'bottom',\n                props: {\n                    translateY: null,\n                },\n\n                mixins: {\n                    animations: {\n                        translateY: PANEL_SPRING_PROPS,\n                    },\n\n                    styles: ['translateY'],\n                },\n            },\n        ].forEach(function(section) {\n            createSection(root, section, props.name);\n        });\n\n        root.element.classList.add('filepond--' + props.name);\n\n        root.ref.scalable = null;\n    };\n\n    var createSection = function createSection(root, section, className) {\n        var viewConstructor = createView({\n            name: 'panel-' + section.name + ' filepond--' + className,\n            mixins: section.mixins,\n            ignoreRectUpdate: true,\n        });\n\n        var view = root.createChildView(viewConstructor, section.props);\n\n        root.ref[section.name] = root.appendChildView(view);\n    };\n\n    var write$3 = function write(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n\n        // update scalable state\n        if (root.ref.scalable === null || props.scalable !== root.ref.scalable) {\n            root.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;\n            root.element.dataset.scalable = root.ref.scalable;\n        }\n\n        // no height, can't set\n        if (!props.height) return;\n\n        // get child rects\n        var topRect = root.ref.top.rect.element;\n        var bottomRect = root.ref.bottom.rect.element;\n\n        // make sure height never is smaller than bottom and top seciton heights combined (will probably never happen, but who knows)\n        var height = Math.max(topRect.height + bottomRect.height, props.height);\n\n        // offset center part\n        root.ref.center.translateY = topRect.height;\n\n        // scale center part\n        // use math ceil to prevent transparent lines because of rounding errors\n        root.ref.center.scaleY = (height - topRect.height - bottomRect.height) / 100;\n\n        // offset bottom part\n        root.ref.bottom.translateY = height - bottomRect.height;\n    };\n\n    var panel = createView({\n        name: 'panel',\n        read: function read(_ref3) {\n            var root = _ref3.root,\n                props = _ref3.props;\n            return (props.heightCurrent = root.ref.bottom.translateY);\n        },\n        write: write$3,\n        create: create$6,\n        ignoreRect: true,\n        mixins: {\n            apis: ['height', 'heightCurrent', 'scalable'],\n        },\n    });\n\n    var createDragHelper = function createDragHelper(items) {\n        var itemIds = items.map(function(item) {\n            return item.id;\n        });\n        var prevIndex = undefined;\n        return {\n            setIndex: function setIndex(index) {\n                prevIndex = index;\n            },\n            getIndex: function getIndex() {\n                return prevIndex;\n            },\n            getItemIndex: function getItemIndex(item) {\n                return itemIds.indexOf(item.id);\n            },\n        };\n    };\n\n    var ITEM_TRANSLATE_SPRING = {\n        type: 'spring',\n        stiffness: 0.75,\n        damping: 0.45,\n        mass: 10,\n    };\n\n    var ITEM_SCALE_SPRING = 'spring';\n\n    var StateMap = {\n        DID_START_ITEM_LOAD: 'busy',\n        DID_UPDATE_ITEM_LOAD_PROGRESS: 'loading',\n        DID_THROW_ITEM_INVALID: 'load-invalid',\n        DID_THROW_ITEM_LOAD_ERROR: 'load-error',\n        DID_LOAD_ITEM: 'idle',\n        DID_THROW_ITEM_REMOVE_ERROR: 'remove-error',\n        DID_START_ITEM_REMOVE: 'busy',\n        DID_START_ITEM_PROCESSING: 'busy processing',\n        DID_REQUEST_ITEM_PROCESSING: 'busy processing',\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: 'processing',\n        DID_COMPLETE_ITEM_PROCESSING: 'processing-complete',\n        DID_THROW_ITEM_PROCESSING_ERROR: 'processing-error',\n        DID_THROW_ITEM_PROCESSING_REVERT_ERROR: 'processing-revert-error',\n        DID_ABORT_ITEM_PROCESSING: 'cancelled',\n        DID_REVERT_ITEM_PROCESSING: 'idle',\n    };\n\n    /**\n     * Creates the file view\n     */\n    var create$7 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        // select\n        root.ref.handleClick = function(e) {\n            return root.dispatch('DID_ACTIVATE_ITEM', { id: props.id });\n        };\n\n        // set id\n        root.element.id = 'filepond--item-' + props.id;\n        root.element.addEventListener('click', root.ref.handleClick);\n\n        // file view\n        root.ref.container = root.appendChildView(\n            root.createChildView(fileWrapper, { id: props.id })\n        );\n\n        // file panel\n        root.ref.panel = root.appendChildView(root.createChildView(panel, { name: 'item-panel' }));\n\n        // default start height\n        root.ref.panel.height = null;\n\n        // by default not marked for removal\n        props.markedForRemoval = false;\n\n        // if not allowed to reorder file items, exit here\n        if (!root.query('GET_ALLOW_REORDER')) return;\n\n        // set to idle so shows grab cursor\n        root.element.dataset.dragState = 'idle';\n\n        var grab = function grab(e) {\n            if (!e.isPrimary) return;\n\n            var removedActivateListener = false;\n\n            var origin = {\n                x: e.pageX,\n                y: e.pageY,\n            };\n\n            props.dragOrigin = {\n                x: root.translateX,\n                y: root.translateY,\n            };\n\n            props.dragCenter = {\n                x: e.offsetX,\n                y: e.offsetY,\n            };\n\n            var dragState = createDragHelper(root.query('GET_ACTIVE_ITEMS'));\n\n            root.dispatch('DID_GRAB_ITEM', { id: props.id, dragState: dragState });\n\n            var drag = function drag(e) {\n                if (!e.isPrimary) return;\n\n                e.stopPropagation();\n                e.preventDefault();\n\n                props.dragOffset = {\n                    x: e.pageX - origin.x,\n                    y: e.pageY - origin.y,\n                };\n\n                // if dragged stop listening to clicks, will re-add when done dragging\n                var dist =\n                    props.dragOffset.x * props.dragOffset.x +\n                    props.dragOffset.y * props.dragOffset.y;\n                if (dist > 16 && !removedActivateListener) {\n                    removedActivateListener = true;\n                    root.element.removeEventListener('click', root.ref.handleClick);\n                }\n\n                root.dispatch('DID_DRAG_ITEM', { id: props.id, dragState: dragState });\n            };\n\n            var drop = function drop(e) {\n                if (!e.isPrimary) return;\n\n                props.dragOffset = {\n                    x: e.pageX - origin.x,\n                    y: e.pageY - origin.y,\n                };\n\n                reset();\n            };\n\n            var cancel = function cancel() {\n                reset();\n            };\n\n            var reset = function reset() {\n                document.removeEventListener('pointercancel', cancel);\n                document.removeEventListener('pointermove', drag);\n                document.removeEventListener('pointerup', drop);\n\n                root.dispatch('DID_DROP_ITEM', { id: props.id, dragState: dragState });\n\n                // start listening to clicks again\n                if (removedActivateListener) {\n                    setTimeout(function() {\n                        return root.element.addEventListener('click', root.ref.handleClick);\n                    }, 0);\n                }\n            };\n\n            document.addEventListener('pointercancel', cancel);\n            document.addEventListener('pointermove', drag);\n            document.addEventListener('pointerup', drop);\n        };\n\n        root.element.addEventListener('pointerdown', grab);\n    };\n\n    var route$1 = createRoute({\n        DID_UPDATE_PANEL_HEIGHT: function DID_UPDATE_PANEL_HEIGHT(_ref2) {\n            var root = _ref2.root,\n                action = _ref2.action;\n            root.height = action.height;\n        },\n    });\n\n    var write$4 = createRoute(\n        {\n            DID_GRAB_ITEM: function DID_GRAB_ITEM(_ref3) {\n                var root = _ref3.root,\n                    props = _ref3.props;\n                props.dragOrigin = {\n                    x: root.translateX,\n                    y: root.translateY,\n                };\n            },\n            DID_DRAG_ITEM: function DID_DRAG_ITEM(_ref4) {\n                var root = _ref4.root;\n                root.element.dataset.dragState = 'drag';\n            },\n            DID_DROP_ITEM: function DID_DROP_ITEM(_ref5) {\n                var root = _ref5.root,\n                    props = _ref5.props;\n                props.dragOffset = null;\n                props.dragOrigin = null;\n                root.element.dataset.dragState = 'drop';\n            },\n        },\n\n        function(_ref6) {\n            var root = _ref6.root,\n                actions = _ref6.actions,\n                props = _ref6.props,\n                shouldOptimize = _ref6.shouldOptimize;\n            if (root.element.dataset.dragState === 'drop') {\n                if (root.scaleX <= 1) {\n                    root.element.dataset.dragState = 'idle';\n                }\n            }\n\n            // select last state change action\n            var action = actions\n                .concat()\n                .filter(function(action) {\n                    return /^DID_/.test(action.type);\n                })\n                .reverse()\n                .find(function(action) {\n                    return StateMap[action.type];\n                });\n\n            // no need to set same state twice\n            if (action && action.type !== props.currentState) {\n                // set current state\n                props.currentState = action.type;\n\n                // set state\n                root.element.dataset.filepondItemState = StateMap[props.currentState] || '';\n            }\n\n            // route actions\n            var aspectRatio =\n                root.query('GET_ITEM_PANEL_ASPECT_RATIO') || root.query('GET_PANEL_ASPECT_RATIO');\n            if (!aspectRatio) {\n                route$1({ root: root, actions: actions, props: props });\n                if (!root.height && root.ref.container.rect.element.height > 0) {\n                    root.height = root.ref.container.rect.element.height;\n                }\n            } else if (!shouldOptimize) {\n                root.height = root.rect.element.width * aspectRatio;\n            }\n\n            // sync panel height with item height\n            if (shouldOptimize) {\n                root.ref.panel.height = null;\n            }\n\n            root.ref.panel.height = root.height;\n        }\n    );\n\n    var item = createView({\n        create: create$7,\n        write: write$4,\n        destroy: function destroy(_ref7) {\n            var root = _ref7.root,\n                props = _ref7.props;\n            root.element.removeEventListener('click', root.ref.handleClick);\n            root.dispatch('RELEASE_ITEM', { query: props.id });\n        },\n        tag: 'li',\n        name: 'item',\n        mixins: {\n            apis: [\n                'id',\n                'interactionMethod',\n                'markedForRemoval',\n                'spawnDate',\n                'dragCenter',\n                'dragOrigin',\n                'dragOffset',\n            ],\n\n            styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity', 'height'],\n            animations: {\n                scaleX: ITEM_SCALE_SPRING,\n                scaleY: ITEM_SCALE_SPRING,\n                translateX: ITEM_TRANSLATE_SPRING,\n                translateY: ITEM_TRANSLATE_SPRING,\n                opacity: { type: 'tween', duration: 150 },\n            },\n        },\n    });\n\n    var getItemsPerRow = function(horizontalSpace, itemWidth) {\n        // add one pixel leeway, when using percentages for item width total items can be 1.99 per row\n\n        return Math.max(1, Math.floor((horizontalSpace + 1) / itemWidth));\n    };\n\n    var getItemIndexByPosition = function getItemIndexByPosition(view, children, positionInView) {\n        if (!positionInView) return;\n\n        var horizontalSpace = view.rect.element.width;\n        // const children = view.childViews;\n        var l = children.length;\n        var last = null;\n\n        // -1, don't move items to accomodate (either add to top or bottom)\n        if (l === 0 || positionInView.top < children[0].rect.element.top) return -1;\n\n        // let's get the item width\n        var item = children[0];\n        var itemRect = item.rect.element;\n        var itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;\n        var itemWidth = itemRect.width + itemHorizontalMargin;\n        var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n\n        // stack\n        if (itemsPerRow === 1) {\n            for (var index = 0; index < l; index++) {\n                var child = children[index];\n                var childMid = child.rect.outer.top + child.rect.element.height * 0.5;\n                if (positionInView.top < childMid) {\n                    return index;\n                }\n            }\n            return l;\n        }\n\n        // grid\n        var itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;\n        var itemHeight = itemRect.height + itemVerticalMargin;\n        for (var _index = 0; _index < l; _index++) {\n            var indexX = _index % itemsPerRow;\n            var indexY = Math.floor(_index / itemsPerRow);\n\n            var offsetX = indexX * itemWidth;\n            var offsetY = indexY * itemHeight;\n\n            var itemTop = offsetY - itemRect.marginTop;\n            var itemRight = offsetX + itemWidth;\n            var itemBottom = offsetY + itemHeight + itemRect.marginBottom;\n\n            if (positionInView.top < itemBottom && positionInView.top > itemTop) {\n                if (positionInView.left < itemRight) {\n                    return _index;\n                } else if (_index !== l - 1) {\n                    last = _index;\n                } else {\n                    last = null;\n                }\n            }\n        }\n\n        if (last !== null) {\n            return last;\n        }\n\n        return l;\n    };\n\n    var dropAreaDimensions = {\n        height: 0,\n        width: 0,\n        get getHeight() {\n            return this.height;\n        },\n        set setHeight(val) {\n            if (this.height === 0 || val === 0) this.height = val;\n        },\n        get getWidth() {\n            return this.width;\n        },\n        set setWidth(val) {\n            if (this.width === 0 || val === 0) this.width = val;\n        },\n        setDimensions: function setDimensions(height, width) {\n            if (this.height === 0 || height === 0) this.height = height;\n            if (this.width === 0 || width === 0) this.width = width;\n        },\n    };\n\n    var create$8 = function create(_ref) {\n        var root = _ref.root;\n        // need to set role to list as otherwise it won't be read as a list by VoiceOver\n        attr(root.element, 'role', 'list');\n\n        root.ref.lastItemSpanwDate = Date.now();\n    };\n\n    /**\n     * Inserts a new item\n     * @param root\n     * @param action\n     */\n    var addItemView = function addItemView(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        var id = action.id,\n            index = action.index,\n            interactionMethod = action.interactionMethod;\n\n        root.ref.addIndex = index;\n\n        var now = Date.now();\n        var spawnDate = now;\n        var opacity = 1;\n\n        if (interactionMethod !== InteractionMethod.NONE) {\n            opacity = 0;\n            var cooldown = root.query('GET_ITEM_INSERT_INTERVAL');\n            var dist = now - root.ref.lastItemSpanwDate;\n            spawnDate = dist < cooldown ? now + (cooldown - dist) : now;\n        }\n\n        root.ref.lastItemSpanwDate = spawnDate;\n\n        root.appendChildView(\n            root.createChildView(\n                // view type\n                item,\n\n                // props\n                {\n                    spawnDate: spawnDate,\n                    id: id,\n                    opacity: opacity,\n                    interactionMethod: interactionMethod,\n                }\n            ),\n\n            index\n        );\n    };\n\n    var moveItem = function moveItem(item, x, y) {\n        var vx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        var vy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n        // set to null to remove animation while dragging\n        if (item.dragOffset) {\n            item.translateX = null;\n            item.translateY = null;\n            item.translateX = item.dragOrigin.x + item.dragOffset.x;\n            item.translateY = item.dragOrigin.y + item.dragOffset.y;\n            item.scaleX = 1.025;\n            item.scaleY = 1.025;\n        } else {\n            item.translateX = x;\n            item.translateY = y;\n\n            if (Date.now() > item.spawnDate) {\n                // reveal element\n                if (item.opacity === 0) {\n                    introItemView(item, x, y, vx, vy);\n                }\n\n                // make sure is default scale every frame\n                item.scaleX = 1;\n                item.scaleY = 1;\n                item.opacity = 1;\n            }\n        }\n    };\n\n    var introItemView = function introItemView(item, x, y, vx, vy) {\n        if (item.interactionMethod === InteractionMethod.NONE) {\n            item.translateX = null;\n            item.translateX = x;\n            item.translateY = null;\n            item.translateY = y;\n        } else if (item.interactionMethod === InteractionMethod.DROP) {\n            item.translateX = null;\n            item.translateX = x - vx * 20;\n\n            item.translateY = null;\n            item.translateY = y - vy * 10;\n\n            item.scaleX = 0.8;\n            item.scaleY = 0.8;\n        } else if (item.interactionMethod === InteractionMethod.BROWSE) {\n            item.translateY = null;\n            item.translateY = y - 30;\n        } else if (item.interactionMethod === InteractionMethod.API) {\n            item.translateX = null;\n            item.translateX = x - 30;\n            item.translateY = null;\n        }\n    };\n\n    /**\n     * Removes an existing item\n     * @param root\n     * @param action\n     */\n    var removeItemView = function removeItemView(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        var id = action.id;\n\n        // get the view matching the given id\n        var view = root.childViews.find(function(child) {\n            return child.id === id;\n        });\n\n        // if no view found, exit\n        if (!view) {\n            return;\n        }\n\n        // animate view out of view\n        view.scaleX = 0.9;\n        view.scaleY = 0.9;\n        view.opacity = 0;\n\n        // mark for removal\n        view.markedForRemoval = true;\n    };\n\n    var getItemHeight = function getItemHeight(child) {\n        return (\n            child.rect.element.height +\n            child.rect.element.marginBottom * 0.5 +\n            child.rect.element.marginTop * 0.5\n        );\n    };\n    var getItemWidth = function getItemWidth(child) {\n        return (\n            child.rect.element.width +\n            child.rect.element.marginLeft * 0.5 +\n            child.rect.element.marginRight * 0.5\n        );\n    };\n\n    var dragItem = function dragItem(_ref4) {\n        var root = _ref4.root,\n            action = _ref4.action;\n        var id = action.id,\n            dragState = action.dragState;\n\n        // reference to item\n        var item = root.query('GET_ITEM', { id: id });\n\n        // get the view matching the given id\n        var view = root.childViews.find(function(child) {\n            return child.id === id;\n        });\n\n        var numItems = root.childViews.length;\n        var oldIndex = dragState.getItemIndex(item);\n\n        // if no view found, exit\n        if (!view) return;\n\n        var dragPosition = {\n            x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,\n            y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y,\n        };\n\n        // get drag area dimensions\n        var dragHeight = getItemHeight(view);\n        var dragWidth = getItemWidth(view);\n\n        // get rows and columns (There will always be at least one row and one column if a file is present)\n        var cols = Math.floor(root.rect.outer.width / dragWidth);\n        if (cols > numItems) cols = numItems;\n\n        // rows are used to find when we have left the preview area bounding box\n        var rows = Math.floor(numItems / cols + 1);\n\n        dropAreaDimensions.setHeight = dragHeight * rows;\n        dropAreaDimensions.setWidth = dragWidth * cols;\n\n        // get new index of dragged item\n        var location = {\n            y: Math.floor(dragPosition.y / dragHeight),\n            x: Math.floor(dragPosition.x / dragWidth),\n            getGridIndex: function getGridIndex() {\n                if (\n                    dragPosition.y > dropAreaDimensions.getHeight ||\n                    dragPosition.y < 0 ||\n                    dragPosition.x > dropAreaDimensions.getWidth ||\n                    dragPosition.x < 0\n                )\n                    return oldIndex;\n                return this.y * cols + this.x;\n            },\n            getColIndex: function getColIndex() {\n                var items = root.query('GET_ACTIVE_ITEMS');\n                var visibleChildren = root.childViews.filter(function(child) {\n                    return child.rect.element.height;\n                });\n                var children = items.map(function(item) {\n                    return visibleChildren.find(function(childView) {\n                        return childView.id === item.id;\n                    });\n                });\n\n                var currentIndex = children.findIndex(function(child) {\n                    return child === view;\n                });\n                var dragHeight = getItemHeight(view);\n                var l = children.length;\n                var idx = l;\n                var childHeight = 0;\n                var childBottom = 0;\n                var childTop = 0;\n                for (var i = 0; i < l; i++) {\n                    childHeight = getItemHeight(children[i]);\n                    childTop = childBottom;\n                    childBottom = childTop + childHeight;\n                    if (dragPosition.y < childBottom) {\n                        if (currentIndex > i) {\n                            if (dragPosition.y < childTop + dragHeight) {\n                                idx = i;\n                                break;\n                            }\n                            continue;\n                        }\n                        idx = i;\n                        break;\n                    }\n                }\n                return idx;\n            },\n        };\n\n        // get new index\n        var index = cols > 1 ? location.getGridIndex() : location.getColIndex();\n        root.dispatch('MOVE_ITEM', { query: view, index: index });\n\n        // if the index of the item changed, dispatch reorder action\n        var currentIndex = dragState.getIndex();\n\n        if (currentIndex === undefined || currentIndex !== index) {\n            dragState.setIndex(index);\n\n            if (currentIndex === undefined) return;\n\n            root.dispatch('DID_REORDER_ITEMS', {\n                items: root.query('GET_ACTIVE_ITEMS'),\n                origin: oldIndex,\n                target: index,\n            });\n        }\n    };\n\n    /**\n     * Setup action routes\n     */\n    var route$2 = createRoute({\n        DID_ADD_ITEM: addItemView,\n        DID_REMOVE_ITEM: removeItemView,\n        DID_DRAG_ITEM: dragItem,\n    });\n\n    /**\n     * Write to view\n     * @param root\n     * @param actions\n     * @param props\n     */\n    var write$5 = function write(_ref5) {\n        var root = _ref5.root,\n            props = _ref5.props,\n            actions = _ref5.actions,\n            shouldOptimize = _ref5.shouldOptimize;\n        // route actions\n        route$2({ root: root, props: props, actions: actions });\n        var dragCoordinates = props.dragCoordinates;\n\n        // available space on horizontal axis\n        var horizontalSpace = root.rect.element.width;\n\n        // only draw children that have dimensions\n        var visibleChildren = root.childViews.filter(function(child) {\n            return child.rect.element.height;\n        });\n\n        // sort based on current active items\n        var children = root\n            .query('GET_ACTIVE_ITEMS')\n            .map(function(item) {\n                return visibleChildren.find(function(child) {\n                    return child.id === item.id;\n                });\n            })\n            .filter(function(item) {\n                return item;\n            });\n\n        // get index\n        var dragIndex = dragCoordinates\n            ? getItemIndexByPosition(root, children, dragCoordinates)\n            : null;\n\n        // add index is used to reserve the dropped/added item index till the actual item is rendered\n        var addIndex = root.ref.addIndex || null;\n\n        // add index no longer needed till possibly next draw\n        root.ref.addIndex = null;\n\n        var dragIndexOffset = 0;\n        var removeIndexOffset = 0;\n        var addIndexOffset = 0;\n\n        if (children.length === 0) return;\n\n        var childRect = children[0].rect.element;\n        var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n        var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n        var itemWidth = childRect.width + itemHorizontalMargin;\n        var itemHeight = childRect.height + itemVerticalMargin;\n        var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n\n        // stack\n        if (itemsPerRow === 1) {\n            var offsetY = 0;\n            var dragOffset = 0;\n\n            children.forEach(function(child, index) {\n                if (dragIndex) {\n                    var dist = index - dragIndex;\n                    if (dist === -2) {\n                        dragOffset = -itemVerticalMargin * 0.25;\n                    } else if (dist === -1) {\n                        dragOffset = -itemVerticalMargin * 0.75;\n                    } else if (dist === 0) {\n                        dragOffset = itemVerticalMargin * 0.75;\n                    } else if (dist === 1) {\n                        dragOffset = itemVerticalMargin * 0.25;\n                    } else {\n                        dragOffset = 0;\n                    }\n                }\n\n                if (shouldOptimize) {\n                    child.translateX = null;\n                    child.translateY = null;\n                }\n\n                if (!child.markedForRemoval) {\n                    moveItem(child, 0, offsetY + dragOffset);\n                }\n\n                var itemHeight = child.rect.element.height + itemVerticalMargin;\n\n                var visualHeight = itemHeight * (child.markedForRemoval ? child.opacity : 1);\n\n                offsetY += visualHeight;\n            });\n        }\n        // grid\n        else {\n            var prevX = 0;\n            var prevY = 0;\n\n            children.forEach(function(child, index) {\n                if (index === dragIndex) {\n                    dragIndexOffset = 1;\n                }\n\n                if (index === addIndex) {\n                    addIndexOffset += 1;\n                }\n\n                if (child.markedForRemoval && child.opacity < 0.5) {\n                    removeIndexOffset -= 1;\n                }\n\n                var visualIndex = index + addIndexOffset + dragIndexOffset + removeIndexOffset;\n\n                var indexX = visualIndex % itemsPerRow;\n                var indexY = Math.floor(visualIndex / itemsPerRow);\n\n                var offsetX = indexX * itemWidth;\n                var offsetY = indexY * itemHeight;\n\n                var vectorX = Math.sign(offsetX - prevX);\n                var vectorY = Math.sign(offsetY - prevY);\n\n                prevX = offsetX;\n                prevY = offsetY;\n\n                if (child.markedForRemoval) return;\n\n                if (shouldOptimize) {\n                    child.translateX = null;\n                    child.translateY = null;\n                }\n\n                moveItem(child, offsetX, offsetY, vectorX, vectorY);\n            });\n        }\n    };\n\n    /**\n     * Filters actions that are meant specifically for a certain child of the list\n     * @param child\n     * @param actions\n     */\n    var filterSetItemActions = function filterSetItemActions(child, actions) {\n        return actions.filter(function(action) {\n            // if action has an id, filter out actions that don't have this child id\n            if (action.data && action.data.id) {\n                return child.id === action.data.id;\n            }\n\n            // allow all other actions\n            return true;\n        });\n    };\n\n    var list = createView({\n        create: create$8,\n        write: write$5,\n        tag: 'ul',\n        name: 'list',\n        didWriteView: function didWriteView(_ref6) {\n            var root = _ref6.root;\n            root.childViews\n                .filter(function(view) {\n                    return view.markedForRemoval && view.opacity === 0 && view.resting;\n                })\n                .forEach(function(view) {\n                    view._destroy();\n                    root.removeChildView(view);\n                });\n        },\n        filterFrameActionsForChild: filterSetItemActions,\n        mixins: {\n            apis: ['dragCoordinates'],\n        },\n    });\n\n    var create$9 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        root.ref.list = root.appendChildView(root.createChildView(list));\n        props.dragCoordinates = null;\n        props.overflowing = false;\n    };\n\n    var storeDragCoordinates = function storeDragCoordinates(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props,\n            action = _ref2.action;\n        if (!root.query('GET_ITEM_INSERT_LOCATION_FREEDOM')) return;\n        props.dragCoordinates = {\n            left: action.position.scopeLeft - root.ref.list.rect.element.left,\n            top:\n                action.position.scopeTop -\n                (root.rect.outer.top + root.rect.element.marginTop + root.rect.element.scrollTop),\n        };\n    };\n\n    var clearDragCoordinates = function clearDragCoordinates(_ref3) {\n        var props = _ref3.props;\n        props.dragCoordinates = null;\n    };\n\n    var route$3 = createRoute({\n        DID_DRAG: storeDragCoordinates,\n        DID_END_DRAG: clearDragCoordinates,\n    });\n\n    var write$6 = function write(_ref4) {\n        var root = _ref4.root,\n            props = _ref4.props,\n            actions = _ref4.actions;\n\n        // route actions\n        route$3({ root: root, props: props, actions: actions });\n\n        // current drag position\n        root.ref.list.dragCoordinates = props.dragCoordinates;\n\n        // if currently overflowing but no longer received overflow\n        if (props.overflowing && !props.overflow) {\n            props.overflowing = false;\n\n            // reset overflow state\n            root.element.dataset.state = '';\n            root.height = null;\n        }\n\n        // if is not overflowing currently but does receive overflow value\n        if (props.overflow) {\n            var newHeight = Math.round(props.overflow);\n            if (newHeight !== root.height) {\n                props.overflowing = true;\n                root.element.dataset.state = 'overflow';\n                root.height = newHeight;\n            }\n        }\n    };\n\n    var listScroller = createView({\n        create: create$9,\n        write: write$6,\n        name: 'list-scroller',\n        mixins: {\n            apis: ['overflow', 'dragCoordinates'],\n            styles: ['height', 'translateY'],\n            animations: {\n                translateY: 'spring',\n            },\n        },\n    });\n\n    var attrToggle = function attrToggle(element, name, state) {\n        var enabledValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n        if (state) {\n            attr(element, name, enabledValue);\n        } else {\n            element.removeAttribute(name);\n        }\n    };\n\n    var resetFileInput = function resetFileInput(input) {\n        // no value, no need to reset\n        if (!input || input.value === '') {\n            return;\n        }\n\n        try {\n            // for modern browsers\n            input.value = '';\n        } catch (err) {}\n\n        // for IE10\n        if (input.value) {\n            // quickly append input to temp form and reset form\n            var form = createElement$1('form');\n            var parentNode = input.parentNode;\n            var ref = input.nextSibling;\n            form.appendChild(input);\n            form.reset();\n\n            // re-inject input where it originally was\n            if (ref) {\n                parentNode.insertBefore(input, ref);\n            } else {\n                parentNode.appendChild(input);\n            }\n        }\n    };\n\n    var create$a = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n\n        // set id so can be referenced from outside labels\n        root.element.id = 'filepond--browser-' + props.id;\n\n        // set name of element (is removed when a value is set)\n        attr(root.element, 'name', root.query('GET_NAME'));\n\n        // we have to link this element to the status element\n        attr(root.element, 'aria-controls', 'filepond--assistant-' + props.id);\n\n        // set label, we use labelled by as otherwise the screenreader does not read the \"browse\" text in the label (as it has tabindex: 0)\n        attr(root.element, 'aria-labelledby', 'filepond--drop-label-' + props.id);\n\n        // set configurable props\n        setAcceptedFileTypes({\n            root: root,\n            action: { value: root.query('GET_ACCEPTED_FILE_TYPES') },\n        });\n        toggleAllowMultiple({ root: root, action: { value: root.query('GET_ALLOW_MULTIPLE') } });\n        toggleDirectoryFilter({\n            root: root,\n            action: { value: root.query('GET_ALLOW_DIRECTORIES_ONLY') },\n        });\n        toggleDisabled({ root: root });\n        toggleRequired({ root: root, action: { value: root.query('GET_REQUIRED') } });\n        setCaptureMethod({ root: root, action: { value: root.query('GET_CAPTURE_METHOD') } });\n\n        // handle changes to the input field\n        root.ref.handleChange = function(e) {\n            if (!root.element.value) {\n                return;\n            }\n\n            // extract files and move value of webkitRelativePath path to _relativePath\n            var files = Array.from(root.element.files).map(function(file) {\n                file._relativePath = file.webkitRelativePath;\n                return file;\n            });\n\n            // we add a little delay so the OS file select window can move out of the way before we add our file\n            setTimeout(function() {\n                // load files\n                props.onload(files);\n\n                // reset input, it's just for exposing a method to drop files, should not retain any state\n                resetFileInput(root.element);\n            }, 250);\n        };\n\n        root.element.addEventListener('change', root.ref.handleChange);\n    };\n\n    var setAcceptedFileTypes = function setAcceptedFileTypes(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        if (!root.query('GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE')) return;\n        attrToggle(\n            root.element,\n            'accept',\n            !!action.value,\n            action.value ? action.value.join(',') : ''\n        );\n    };\n\n    var toggleAllowMultiple = function toggleAllowMultiple(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        attrToggle(root.element, 'multiple', action.value);\n    };\n\n    var toggleDirectoryFilter = function toggleDirectoryFilter(_ref4) {\n        var root = _ref4.root,\n            action = _ref4.action;\n        attrToggle(root.element, 'webkitdirectory', action.value);\n    };\n\n    var toggleDisabled = function toggleDisabled(_ref5) {\n        var root = _ref5.root;\n        var isDisabled = root.query('GET_DISABLED');\n        var doesAllowBrowse = root.query('GET_ALLOW_BROWSE');\n        var disableField = isDisabled || !doesAllowBrowse;\n        attrToggle(root.element, 'disabled', disableField);\n    };\n\n    var toggleRequired = function toggleRequired(_ref6) {\n        var root = _ref6.root,\n            action = _ref6.action;\n        // want to remove required, always possible\n        if (!action.value) {\n            attrToggle(root.element, 'required', false);\n        }\n        // if want to make required, only possible when zero items\n        else if (root.query('GET_TOTAL_ITEMS') === 0) {\n            attrToggle(root.element, 'required', true);\n        }\n    };\n\n    var setCaptureMethod = function setCaptureMethod(_ref7) {\n        var root = _ref7.root,\n            action = _ref7.action;\n        attrToggle(\n            root.element,\n            'capture',\n            !!action.value,\n            action.value === true ? '' : action.value\n        );\n    };\n\n    var updateRequiredStatus = function updateRequiredStatus(_ref8) {\n        var root = _ref8.root;\n        var element = root.element;\n        // always remove the required attribute when more than zero items\n        if (root.query('GET_TOTAL_ITEMS') > 0) {\n            attrToggle(element, 'required', false);\n            attrToggle(element, 'name', false);\n        } else {\n            // add name attribute\n            attrToggle(element, 'name', true, root.query('GET_NAME'));\n\n            // remove any validation messages\n            var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n            if (shouldCheckValidity) {\n                element.setCustomValidity('');\n            }\n\n            // we only add required if the field has been deemed required\n            if (root.query('GET_REQUIRED')) {\n                attrToggle(element, 'required', true);\n            }\n        }\n    };\n\n    var updateFieldValidityStatus = function updateFieldValidityStatus(_ref9) {\n        var root = _ref9.root;\n        var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n        if (!shouldCheckValidity) return;\n        root.element.setCustomValidity(root.query('GET_LABEL_INVALID_FIELD'));\n    };\n\n    var browser = createView({\n        tag: 'input',\n        name: 'browser',\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        attributes: {\n            type: 'file',\n        },\n\n        create: create$a,\n        destroy: function destroy(_ref10) {\n            var root = _ref10.root;\n            root.element.removeEventListener('change', root.ref.handleChange);\n        },\n        write: createRoute({\n            DID_LOAD_ITEM: updateRequiredStatus,\n            DID_REMOVE_ITEM: updateRequiredStatus,\n            DID_THROW_ITEM_INVALID: updateFieldValidityStatus,\n\n            DID_SET_DISABLED: toggleDisabled,\n            DID_SET_ALLOW_BROWSE: toggleDisabled,\n            DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,\n            DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,\n            DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,\n            DID_SET_CAPTURE_METHOD: setCaptureMethod,\n            DID_SET_REQUIRED: toggleRequired,\n        }),\n    });\n\n    var Key = {\n        ENTER: 13,\n        SPACE: 32,\n    };\n\n    var create$b = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n\n        // create the label and link it to the file browser\n        var label = createElement$1('label');\n        attr(label, 'for', 'filepond--browser-' + props.id);\n\n        // use for labeling file input (aria-labelledby on file input)\n        attr(label, 'id', 'filepond--drop-label-' + props.id);\n\n        // hide the label for screenreaders, the input element will read the contents of the label when it's focussed. If we don't set aria-hidden the screenreader will also navigate the contents of the label separately from the input.\n        attr(label, 'aria-hidden', 'true');\n\n        // handle keys\n        root.ref.handleKeyDown = function(e) {\n            var isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;\n            if (!isActivationKey) return;\n            // stops from triggering the element a second time\n            e.preventDefault();\n\n            // click link (will then in turn activate file input)\n            root.ref.label.click();\n        };\n\n        root.ref.handleClick = function(e) {\n            var isLabelClick = e.target === label || label.contains(e.target);\n\n            // don't want to click twice\n            if (isLabelClick) return;\n\n            // click link (will then in turn activate file input)\n            root.ref.label.click();\n        };\n\n        // attach events\n        label.addEventListener('keydown', root.ref.handleKeyDown);\n        root.element.addEventListener('click', root.ref.handleClick);\n\n        // update\n        updateLabelValue(label, props.caption);\n\n        // add!\n        root.appendChild(label);\n        root.ref.label = label;\n    };\n\n    var updateLabelValue = function updateLabelValue(label, value) {\n        label.innerHTML = value;\n        var clickable = label.querySelector('.filepond--label-action');\n        if (clickable) {\n            attr(clickable, 'tabindex', '0');\n        }\n        return value;\n    };\n\n    var dropLabel = createView({\n        name: 'drop-label',\n        ignoreRect: true,\n        create: create$b,\n        destroy: function destroy(_ref2) {\n            var root = _ref2.root;\n            root.ref.label.addEventListener('keydown', root.ref.handleKeyDown);\n            root.element.removeEventListener('click', root.ref.handleClick);\n        },\n        write: createRoute({\n            DID_SET_LABEL_IDLE: function DID_SET_LABEL_IDLE(_ref3) {\n                var root = _ref3.root,\n                    action = _ref3.action;\n                updateLabelValue(root.ref.label, action.value);\n            },\n        }),\n\n        mixins: {\n            styles: ['opacity', 'translateX', 'translateY'],\n            animations: {\n                opacity: { type: 'tween', duration: 150 },\n                translateX: 'spring',\n                translateY: 'spring',\n            },\n        },\n    });\n\n    var blob = createView({\n        name: 'drip-blob',\n        ignoreRect: true,\n        mixins: {\n            styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n            animations: {\n                scaleX: 'spring',\n                scaleY: 'spring',\n                translateX: 'spring',\n                translateY: 'spring',\n                opacity: { type: 'tween', duration: 250 },\n            },\n        },\n    });\n\n    var addBlob = function addBlob(_ref) {\n        var root = _ref.root;\n        var centerX = root.rect.element.width * 0.5;\n        var centerY = root.rect.element.height * 0.5;\n\n        root.ref.blob = root.appendChildView(\n            root.createChildView(blob, {\n                opacity: 0,\n                scaleX: 2.5,\n                scaleY: 2.5,\n                translateX: centerX,\n                translateY: centerY,\n            })\n        );\n    };\n\n    var moveBlob = function moveBlob(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        if (!root.ref.blob) {\n            addBlob({ root: root });\n            return;\n        }\n\n        root.ref.blob.translateX = action.position.scopeLeft;\n        root.ref.blob.translateY = action.position.scopeTop;\n        root.ref.blob.scaleX = 1;\n        root.ref.blob.scaleY = 1;\n        root.ref.blob.opacity = 1;\n    };\n\n    var hideBlob = function hideBlob(_ref3) {\n        var root = _ref3.root;\n        if (!root.ref.blob) {\n            return;\n        }\n        root.ref.blob.opacity = 0;\n    };\n\n    var explodeBlob = function explodeBlob(_ref4) {\n        var root = _ref4.root;\n        if (!root.ref.blob) {\n            return;\n        }\n        root.ref.blob.scaleX = 2.5;\n        root.ref.blob.scaleY = 2.5;\n        root.ref.blob.opacity = 0;\n    };\n\n    var write$7 = function write(_ref5) {\n        var root = _ref5.root,\n            props = _ref5.props,\n            actions = _ref5.actions;\n        route$4({ root: root, props: props, actions: actions });\n        var blob = root.ref.blob;\n\n        if (actions.length === 0 && blob && blob.opacity === 0) {\n            root.removeChildView(blob);\n            root.ref.blob = null;\n        }\n    };\n\n    var route$4 = createRoute({\n        DID_DRAG: moveBlob,\n        DID_DROP: explodeBlob,\n        DID_END_DRAG: hideBlob,\n    });\n\n    var drip = createView({\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        name: 'drip',\n        write: write$7,\n    });\n\n    var setInputFiles = function setInputFiles(element, files) {\n        try {\n            // Create a DataTransfer instance and add a newly created file\n            var dataTransfer = new DataTransfer();\n            files.forEach(function(file) {\n                if (file instanceof File) {\n                    dataTransfer.items.add(file);\n                } else {\n                    dataTransfer.items.add(\n                        new File([file], file.name, {\n                            type: file.type,\n                        })\n                    );\n                }\n            });\n\n            // Assign the DataTransfer files list to the file input\n            element.files = dataTransfer.files;\n        } catch (err) {\n            return false;\n        }\n        return true;\n    };\n\n    var create$c = function create(_ref) {\n        var root = _ref.root;\n        return (root.ref.fields = {});\n    };\n\n    var getField = function getField(root, id) {\n        return root.ref.fields[id];\n    };\n\n    var syncFieldPositionsWithItems = function syncFieldPositionsWithItems(root) {\n        root.query('GET_ACTIVE_ITEMS').forEach(function(item) {\n            if (!root.ref.fields[item.id]) return;\n            root.element.appendChild(root.ref.fields[item.id]);\n        });\n    };\n\n    var didReorderItems = function didReorderItems(_ref2) {\n        var root = _ref2.root;\n        return syncFieldPositionsWithItems(root);\n    };\n\n    var didAddItem = function didAddItem(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        var fileItem = root.query('GET_ITEM', action.id);\n        var isLocalFile = fileItem.origin === FileOrigin.LOCAL;\n        var shouldUseFileInput = !isLocalFile && root.query('SHOULD_UPDATE_FILE_INPUT');\n        var dataContainer = createElement$1('input');\n        dataContainer.type = shouldUseFileInput ? 'file' : 'hidden';\n        dataContainer.name = root.query('GET_NAME');\n        dataContainer.disabled = root.query('GET_DISABLED');\n        root.ref.fields[action.id] = dataContainer;\n        syncFieldPositionsWithItems(root);\n    };\n\n    var didLoadItem$1 = function didLoadItem(_ref4) {\n        var root = _ref4.root,\n            action = _ref4.action;\n        var field = getField(root, action.id);\n        if (!field) return;\n\n        // store server ref in hidden input\n        if (action.serverFileReference !== null) field.value = action.serverFileReference;\n\n        // store file item in file input\n        if (!root.query('SHOULD_UPDATE_FILE_INPUT')) return;\n\n        var fileItem = root.query('GET_ITEM', action.id);\n        setInputFiles(field, [fileItem.file]);\n    };\n\n    var didPrepareOutput = function didPrepareOutput(_ref5) {\n        var root = _ref5.root,\n            action = _ref5.action;\n        // this timeout pushes the handler after 'load'\n        if (!root.query('SHOULD_UPDATE_FILE_INPUT')) return;\n        setTimeout(function() {\n            var field = getField(root, action.id);\n            if (!field) return;\n            setInputFiles(field, [action.file]);\n        }, 0);\n    };\n\n    var didSetDisabled = function didSetDisabled(_ref6) {\n        var root = _ref6.root;\n        root.element.disabled = root.query('GET_DISABLED');\n    };\n\n    var didRemoveItem = function didRemoveItem(_ref7) {\n        var root = _ref7.root,\n            action = _ref7.action;\n        var field = getField(root, action.id);\n        if (!field) return;\n        if (field.parentNode) field.parentNode.removeChild(field);\n        delete root.ref.fields[action.id];\n    };\n\n    // only runs for server files. will refuse to update the value if the field\n    // is a file field\n    var didDefineValue = function didDefineValue(_ref8) {\n        var root = _ref8.root,\n            action = _ref8.action;\n        var field = getField(root, action.id);\n        if (!field) return;\n        if (action.value === null) {\n            // clear field value\n            field.removeAttribute('value');\n        } else {\n            // set field value\n            if (field.type != 'file') {\n                field.value = action.value;\n            }\n        }\n        syncFieldPositionsWithItems(root);\n    };\n\n    var write$8 = createRoute({\n        DID_SET_DISABLED: didSetDisabled,\n        DID_ADD_ITEM: didAddItem,\n        DID_LOAD_ITEM: didLoadItem$1,\n        DID_REMOVE_ITEM: didRemoveItem,\n        DID_DEFINE_VALUE: didDefineValue,\n        DID_PREPARE_OUTPUT: didPrepareOutput,\n        DID_REORDER_ITEMS: didReorderItems,\n        DID_SORT_ITEMS: didReorderItems,\n    });\n\n    var data = createView({\n        tag: 'fieldset',\n        name: 'data',\n        create: create$c,\n        write: write$8,\n        ignoreRect: true,\n    });\n\n    var getRootNode = function getRootNode(element) {\n        return 'getRootNode' in element ? element.getRootNode() : document;\n    };\n\n    var images = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'tiff'];\n    var text$1 = ['css', 'csv', 'html', 'txt'];\n    var map = {\n        zip: 'zip|compressed',\n        epub: 'application/epub+zip',\n    };\n\n    var guesstimateMimeType = function guesstimateMimeType() {\n        var extension = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        extension = extension.toLowerCase();\n        if (images.includes(extension)) {\n            return (\n                'image/' +\n                (extension === 'jpg' ? 'jpeg' : extension === 'svg' ? 'svg+xml' : extension)\n            );\n        }\n        if (text$1.includes(extension)) {\n            return 'text/' + extension;\n        }\n\n        return map[extension] || '';\n    };\n\n    var requestDataTransferItems = function requestDataTransferItems(dataTransfer) {\n        return new Promise(function(resolve, reject) {\n            // try to get links from transfer, if found we'll exit immediately (unless a file is in the dataTransfer as well, this is because Firefox could represent the file as a URL and a file object at the same time)\n            var links = getLinks(dataTransfer);\n            if (links.length && !hasFiles(dataTransfer)) {\n                return resolve(links);\n            }\n            // try to get files from the transfer\n            getFiles(dataTransfer).then(resolve);\n        });\n    };\n\n    /**\n     * Test if datatransfer has files\n     */\n    var hasFiles = function hasFiles(dataTransfer) {\n        if (dataTransfer.files) return dataTransfer.files.length > 0;\n        return false;\n    };\n\n    /**\n     * Extracts files from a DataTransfer object\n     */\n    var getFiles = function getFiles(dataTransfer) {\n        return new Promise(function(resolve, reject) {\n            // get the transfer items as promises\n            var promisedFiles = (dataTransfer.items ? Array.from(dataTransfer.items) : [])\n                // only keep file system items (files and directories)\n                .filter(function(item) {\n                    return isFileSystemItem(item);\n                })\n\n                // map each item to promise\n                .map(function(item) {\n                    return getFilesFromItem(item);\n                });\n\n            // if is empty, see if we can extract some info from the files property as a fallback\n            if (!promisedFiles.length) {\n                // TODO: test for directories (should not be allowed)\n                // Use FileReader, problem is that the files property gets lost in the process\n                resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);\n                return;\n            }\n\n            // done!\n            Promise.all(promisedFiles)\n                .then(function(returnedFileGroups) {\n                    // flatten groups\n                    var files = [];\n                    returnedFileGroups.forEach(function(group) {\n                        files.push.apply(files, group);\n                    });\n\n                    // done (filter out empty files)!\n                    resolve(\n                        files\n                            .filter(function(file) {\n                                return file;\n                            })\n                            .map(function(file) {\n                                if (!file._relativePath)\n                                    file._relativePath = file.webkitRelativePath;\n                                return file;\n                            })\n                    );\n                })\n                .catch(console.error);\n        });\n    };\n\n    var isFileSystemItem = function isFileSystemItem(item) {\n        if (isEntry(item)) {\n            var entry = getAsEntry(item);\n            if (entry) {\n                return entry.isFile || entry.isDirectory;\n            }\n        }\n        return item.kind === 'file';\n    };\n\n    var getFilesFromItem = function getFilesFromItem(item) {\n        return new Promise(function(resolve, reject) {\n            if (isDirectoryEntry(item)) {\n                getFilesInDirectory(getAsEntry(item))\n                    .then(resolve)\n                    .catch(reject);\n                return;\n            }\n\n            resolve([item.getAsFile()]);\n        });\n    };\n\n    var getFilesInDirectory = function getFilesInDirectory(entry) {\n        return new Promise(function(resolve, reject) {\n            var files = [];\n\n            // the total entries to read\n            var dirCounter = 0;\n            var fileCounter = 0;\n\n            var resolveIfDone = function resolveIfDone() {\n                if (fileCounter === 0 && dirCounter === 0) {\n                    resolve(files);\n                }\n            };\n\n            // the recursive function\n            var readEntries = function readEntries(dirEntry) {\n                dirCounter++;\n\n                var directoryReader = dirEntry.createReader();\n\n                // directories are returned in batches, we need to process all batches before we're done\n                var readBatch = function readBatch() {\n                    directoryReader.readEntries(function(entries) {\n                        if (entries.length === 0) {\n                            dirCounter--;\n                            resolveIfDone();\n                            return;\n                        }\n\n                        entries.forEach(function(entry) {\n                            // recursively read more directories\n                            if (entry.isDirectory) {\n                                readEntries(entry);\n                            } else {\n                                // read as file\n                                fileCounter++;\n\n                                entry.file(function(file) {\n                                    var correctedFile = correctMissingFileType(file);\n                                    if (entry.fullPath)\n                                        correctedFile._relativePath = entry.fullPath;\n                                    files.push(correctedFile);\n                                    fileCounter--;\n                                    resolveIfDone();\n                                });\n                            }\n                        });\n\n                        // try to get next batch of files\n                        readBatch();\n                    }, reject);\n                };\n\n                // read first batch of files\n                readBatch();\n            };\n\n            // go!\n            readEntries(entry);\n        });\n    };\n\n    var correctMissingFileType = function correctMissingFileType(file) {\n        if (file.type.length) return file;\n        var date = file.lastModifiedDate;\n        var name = file.name;\n        var type = guesstimateMimeType(getExtensionFromFilename(file.name));\n        if (!type.length) return file;\n        file = file.slice(0, file.size, type);\n        file.name = name;\n        file.lastModifiedDate = date;\n        return file;\n    };\n\n    var isDirectoryEntry = function isDirectoryEntry(item) {\n        return isEntry(item) && (getAsEntry(item) || {}).isDirectory;\n    };\n\n    var isEntry = function isEntry(item) {\n        return 'webkitGetAsEntry' in item;\n    };\n\n    var getAsEntry = function getAsEntry(item) {\n        return item.webkitGetAsEntry();\n    };\n\n    /**\n     * Extracts links from a DataTransfer object\n     */\n    var getLinks = function getLinks(dataTransfer) {\n        var links = [];\n        try {\n            // look in meta data property\n            links = getLinksFromTransferMetaData(dataTransfer);\n            if (links.length) {\n                return links;\n            }\n            links = getLinksFromTransferURLData(dataTransfer);\n        } catch (e) {\n            // nope nope nope (probably IE trouble)\n        }\n        return links;\n    };\n\n    var getLinksFromTransferURLData = function getLinksFromTransferURLData(dataTransfer) {\n        var data = dataTransfer.getData('url');\n        if (typeof data === 'string' && data.length) {\n            return [data];\n        }\n        return [];\n    };\n\n    var getLinksFromTransferMetaData = function getLinksFromTransferMetaData(dataTransfer) {\n        var data = dataTransfer.getData('text/html');\n        if (typeof data === 'string' && data.length) {\n            var matches = data.match(/src\\s*=\\s*\"(.+?)\"/);\n            if (matches) {\n                return [matches[1]];\n            }\n        }\n        return [];\n    };\n\n    var dragNDropObservers = [];\n\n    var eventPosition = function eventPosition(e) {\n        return {\n            pageLeft: e.pageX,\n            pageTop: e.pageY,\n            scopeLeft: e.offsetX || e.layerX,\n            scopeTop: e.offsetY || e.layerY,\n        };\n    };\n\n    var createDragNDropClient = function createDragNDropClient(\n        element,\n        scopeToObserve,\n        filterElement\n    ) {\n        var observer = getDragNDropObserver(scopeToObserve);\n\n        var client = {\n            element: element,\n            filterElement: filterElement,\n            state: null,\n            ondrop: function ondrop() {},\n            onenter: function onenter() {},\n            ondrag: function ondrag() {},\n            onexit: function onexit() {},\n            onload: function onload() {},\n            allowdrop: function allowdrop() {},\n        };\n\n        client.destroy = observer.addListener(client);\n\n        return client;\n    };\n\n    var getDragNDropObserver = function getDragNDropObserver(element) {\n        // see if already exists, if so, return\n        var observer = dragNDropObservers.find(function(item) {\n            return item.element === element;\n        });\n        if (observer) {\n            return observer;\n        }\n\n        // create new observer, does not yet exist for this element\n        var newObserver = createDragNDropObserver(element);\n        dragNDropObservers.push(newObserver);\n        return newObserver;\n    };\n\n    var createDragNDropObserver = function createDragNDropObserver(element) {\n        var clients = [];\n\n        var routes = {\n            dragenter: dragenter,\n            dragover: dragover,\n            dragleave: dragleave,\n            drop: drop,\n        };\n\n        var handlers = {};\n\n        forin(routes, function(event, createHandler) {\n            handlers[event] = createHandler(element, clients);\n            element.addEventListener(event, handlers[event], false);\n        });\n\n        var observer = {\n            element: element,\n            addListener: function addListener(client) {\n                // add as client\n                clients.push(client);\n\n                // return removeListener function\n                return function() {\n                    // remove client\n                    clients.splice(clients.indexOf(client), 1);\n\n                    // if no more clients, clean up observer\n                    if (clients.length === 0) {\n                        dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);\n\n                        forin(routes, function(event) {\n                            element.removeEventListener(event, handlers[event], false);\n                        });\n                    }\n                };\n            },\n        };\n\n        return observer;\n    };\n\n    var elementFromPoint = function elementFromPoint(root, point) {\n        if (!('elementFromPoint' in root)) {\n            root = document;\n        }\n        return root.elementFromPoint(point.x, point.y);\n    };\n\n    var isEventTarget = function isEventTarget(e, target) {\n        // get root\n        var root = getRootNode(target);\n\n        // get element at position\n        // if root is not actual shadow DOM and does not have elementFromPoint method, use the one on document\n        var elementAtPosition = elementFromPoint(root, {\n            x: e.pageX - window.pageXOffset,\n            y: e.pageY - window.pageYOffset,\n        });\n\n        // test if target is the element or if one of its children is\n        return elementAtPosition === target || target.contains(elementAtPosition);\n    };\n\n    var initialTarget = null;\n\n    var setDropEffect = function setDropEffect(dataTransfer, effect) {\n        // is in try catch as IE11 will throw error if not\n        try {\n            dataTransfer.dropEffect = effect;\n        } catch (e) {}\n    };\n\n    var dragenter = function dragenter(root, clients) {\n        return function(e) {\n            e.preventDefault();\n\n            initialTarget = e.target;\n\n            clients.forEach(function(client) {\n                var element = client.element,\n                    onenter = client.onenter;\n\n                if (isEventTarget(e, element)) {\n                    client.state = 'enter';\n\n                    // fire enter event\n                    onenter(eventPosition(e));\n                }\n            });\n        };\n    };\n\n    var dragover = function dragover(root, clients) {\n        return function(e) {\n            e.preventDefault();\n\n            var dataTransfer = e.dataTransfer;\n\n            requestDataTransferItems(dataTransfer).then(function(items) {\n                var overDropTarget = false;\n\n                clients.some(function(client) {\n                    var filterElement = client.filterElement,\n                        element = client.element,\n                        onenter = client.onenter,\n                        onexit = client.onexit,\n                        ondrag = client.ondrag,\n                        allowdrop = client.allowdrop;\n\n                    // by default we can drop\n                    setDropEffect(dataTransfer, 'copy');\n\n                    // allow transfer of these items\n                    var allowsTransfer = allowdrop(items);\n\n                    // only used when can be dropped on page\n                    if (!allowsTransfer) {\n                        setDropEffect(dataTransfer, 'none');\n                        return;\n                    }\n\n                    // targetting this client\n                    if (isEventTarget(e, element)) {\n                        overDropTarget = true;\n\n                        // had no previous state, means we are entering this client\n                        if (client.state === null) {\n                            client.state = 'enter';\n                            onenter(eventPosition(e));\n                            return;\n                        }\n\n                        // now over element (no matter if it allows the drop or not)\n                        client.state = 'over';\n\n                        // needs to allow transfer\n                        if (filterElement && !allowsTransfer) {\n                            setDropEffect(dataTransfer, 'none');\n                            return;\n                        }\n\n                        // dragging\n                        ondrag(eventPosition(e));\n                    } else {\n                        // should be over an element to drop\n                        if (filterElement && !overDropTarget) {\n                            setDropEffect(dataTransfer, 'none');\n                        }\n\n                        // might have just left this client?\n                        if (client.state) {\n                            client.state = null;\n                            onexit(eventPosition(e));\n                        }\n                    }\n                });\n            });\n        };\n    };\n\n    var drop = function drop(root, clients) {\n        return function(e) {\n            e.preventDefault();\n\n            var dataTransfer = e.dataTransfer;\n\n            requestDataTransferItems(dataTransfer).then(function(items) {\n                clients.forEach(function(client) {\n                    var filterElement = client.filterElement,\n                        element = client.element,\n                        ondrop = client.ondrop,\n                        onexit = client.onexit,\n                        allowdrop = client.allowdrop;\n\n                    client.state = null;\n\n                    // if we're filtering on element we need to be over the element to drop\n                    if (filterElement && !isEventTarget(e, element)) return;\n\n                    // no transfer for this client\n                    if (!allowdrop(items)) return onexit(eventPosition(e));\n\n                    // we can drop these items on this client\n                    ondrop(eventPosition(e), items);\n                });\n            });\n        };\n    };\n\n    var dragleave = function dragleave(root, clients) {\n        return function(e) {\n            if (initialTarget !== e.target) {\n                return;\n            }\n\n            clients.forEach(function(client) {\n                var onexit = client.onexit;\n\n                client.state = null;\n\n                onexit(eventPosition(e));\n            });\n        };\n    };\n\n    var createHopper = function createHopper(scope, validateItems, options) {\n        // is now hopper scope\n        scope.classList.add('filepond--hopper');\n\n        // shortcuts\n        var catchesDropsOnPage = options.catchesDropsOnPage,\n            requiresDropOnElement = options.requiresDropOnElement,\n            _options$filterItems = options.filterItems,\n            filterItems =\n                _options$filterItems === void 0\n                    ? function(items) {\n                          return items;\n                      }\n                    : _options$filterItems;\n\n        // create a dnd client\n        var client = createDragNDropClient(\n            scope,\n            catchesDropsOnPage ? document.documentElement : scope,\n            requiresDropOnElement\n        );\n\n        // current client state\n        var lastState = '';\n        var currentState = '';\n\n        // determines if a file may be dropped\n        client.allowdrop = function(items) {\n            // TODO: if we can, throw error to indicate the items cannot by dropped\n\n            return validateItems(filterItems(items));\n        };\n\n        client.ondrop = function(position, items) {\n            var filteredItems = filterItems(items);\n\n            if (!validateItems(filteredItems)) {\n                api.ondragend(position);\n                return;\n            }\n\n            currentState = 'drag-drop';\n\n            api.onload(filteredItems, position);\n        };\n\n        client.ondrag = function(position) {\n            api.ondrag(position);\n        };\n\n        client.onenter = function(position) {\n            currentState = 'drag-over';\n\n            api.ondragstart(position);\n        };\n\n        client.onexit = function(position) {\n            currentState = 'drag-exit';\n\n            api.ondragend(position);\n        };\n\n        var api = {\n            updateHopperState: function updateHopperState() {\n                if (lastState !== currentState) {\n                    scope.dataset.hopperState = currentState;\n                    lastState = currentState;\n                }\n            },\n            onload: function onload() {},\n            ondragstart: function ondragstart() {},\n            ondrag: function ondrag() {},\n            ondragend: function ondragend() {},\n            destroy: function destroy() {\n                // destroy client\n                client.destroy();\n            },\n        };\n\n        return api;\n    };\n\n    var listening = false;\n    var listeners$1 = [];\n\n    var handlePaste = function handlePaste(e) {\n        // if is pasting in input or textarea and the target is outside of a filepond scope, ignore\n        var activeEl = document.activeElement;\n        if (activeEl && /textarea|input/i.test(activeEl.nodeName)) {\n            // test textarea or input is contained in filepond root\n            var inScope = false;\n            var element = activeEl;\n            while (element !== document.body) {\n                if (element.classList.contains('filepond--root')) {\n                    inScope = true;\n                    break;\n                }\n                element = element.parentNode;\n            }\n\n            if (!inScope) return;\n        }\n\n        requestDataTransferItems(e.clipboardData).then(function(files) {\n            // no files received\n            if (!files.length) {\n                return;\n            }\n\n            // notify listeners of received files\n            listeners$1.forEach(function(listener) {\n                return listener(files);\n            });\n        });\n    };\n\n    var listen = function listen(cb) {\n        // can't add twice\n        if (listeners$1.includes(cb)) {\n            return;\n        }\n\n        // add initial listener\n        listeners$1.push(cb);\n\n        // setup paste listener for entire page\n        if (listening) {\n            return;\n        }\n\n        listening = true;\n        document.addEventListener('paste', handlePaste);\n    };\n\n    var unlisten = function unlisten(listener) {\n        arrayRemove(listeners$1, listeners$1.indexOf(listener));\n\n        // clean up\n        if (listeners$1.length === 0) {\n            document.removeEventListener('paste', handlePaste);\n            listening = false;\n        }\n    };\n\n    var createPaster = function createPaster() {\n        var cb = function cb(files) {\n            api.onload(files);\n        };\n\n        var api = {\n            destroy: function destroy() {\n                unlisten(cb);\n            },\n            onload: function onload() {},\n        };\n\n        listen(cb);\n\n        return api;\n    };\n\n    /**\n     * Creates the file view\n     */\n    var create$d = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        root.element.id = 'filepond--assistant-' + props.id;\n        attr(root.element, 'role', 'status');\n        attr(root.element, 'aria-live', 'polite');\n        attr(root.element, 'aria-relevant', 'additions');\n    };\n\n    var addFilesNotificationTimeout = null;\n    var notificationClearTimeout = null;\n\n    var filenames = [];\n\n    var assist = function assist(root, message) {\n        root.element.textContent = message;\n    };\n\n    var clear$1 = function clear(root) {\n        root.element.textContent = '';\n    };\n\n    var listModified = function listModified(root, filename, label) {\n        var total = root.query('GET_TOTAL_ITEMS');\n        assist(\n            root,\n            label +\n                ' ' +\n                filename +\n                ', ' +\n                total +\n                ' ' +\n                (total === 1\n                    ? root.query('GET_LABEL_FILE_COUNT_SINGULAR')\n                    : root.query('GET_LABEL_FILE_COUNT_PLURAL'))\n        );\n\n        // clear group after set amount of time so the status is not read twice\n        clearTimeout(notificationClearTimeout);\n        notificationClearTimeout = setTimeout(function() {\n            clear$1(root);\n        }, 1500);\n    };\n\n    var isUsingFilePond = function isUsingFilePond(root) {\n        return root.element.parentNode.contains(document.activeElement);\n    };\n\n    var itemAdded = function itemAdded(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        if (!isUsingFilePond(root)) {\n            return;\n        }\n\n        root.element.textContent = '';\n        var item = root.query('GET_ITEM', action.id);\n        filenames.push(item.filename);\n\n        clearTimeout(addFilesNotificationTimeout);\n        addFilesNotificationTimeout = setTimeout(function() {\n            listModified(root, filenames.join(', '), root.query('GET_LABEL_FILE_ADDED'));\n\n            filenames.length = 0;\n        }, 750);\n    };\n\n    var itemRemoved = function itemRemoved(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        if (!isUsingFilePond(root)) {\n            return;\n        }\n\n        var item = action.item;\n        listModified(root, item.filename, root.query('GET_LABEL_FILE_REMOVED'));\n    };\n\n    var itemProcessed = function itemProcessed(_ref4) {\n        var root = _ref4.root,\n            action = _ref4.action;\n        // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n        var item = root.query('GET_ITEM', action.id);\n        var filename = item.filename;\n        var label = root.query('GET_LABEL_FILE_PROCESSING_COMPLETE');\n\n        assist(root, filename + ' ' + label);\n    };\n\n    var itemProcessedUndo = function itemProcessedUndo(_ref5) {\n        var root = _ref5.root,\n            action = _ref5.action;\n        var item = root.query('GET_ITEM', action.id);\n        var filename = item.filename;\n        var label = root.query('GET_LABEL_FILE_PROCESSING_ABORTED');\n\n        assist(root, filename + ' ' + label);\n    };\n\n    var itemError = function itemError(_ref6) {\n        var root = _ref6.root,\n            action = _ref6.action;\n        var item = root.query('GET_ITEM', action.id);\n        var filename = item.filename;\n\n        // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n        assist(root, action.status.main + ' ' + filename + ' ' + action.status.sub);\n    };\n\n    var assistant = createView({\n        create: create$d,\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        write: createRoute({\n            DID_LOAD_ITEM: itemAdded,\n            DID_REMOVE_ITEM: itemRemoved,\n            DID_COMPLETE_ITEM_PROCESSING: itemProcessed,\n\n            DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,\n            DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,\n\n            DID_THROW_ITEM_REMOVE_ERROR: itemError,\n            DID_THROW_ITEM_LOAD_ERROR: itemError,\n            DID_THROW_ITEM_INVALID: itemError,\n            DID_THROW_ITEM_PROCESSING_ERROR: itemError,\n        }),\n\n        tag: 'span',\n        name: 'assistant',\n    });\n\n    var toCamels = function toCamels(string) {\n        var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n        return string.replace(new RegExp(separator + '.', 'g'), function(sub) {\n            return sub.charAt(1).toUpperCase();\n        });\n    };\n\n    var debounce = function debounce(func) {\n        var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n        var immidiateOnly =\n            arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        var last = Date.now();\n        var timeout = null;\n\n        return function() {\n            for (\n                var _len = arguments.length, args = new Array(_len), _key = 0;\n                _key < _len;\n                _key++\n            ) {\n                args[_key] = arguments[_key];\n            }\n            clearTimeout(timeout);\n\n            var dist = Date.now() - last;\n\n            var fn = function fn() {\n                last = Date.now();\n                func.apply(void 0, args);\n            };\n\n            if (dist < interval) {\n                // we need to delay by the difference between interval and dist\n                // for example: if distance is 10 ms and interval is 16 ms,\n                // we need to wait an additional 6ms before calling the function)\n                if (!immidiateOnly) {\n                    timeout = setTimeout(fn, interval - dist);\n                }\n            } else {\n                // go!\n                fn();\n            }\n        };\n    };\n\n    var MAX_FILES_LIMIT = 1000000;\n\n    var prevent = function prevent(e) {\n        return e.preventDefault();\n    };\n\n    var create$e = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        // Add id\n        var id = root.query('GET_ID');\n        if (id) {\n            root.element.id = id;\n        }\n\n        // Add className\n        var className = root.query('GET_CLASS_NAME');\n        if (className) {\n            className\n                .split(' ')\n                .filter(function(name) {\n                    return name.length;\n                })\n                .forEach(function(name) {\n                    root.element.classList.add(name);\n                });\n        }\n\n        // Field label\n        root.ref.label = root.appendChildView(\n            root.createChildView(\n                dropLabel,\n                Object.assign({}, props, {\n                    translateY: null,\n                    caption: root.query('GET_LABEL_IDLE'),\n                })\n            )\n        );\n\n        // List of items\n        root.ref.list = root.appendChildView(\n            root.createChildView(listScroller, { translateY: null })\n        );\n\n        // Background panel\n        root.ref.panel = root.appendChildView(root.createChildView(panel, { name: 'panel-root' }));\n\n        // Assistant notifies assistive tech when content changes\n        root.ref.assistant = root.appendChildView(\n            root.createChildView(assistant, Object.assign({}, props))\n        );\n\n        // Data\n        root.ref.data = root.appendChildView(root.createChildView(data, Object.assign({}, props)));\n\n        // Measure (tests if fixed height was set)\n        // DOCTYPE needs to be set for this to work\n        root.ref.measure = createElement$1('div');\n        root.ref.measure.style.height = '100%';\n        root.element.appendChild(root.ref.measure);\n\n        // information on the root height or fixed height status\n        root.ref.bounds = null;\n\n        // apply initial style properties\n        root.query('GET_STYLES')\n            .filter(function(style) {\n                return !isEmpty(style.value);\n            })\n            .map(function(_ref2) {\n                var name = _ref2.name,\n                    value = _ref2.value;\n                root.element.dataset[name] = value;\n            });\n\n        // determine if width changed\n        root.ref.widthPrevious = null;\n        root.ref.widthUpdated = debounce(function() {\n            root.ref.updateHistory = [];\n            root.dispatch('DID_RESIZE_ROOT');\n        }, 250);\n\n        // history of updates\n        root.ref.previousAspectRatio = null;\n        root.ref.updateHistory = [];\n\n        // prevent scrolling and zooming on iOS (only if supports pointer events, for then we can enable reorder)\n        var canHover = window.matchMedia('(pointer: fine) and (hover: hover)').matches;\n        var hasPointerEvents = 'PointerEvent' in window;\n        if (root.query('GET_ALLOW_REORDER') && hasPointerEvents && !canHover) {\n            root.element.addEventListener('touchmove', prevent, { passive: false });\n            root.element.addEventListener('gesturestart', prevent);\n        }\n\n        // add credits\n        var credits = root.query('GET_CREDITS');\n        var hasCredits = credits.length === 2;\n        if (hasCredits) {\n            var frag = document.createElement('a');\n            frag.className = 'filepond--credits';\n            frag.setAttribute('aria-hidden', 'true');\n            frag.href = credits[0];\n            frag.tabindex = -1;\n            frag.target = '_blank';\n            frag.rel = 'noopener noreferrer';\n            frag.textContent = credits[1];\n            root.element.appendChild(frag);\n            root.ref.credits = frag;\n        }\n    };\n\n    var write$9 = function write(_ref3) {\n        var root = _ref3.root,\n            props = _ref3.props,\n            actions = _ref3.actions;\n        // route actions\n        route$5({ root: root, props: props, actions: actions });\n\n        // apply style properties\n        actions\n            .filter(function(action) {\n                return /^DID_SET_STYLE_/.test(action.type);\n            })\n            .filter(function(action) {\n                return !isEmpty(action.data.value);\n            })\n            .map(function(_ref4) {\n                var type = _ref4.type,\n                    data = _ref4.data;\n                var name = toCamels(type.substring(8).toLowerCase(), '_');\n                root.element.dataset[name] = data.value;\n                root.invalidateLayout();\n            });\n\n        if (root.rect.element.hidden) return;\n\n        if (root.rect.element.width !== root.ref.widthPrevious) {\n            root.ref.widthPrevious = root.rect.element.width;\n            root.ref.widthUpdated();\n        }\n\n        // get box bounds, we do this only once\n        var bounds = root.ref.bounds;\n        if (!bounds) {\n            bounds = root.ref.bounds = calculateRootBoundingBoxHeight(root);\n\n            // destroy measure element\n            root.element.removeChild(root.ref.measure);\n            root.ref.measure = null;\n        }\n\n        // get quick references to various high level parts of the upload tool\n        var _root$ref = root.ref,\n            hopper = _root$ref.hopper,\n            label = _root$ref.label,\n            list = _root$ref.list,\n            panel = _root$ref.panel;\n\n        // sets correct state to hopper scope\n        if (hopper) {\n            hopper.updateHopperState();\n        }\n\n        // bool to indicate if we're full or not\n        var aspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n        var isMultiItem = root.query('GET_ALLOW_MULTIPLE');\n        var totalItems = root.query('GET_TOTAL_ITEMS');\n        var maxItems = isMultiItem ? root.query('GET_MAX_FILES') || MAX_FILES_LIMIT : 1;\n        var atMaxCapacity = totalItems === maxItems;\n\n        // action used to add item\n        var addAction = actions.find(function(action) {\n            return action.type === 'DID_ADD_ITEM';\n        });\n\n        // if reached max capacity and we've just reached it\n        if (atMaxCapacity && addAction) {\n            // get interaction type\n            var interactionMethod = addAction.data.interactionMethod;\n\n            // hide label\n            label.opacity = 0;\n\n            if (isMultiItem) {\n                label.translateY = -40;\n            } else {\n                if (interactionMethod === InteractionMethod.API) {\n                    label.translateX = 40;\n                } else if (interactionMethod === InteractionMethod.BROWSE) {\n                    label.translateY = 40;\n                } else {\n                    label.translateY = 30;\n                }\n            }\n        } else if (!atMaxCapacity) {\n            label.opacity = 1;\n            label.translateX = 0;\n            label.translateY = 0;\n        }\n\n        var listItemMargin = calculateListItemMargin(root);\n\n        var listHeight = calculateListHeight(root);\n\n        var labelHeight = label.rect.element.height;\n        var currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;\n\n        var listMarginTop = atMaxCapacity ? list.rect.element.marginTop : 0;\n        var listMarginBottom = totalItems === 0 ? 0 : list.rect.element.marginBottom;\n\n        var visualHeight =\n            currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;\n        var boundsHeight =\n            currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;\n\n        // link list to label bottom position\n        list.translateY =\n            Math.max(0, currentLabelHeight - list.rect.element.marginTop) - listItemMargin.top;\n\n        if (aspectRatio) {\n            // fixed aspect ratio\n\n            // calculate height based on width\n            var width = root.rect.element.width;\n            var height = width * aspectRatio;\n\n            // clear history if aspect ratio has changed\n            if (aspectRatio !== root.ref.previousAspectRatio) {\n                root.ref.previousAspectRatio = aspectRatio;\n                root.ref.updateHistory = [];\n            }\n\n            // remember this width\n            var history = root.ref.updateHistory;\n            history.push(width);\n\n            var MAX_BOUNCES = 2;\n            if (history.length > MAX_BOUNCES * 2) {\n                var l = history.length;\n                var bottom = l - 10;\n                var bounces = 0;\n                for (var i = l; i >= bottom; i--) {\n                    if (history[i] === history[i - 2]) {\n                        bounces++;\n                    }\n\n                    if (bounces >= MAX_BOUNCES) {\n                        // dont adjust height\n                        return;\n                    }\n                }\n            }\n\n            // fix height of panel so it adheres to aspect ratio\n            panel.scalable = false;\n            panel.height = height;\n\n            // available height for list\n            var listAvailableHeight =\n                // the height of the panel minus the label height\n                height -\n                currentLabelHeight -\n                // the room we leave open between the end of the list and the panel bottom\n                (listMarginBottom - listItemMargin.bottom) -\n                // if we're full we need to leave some room between the top of the panel and the list\n                (atMaxCapacity ? listMarginTop : 0);\n\n            if (listHeight.visual > listAvailableHeight) {\n                list.overflow = listAvailableHeight;\n            } else {\n                list.overflow = null;\n            }\n\n            // set container bounds (so pushes siblings downwards)\n            root.height = height;\n        } else if (bounds.fixedHeight) {\n            // fixed height\n\n            // fix height of panel\n            panel.scalable = false;\n\n            // available height for list\n            var _listAvailableHeight =\n                // the height of the panel minus the label height\n                bounds.fixedHeight -\n                currentLabelHeight -\n                // the room we leave open between the end of the list and the panel bottom\n                (listMarginBottom - listItemMargin.bottom) -\n                // if we're full we need to leave some room between the top of the panel and the list\n                (atMaxCapacity ? listMarginTop : 0);\n\n            // set list height\n            if (listHeight.visual > _listAvailableHeight) {\n                list.overflow = _listAvailableHeight;\n            } else {\n                list.overflow = null;\n            }\n\n            // no need to set container bounds as these are handles by CSS fixed height\n        } else if (bounds.cappedHeight) {\n            // max-height\n\n            // not a fixed height panel\n            var isCappedHeight = visualHeight >= bounds.cappedHeight;\n            var panelHeight = Math.min(bounds.cappedHeight, visualHeight);\n            panel.scalable = true;\n            panel.height = isCappedHeight\n                ? panelHeight\n                : panelHeight - listItemMargin.top - listItemMargin.bottom;\n\n            // available height for list\n            var _listAvailableHeight2 =\n                // the height of the panel minus the label height\n                panelHeight -\n                currentLabelHeight -\n                // the room we leave open between the end of the list and the panel bottom\n                (listMarginBottom - listItemMargin.bottom) -\n                // if we're full we need to leave some room between the top of the panel and the list\n                (atMaxCapacity ? listMarginTop : 0);\n\n            // set list height (if is overflowing)\n            if (visualHeight > bounds.cappedHeight && listHeight.visual > _listAvailableHeight2) {\n                list.overflow = _listAvailableHeight2;\n            } else {\n                list.overflow = null;\n            }\n\n            // set container bounds (so pushes siblings downwards)\n            root.height = Math.min(\n                bounds.cappedHeight,\n                boundsHeight - listItemMargin.top - listItemMargin.bottom\n            );\n        } else {\n            // flexible height\n\n            // not a fixed height panel\n            var itemMargin = totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;\n            panel.scalable = true;\n            panel.height = Math.max(labelHeight, visualHeight - itemMargin);\n\n            // set container bounds (so pushes siblings downwards)\n            root.height = Math.max(labelHeight, boundsHeight - itemMargin);\n        }\n\n        // move credits to bottom\n        if (root.ref.credits && panel.heightCurrent)\n            root.ref.credits.style.transform = 'translateY(' + panel.heightCurrent + 'px)';\n    };\n\n    var calculateListItemMargin = function calculateListItemMargin(root) {\n        var item = root.ref.list.childViews[0].childViews[0];\n        return item\n            ? {\n                  top: item.rect.element.marginTop,\n                  bottom: item.rect.element.marginBottom,\n              }\n            : {\n                  top: 0,\n                  bottom: 0,\n              };\n    };\n\n    var calculateListHeight = function calculateListHeight(root) {\n        var visual = 0;\n        var bounds = 0;\n\n        // get file list reference\n        var scrollList = root.ref.list;\n        var itemList = scrollList.childViews[0];\n        var visibleChildren = itemList.childViews.filter(function(child) {\n            return child.rect.element.height;\n        });\n        var children = root\n            .query('GET_ACTIVE_ITEMS')\n            .map(function(item) {\n                return visibleChildren.find(function(child) {\n                    return child.id === item.id;\n                });\n            })\n            .filter(function(item) {\n                return item;\n            });\n\n        // no children, done!\n        if (children.length === 0) return { visual: visual, bounds: bounds };\n\n        var horizontalSpace = itemList.rect.element.width;\n        var dragIndex = getItemIndexByPosition(itemList, children, scrollList.dragCoordinates);\n\n        var childRect = children[0].rect.element;\n\n        var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n        var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n\n        var itemWidth = childRect.width + itemHorizontalMargin;\n        var itemHeight = childRect.height + itemVerticalMargin;\n\n        var newItem = typeof dragIndex !== 'undefined' && dragIndex >= 0 ? 1 : 0;\n        var removedItem = children.find(function(child) {\n            return child.markedForRemoval && child.opacity < 0.45;\n        })\n            ? -1\n            : 0;\n        var verticalItemCount = children.length + newItem + removedItem;\n        var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n\n        // stack\n        if (itemsPerRow === 1) {\n            children.forEach(function(item) {\n                var height = item.rect.element.height + itemVerticalMargin;\n                bounds += height;\n                visual += height * item.opacity;\n            });\n        }\n        // grid\n        else {\n            bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;\n            visual = bounds;\n        }\n\n        return { visual: visual, bounds: bounds };\n    };\n\n    var calculateRootBoundingBoxHeight = function calculateRootBoundingBoxHeight(root) {\n        var height = root.ref.measureHeight || null;\n        var cappedHeight = parseInt(root.style.maxHeight, 10) || null;\n        var fixedHeight = height === 0 ? null : height;\n\n        return {\n            cappedHeight: cappedHeight,\n            fixedHeight: fixedHeight,\n        };\n    };\n\n    var exceedsMaxFiles = function exceedsMaxFiles(root, items) {\n        var allowReplace = root.query('GET_ALLOW_REPLACE');\n        var allowMultiple = root.query('GET_ALLOW_MULTIPLE');\n        var totalItems = root.query('GET_TOTAL_ITEMS');\n        var maxItems = root.query('GET_MAX_FILES');\n\n        // total amount of items being dragged\n        var totalBrowseItems = items.length;\n\n        // if does not allow multiple items and dragging more than one item\n        if (!allowMultiple && totalBrowseItems > 1) {\n            root.dispatch('DID_THROW_MAX_FILES', {\n                source: items,\n                error: createResponse('warning', 0, 'Max files'),\n            });\n\n            return true;\n        }\n\n        // limit max items to one if not allowed to drop multiple items\n        maxItems = allowMultiple ? maxItems : 1;\n\n        if (!allowMultiple && allowReplace) {\n            // There is only one item, so there is room to replace or add an item\n            return false;\n        }\n\n        // no more room?\n        var hasMaxItems = isInt(maxItems);\n        if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {\n            root.dispatch('DID_THROW_MAX_FILES', {\n                source: items,\n                error: createResponse('warning', 0, 'Max files'),\n            });\n\n            return true;\n        }\n\n        return false;\n    };\n\n    var getDragIndex = function getDragIndex(list, children, position) {\n        var itemList = list.childViews[0];\n        return getItemIndexByPosition(itemList, children, {\n            left: position.scopeLeft - itemList.rect.element.left,\n            top:\n                position.scopeTop -\n                (list.rect.outer.top + list.rect.element.marginTop + list.rect.element.scrollTop),\n        });\n    };\n\n    /**\n     * Enable or disable file drop functionality\n     */\n    var toggleDrop = function toggleDrop(root) {\n        var isAllowed = root.query('GET_ALLOW_DROP');\n        var isDisabled = root.query('GET_DISABLED');\n        var enabled = isAllowed && !isDisabled;\n        if (enabled && !root.ref.hopper) {\n            var hopper = createHopper(\n                root.element,\n                function(items) {\n                    // allow quick validation of dropped items\n                    var beforeDropFile =\n                        root.query('GET_BEFORE_DROP_FILE') ||\n                        function() {\n                            return true;\n                        };\n\n                    // all items should be validated by all filters as valid\n                    var dropValidation = root.query('GET_DROP_VALIDATION');\n                    return dropValidation\n                        ? items.every(function(item) {\n                              return (\n                                  applyFilters('ALLOW_HOPPER_ITEM', item, {\n                                      query: root.query,\n                                  }).every(function(result) {\n                                      return result === true;\n                                  }) && beforeDropFile(item)\n                              );\n                          })\n                        : true;\n                },\n                {\n                    filterItems: function filterItems(items) {\n                        var ignoredFiles = root.query('GET_IGNORED_FILES');\n                        return items.filter(function(item) {\n                            if (isFile(item)) {\n                                return !ignoredFiles.includes(item.name.toLowerCase());\n                            }\n                            return true;\n                        });\n                    },\n                    catchesDropsOnPage: root.query('GET_DROP_ON_PAGE'),\n                    requiresDropOnElement: root.query('GET_DROP_ON_ELEMENT'),\n                }\n            );\n\n            hopper.onload = function(items, position) {\n                // get item children elements and sort based on list sort\n                var list = root.ref.list.childViews[0];\n                var visibleChildren = list.childViews.filter(function(child) {\n                    return child.rect.element.height;\n                });\n                var children = root\n                    .query('GET_ACTIVE_ITEMS')\n                    .map(function(item) {\n                        return visibleChildren.find(function(child) {\n                            return child.id === item.id;\n                        });\n                    })\n                    .filter(function(item) {\n                        return item;\n                    });\n\n                applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(function(\n                    queue\n                ) {\n                    // these files don't fit so stop here\n                    if (exceedsMaxFiles(root, queue)) return false;\n\n                    // go\n                    root.dispatch('ADD_ITEMS', {\n                        items: queue,\n                        index: getDragIndex(root.ref.list, children, position),\n                        interactionMethod: InteractionMethod.DROP,\n                    });\n                });\n\n                root.dispatch('DID_DROP', { position: position });\n\n                root.dispatch('DID_END_DRAG', { position: position });\n            };\n\n            hopper.ondragstart = function(position) {\n                root.dispatch('DID_START_DRAG', { position: position });\n            };\n\n            hopper.ondrag = debounce(function(position) {\n                root.dispatch('DID_DRAG', { position: position });\n            });\n\n            hopper.ondragend = function(position) {\n                root.dispatch('DID_END_DRAG', { position: position });\n            };\n\n            root.ref.hopper = hopper;\n\n            root.ref.drip = root.appendChildView(root.createChildView(drip));\n        } else if (!enabled && root.ref.hopper) {\n            root.ref.hopper.destroy();\n            root.ref.hopper = null;\n            root.removeChildView(root.ref.drip);\n        }\n    };\n\n    /**\n     * Enable or disable browse functionality\n     */\n    var toggleBrowse = function toggleBrowse(root, props) {\n        var isAllowed = root.query('GET_ALLOW_BROWSE');\n        var isDisabled = root.query('GET_DISABLED');\n        var enabled = isAllowed && !isDisabled;\n        if (enabled && !root.ref.browser) {\n            root.ref.browser = root.appendChildView(\n                root.createChildView(\n                    browser,\n                    Object.assign({}, props, {\n                        onload: function onload(items) {\n                            applyFilterChain('ADD_ITEMS', items, {\n                                dispatch: root.dispatch,\n                            }).then(function(queue) {\n                                // these files don't fit so stop here\n                                if (exceedsMaxFiles(root, queue)) return false;\n\n                                // add items!\n                                root.dispatch('ADD_ITEMS', {\n                                    items: queue,\n                                    index: -1,\n                                    interactionMethod: InteractionMethod.BROWSE,\n                                });\n                            });\n                        },\n                    })\n                ),\n\n                0\n            );\n        } else if (!enabled && root.ref.browser) {\n            root.removeChildView(root.ref.browser);\n            root.ref.browser = null;\n        }\n    };\n\n    /**\n     * Enable or disable paste functionality\n     */\n    var togglePaste = function togglePaste(root) {\n        var isAllowed = root.query('GET_ALLOW_PASTE');\n        var isDisabled = root.query('GET_DISABLED');\n        var enabled = isAllowed && !isDisabled;\n        if (enabled && !root.ref.paster) {\n            root.ref.paster = createPaster();\n            root.ref.paster.onload = function(items) {\n                applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(function(\n                    queue\n                ) {\n                    // these files don't fit so stop here\n                    if (exceedsMaxFiles(root, queue)) return false;\n\n                    // add items!\n                    root.dispatch('ADD_ITEMS', {\n                        items: queue,\n                        index: -1,\n                        interactionMethod: InteractionMethod.PASTE,\n                    });\n                });\n            };\n        } else if (!enabled && root.ref.paster) {\n            root.ref.paster.destroy();\n            root.ref.paster = null;\n        }\n    };\n\n    /**\n     * Route actions\n     */\n    var route$5 = createRoute({\n        DID_SET_ALLOW_BROWSE: function DID_SET_ALLOW_BROWSE(_ref5) {\n            var root = _ref5.root,\n                props = _ref5.props;\n            toggleBrowse(root, props);\n        },\n        DID_SET_ALLOW_DROP: function DID_SET_ALLOW_DROP(_ref6) {\n            var root = _ref6.root;\n            toggleDrop(root);\n        },\n        DID_SET_ALLOW_PASTE: function DID_SET_ALLOW_PASTE(_ref7) {\n            var root = _ref7.root;\n            togglePaste(root);\n        },\n        DID_SET_DISABLED: function DID_SET_DISABLED(_ref8) {\n            var root = _ref8.root,\n                props = _ref8.props;\n            toggleDrop(root);\n            togglePaste(root);\n            toggleBrowse(root, props);\n            var isDisabled = root.query('GET_DISABLED');\n            if (isDisabled) {\n                root.element.dataset.disabled = 'disabled';\n            } else {\n                // delete root.element.dataset.disabled; <= this does not work on iOS 10\n                root.element.removeAttribute('data-disabled');\n            }\n        },\n    });\n\n    var root = createView({\n        name: 'root',\n        read: function read(_ref9) {\n            var root = _ref9.root;\n            if (root.ref.measure) {\n                root.ref.measureHeight = root.ref.measure.offsetHeight;\n            }\n        },\n        create: create$e,\n        write: write$9,\n        destroy: function destroy(_ref10) {\n            var root = _ref10.root;\n            if (root.ref.paster) {\n                root.ref.paster.destroy();\n            }\n            if (root.ref.hopper) {\n                root.ref.hopper.destroy();\n            }\n            root.element.removeEventListener('touchmove', prevent);\n            root.element.removeEventListener('gesturestart', prevent);\n        },\n        mixins: {\n            styles: ['height'],\n        },\n    });\n\n    // creates the app\n    var createApp = function createApp() {\n        var initialOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        // let element\n        var originalElement = null;\n\n        // get default options\n        var defaultOptions = getOptions();\n\n        // create the data store, this will contain all our app info\n        var store = createStore(\n            // initial state (should be serializable)\n            createInitialState(defaultOptions),\n\n            // queries\n            [queries, createOptionQueries(defaultOptions)],\n\n            // action handlers\n            [actions, createOptionActions(defaultOptions)]\n        );\n\n        // set initial options\n        store.dispatch('SET_OPTIONS', { options: initialOptions });\n\n        // kick thread if visibility changes\n        var visibilityHandler = function visibilityHandler() {\n            if (document.hidden) return;\n            store.dispatch('KICK');\n        };\n        document.addEventListener('visibilitychange', visibilityHandler);\n\n        // re-render on window resize start and finish\n        var resizeDoneTimer = null;\n        var isResizing = false;\n        var isResizingHorizontally = false;\n        var initialWindowWidth = null;\n        var currentWindowWidth = null;\n        var resizeHandler = function resizeHandler() {\n            if (!isResizing) {\n                isResizing = true;\n            }\n            clearTimeout(resizeDoneTimer);\n            resizeDoneTimer = setTimeout(function() {\n                isResizing = false;\n                initialWindowWidth = null;\n                currentWindowWidth = null;\n                if (isResizingHorizontally) {\n                    isResizingHorizontally = false;\n                    store.dispatch('DID_STOP_RESIZE');\n                }\n            }, 500);\n        };\n        window.addEventListener('resize', resizeHandler);\n\n        // render initial view\n        var view = root(store, { id: getUniqueId() });\n\n        //\n        // PRIVATE API -------------------------------------------------------------------------------------\n        //\n        var isResting = false;\n        var isHidden = false;\n\n        var readWriteApi = {\n            // necessary for update loop\n\n            /**\n             * Reads from dom (never call manually)\n             * @private\n             */\n            _read: function _read() {\n                // test if we're resizing horizontally\n                // TODO: see if we can optimize this by measuring root rect\n                if (isResizing) {\n                    currentWindowWidth = window.innerWidth;\n                    if (!initialWindowWidth) {\n                        initialWindowWidth = currentWindowWidth;\n                    }\n\n                    if (!isResizingHorizontally && currentWindowWidth !== initialWindowWidth) {\n                        store.dispatch('DID_START_RESIZE');\n                        isResizingHorizontally = true;\n                    }\n                }\n\n                if (isHidden && isResting) {\n                    // test if is no longer hidden\n                    isResting = view.element.offsetParent === null;\n                }\n\n                // if resting, no need to read as numbers will still all be correct\n                if (isResting) return;\n\n                // read view data\n                view._read();\n\n                // if is hidden we need to know so we exit rest mode when revealed\n                isHidden = view.rect.element.hidden;\n            },\n\n            /**\n             * Writes to dom (never call manually)\n             * @private\n             */\n            _write: function _write(ts) {\n                // get all actions from store\n                var actions = store\n                    .processActionQueue()\n\n                    // filter out set actions (these will automatically trigger DID_SET)\n                    .filter(function(action) {\n                        return !/^SET_/.test(action.type);\n                    });\n\n                // if was idling and no actions stop here\n                if (isResting && !actions.length) return;\n\n                // some actions might trigger events\n                routeActionsToEvents(actions);\n\n                // update the view\n                isResting = view._write(ts, actions, isResizingHorizontally);\n\n                // will clean up all archived items\n                removeReleasedItems(store.query('GET_ITEMS'));\n\n                // now idling\n                if (isResting) {\n                    store.processDispatchQueue();\n                }\n            },\n        };\n\n        //\n        // EXPOSE EVENTS -------------------------------------------------------------------------------------\n        //\n        var createEvent = function createEvent(name) {\n            return function(data) {\n                // create default event\n                var event = {\n                    type: name,\n                };\n\n                // no data to add\n                if (!data) {\n                    return event;\n                }\n\n                // copy relevant props\n                if (data.hasOwnProperty('error')) {\n                    event.error = data.error ? Object.assign({}, data.error) : null;\n                }\n\n                if (data.status) {\n                    event.status = Object.assign({}, data.status);\n                }\n\n                if (data.file) {\n                    event.output = data.file;\n                }\n\n                // only source is available, else add item if possible\n                if (data.source) {\n                    event.file = data.source;\n                } else if (data.item || data.id) {\n                    var item = data.item ? data.item : store.query('GET_ITEM', data.id);\n                    event.file = item ? createItemAPI(item) : null;\n                }\n\n                // map all items in a possible items array\n                if (data.items) {\n                    event.items = data.items.map(createItemAPI);\n                }\n\n                // if this is a progress event add the progress amount\n                if (/progress/.test(name)) {\n                    event.progress = data.progress;\n                }\n\n                // copy relevant props\n                if (data.hasOwnProperty('origin') && data.hasOwnProperty('target')) {\n                    event.origin = data.origin;\n                    event.target = data.target;\n                }\n\n                return event;\n            };\n        };\n\n        var eventRoutes = {\n            DID_DESTROY: createEvent('destroy'),\n\n            DID_INIT: createEvent('init'),\n\n            DID_THROW_MAX_FILES: createEvent('warning'),\n\n            DID_INIT_ITEM: createEvent('initfile'),\n            DID_START_ITEM_LOAD: createEvent('addfilestart'),\n            DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent('addfileprogress'),\n            DID_LOAD_ITEM: createEvent('addfile'),\n\n            DID_THROW_ITEM_INVALID: [createEvent('error'), createEvent('addfile')],\n\n            DID_THROW_ITEM_LOAD_ERROR: [createEvent('error'), createEvent('addfile')],\n\n            DID_THROW_ITEM_REMOVE_ERROR: [createEvent('error'), createEvent('removefile')],\n\n            DID_PREPARE_OUTPUT: createEvent('preparefile'),\n\n            DID_START_ITEM_PROCESSING: createEvent('processfilestart'),\n            DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent('processfileprogress'),\n            DID_ABORT_ITEM_PROCESSING: createEvent('processfileabort'),\n            DID_COMPLETE_ITEM_PROCESSING: createEvent('processfile'),\n            DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent('processfiles'),\n            DID_REVERT_ITEM_PROCESSING: createEvent('processfilerevert'),\n\n            DID_THROW_ITEM_PROCESSING_ERROR: [createEvent('error'), createEvent('processfile')],\n\n            DID_REMOVE_ITEM: createEvent('removefile'),\n\n            DID_UPDATE_ITEMS: createEvent('updatefiles'),\n\n            DID_ACTIVATE_ITEM: createEvent('activatefile'),\n\n            DID_REORDER_ITEMS: createEvent('reorderfiles'),\n        };\n\n        var exposeEvent = function exposeEvent(event) {\n            // create event object to be dispatched\n            var detail = Object.assign({ pond: exports }, event);\n            delete detail.type;\n            view.element.dispatchEvent(\n                new CustomEvent('FilePond:' + event.type, {\n                    // event info\n                    detail: detail,\n\n                    // event behaviour\n                    bubbles: true,\n                    cancelable: true,\n                    composed: true, // triggers listeners outside of shadow root\n                })\n            );\n\n            // event object to params used for `on()` event handlers and callbacks `oninit()`\n            var params = [];\n\n            // if is possible error event, make it the first param\n            if (event.hasOwnProperty('error')) {\n                params.push(event.error);\n            }\n\n            // file is always section\n            if (event.hasOwnProperty('file')) {\n                params.push(event.file);\n            }\n\n            // append other props\n            var filtered = ['type', 'error', 'file'];\n            Object.keys(event)\n                .filter(function(key) {\n                    return !filtered.includes(key);\n                })\n                .forEach(function(key) {\n                    return params.push(event[key]);\n                });\n\n            // on(type, () => { })\n            exports.fire.apply(exports, [event.type].concat(params));\n\n            // oninit = () => {}\n            var handler = store.query('GET_ON' + event.type.toUpperCase());\n            if (handler) {\n                handler.apply(void 0, params);\n            }\n        };\n\n        var routeActionsToEvents = function routeActionsToEvents(actions) {\n            if (!actions.length) return;\n            actions\n                .filter(function(action) {\n                    return eventRoutes[action.type];\n                })\n                .forEach(function(action) {\n                    var routes = eventRoutes[action.type];\n                    (Array.isArray(routes) ? routes : [routes]).forEach(function(route) {\n                        // this isn't fantastic, but because of the stacking of settimeouts plugins can handle the did_load before the did_init\n                        if (action.type === 'DID_INIT_ITEM') {\n                            exposeEvent(route(action.data));\n                        } else {\n                            setTimeout(function() {\n                                exposeEvent(route(action.data));\n                            }, 0);\n                        }\n                    });\n                });\n        };\n\n        //\n        // PUBLIC API -------------------------------------------------------------------------------------\n        //\n        var setOptions = function setOptions(options) {\n            return store.dispatch('SET_OPTIONS', { options: options });\n        };\n\n        var getFile = function getFile(query) {\n            return store.query('GET_ACTIVE_ITEM', query);\n        };\n\n        var prepareFile = function prepareFile(query) {\n            return new Promise(function(resolve, reject) {\n                store.dispatch('REQUEST_ITEM_PREPARE', {\n                    query: query,\n                    success: function success(item) {\n                        resolve(item);\n                    },\n                    failure: function failure(error) {\n                        reject(error);\n                    },\n                });\n            });\n        };\n\n        var addFile = function addFile(source) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return new Promise(function(resolve, reject) {\n                addFiles([{ source: source, options: options }], { index: options.index })\n                    .then(function(items) {\n                        return resolve(items && items[0]);\n                    })\n                    .catch(reject);\n            });\n        };\n\n        var isFilePondFile = function isFilePondFile(obj) {\n            return obj.file && obj.id;\n        };\n\n        var removeFile = function removeFile(query, options) {\n            // if only passed options\n            if (typeof query === 'object' && !isFilePondFile(query) && !options) {\n                options = query;\n                query = undefined;\n            }\n\n            // request item removal\n            store.dispatch('REMOVE_ITEM', Object.assign({}, options, { query: query }));\n\n            // see if item has been removed\n            return store.query('GET_ACTIVE_ITEM', query) === null;\n        };\n\n        var addFiles = function addFiles() {\n            for (\n                var _len = arguments.length, args = new Array(_len), _key = 0;\n                _key < _len;\n                _key++\n            ) {\n                args[_key] = arguments[_key];\n            }\n            return new Promise(function(resolve, reject) {\n                var sources = [];\n                var options = {};\n\n                // user passed a sources array\n                if (isArray(args[0])) {\n                    sources.push.apply(sources, args[0]);\n                    Object.assign(options, args[1] || {});\n                } else {\n                    // user passed sources as arguments, last one might be options object\n                    var lastArgument = args[args.length - 1];\n                    if (typeof lastArgument === 'object' && !(lastArgument instanceof Blob)) {\n                        Object.assign(options, args.pop());\n                    }\n\n                    // add rest to sources\n                    sources.push.apply(sources, args);\n                }\n\n                store.dispatch('ADD_ITEMS', {\n                    items: sources,\n                    index: options.index,\n                    interactionMethod: InteractionMethod.API,\n                    success: resolve,\n                    failure: reject,\n                });\n            });\n        };\n\n        var getFiles = function getFiles() {\n            return store.query('GET_ACTIVE_ITEMS');\n        };\n\n        var processFile = function processFile(query) {\n            return new Promise(function(resolve, reject) {\n                store.dispatch('REQUEST_ITEM_PROCESSING', {\n                    query: query,\n                    success: function success(item) {\n                        resolve(item);\n                    },\n                    failure: function failure(error) {\n                        reject(error);\n                    },\n                });\n            });\n        };\n\n        var prepareFiles = function prepareFiles() {\n            for (\n                var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;\n                _key2 < _len2;\n                _key2++\n            ) {\n                args[_key2] = arguments[_key2];\n            }\n            var queries = Array.isArray(args[0]) ? args[0] : args;\n            var items = queries.length ? queries : getFiles();\n            return Promise.all(items.map(prepareFile));\n        };\n\n        var processFiles = function processFiles() {\n            for (\n                var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;\n                _key3 < _len3;\n                _key3++\n            ) {\n                args[_key3] = arguments[_key3];\n            }\n            var queries = Array.isArray(args[0]) ? args[0] : args;\n            if (!queries.length) {\n                var files = getFiles().filter(function(item) {\n                    return (\n                        !(item.status === ItemStatus.IDLE && item.origin === FileOrigin.LOCAL) &&\n                        item.status !== ItemStatus.PROCESSING &&\n                        item.status !== ItemStatus.PROCESSING_COMPLETE &&\n                        item.status !== ItemStatus.PROCESSING_REVERT_ERROR\n                    );\n                });\n\n                return Promise.all(files.map(processFile));\n            }\n            return Promise.all(queries.map(processFile));\n        };\n\n        var removeFiles = function removeFiles() {\n            for (\n                var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;\n                _key4 < _len4;\n                _key4++\n            ) {\n                args[_key4] = arguments[_key4];\n            }\n\n            var queries = Array.isArray(args[0]) ? args[0] : args;\n\n            var options;\n            if (typeof queries[queries.length - 1] === 'object') {\n                options = queries.pop();\n            } else if (Array.isArray(args[0])) {\n                options = args[1];\n            }\n\n            var files = getFiles();\n\n            if (!queries.length)\n                return Promise.all(\n                    files.map(function(file) {\n                        return removeFile(file, options);\n                    })\n                );\n\n            // when removing by index the indexes shift after each file removal so we need to convert indexes to ids\n            var mappedQueries = queries\n                .map(function(query) {\n                    return isNumber(query) ? (files[query] ? files[query].id : null) : query;\n                })\n                .filter(function(query) {\n                    return query;\n                });\n\n            return mappedQueries.map(function(q) {\n                return removeFile(q, options);\n            });\n        };\n\n        var exports = Object.assign(\n            {},\n\n            on(),\n            {},\n\n            readWriteApi,\n            {},\n\n            createOptionAPI(store, defaultOptions),\n            {\n                /**\n                 * Override options defined in options object\n                 * @param options\n                 */\n                setOptions: setOptions,\n\n                /**\n                 * Load the given file\n                 * @param source - the source of the file (either a File, base64 data uri or url)\n                 * @param options - object, { index: 0 }\n                 */\n                addFile: addFile,\n\n                /**\n                 * Load the given files\n                 * @param sources - the sources of the files to load\n                 * @param options - object, { index: 0 }\n                 */\n                addFiles: addFiles,\n\n                /**\n                 * Returns the file objects matching the given query\n                 * @param query { string, number, null }\n                 */\n                getFile: getFile,\n\n                /**\n                 * Upload file with given name\n                 * @param query { string, number, null  }\n                 */\n                processFile: processFile,\n\n                /**\n                 * Request prepare output for file with given name\n                 * @param query { string, number, null  }\n                 */\n                prepareFile: prepareFile,\n\n                /**\n                 * Removes a file by its name\n                 * @param query { string, number, null  }\n                 */\n                removeFile: removeFile,\n\n                /**\n                 * Moves a file to a new location in the files list\n                 */\n                moveFile: function moveFile(query, index) {\n                    return store.dispatch('MOVE_ITEM', { query: query, index: index });\n                },\n\n                /**\n                 * Returns all files (wrapped in public api)\n                 */\n                getFiles: getFiles,\n\n                /**\n                 * Starts uploading all files\n                 */\n                processFiles: processFiles,\n\n                /**\n                 * Clears all files from the files list\n                 */\n                removeFiles: removeFiles,\n\n                /**\n                 * Starts preparing output of all files\n                 */\n                prepareFiles: prepareFiles,\n\n                /**\n                 * Sort list of files\n                 */\n                sort: function sort(compare) {\n                    return store.dispatch('SORT', { compare: compare });\n                },\n\n                /**\n                 * Browse the file system for a file\n                 */\n                browse: function browse() {\n                    // needs to be trigger directly as user action needs to be traceable (is not traceable in requestAnimationFrame)\n                    var input = view.element.querySelector('input[type=file]');\n                    if (input) {\n                        input.click();\n                    }\n                },\n\n                /**\n                 * Destroys the app\n                 */\n                destroy: function destroy() {\n                    // request destruction\n                    exports.fire('destroy', view.element);\n\n                    // stop active processes (file uploads, fetches, stuff like that)\n                    // loop over items and depending on states call abort for ongoing processes\n                    store.dispatch('ABORT_ALL');\n\n                    // destroy view\n                    view._destroy();\n\n                    // stop listening to resize\n                    window.removeEventListener('resize', resizeHandler);\n\n                    // stop listening to the visiblitychange event\n                    document.removeEventListener('visibilitychange', visibilityHandler);\n\n                    // dispatch destroy\n                    store.dispatch('DID_DESTROY');\n                },\n\n                /**\n                 * Inserts the plugin before the target element\n                 */\n                insertBefore: function insertBefore$1(element) {\n                    return insertBefore(view.element, element);\n                },\n\n                /**\n                 * Inserts the plugin after the target element\n                 */\n                insertAfter: function insertAfter$1(element) {\n                    return insertAfter(view.element, element);\n                },\n\n                /**\n                 * Appends the plugin to the target element\n                 */\n                appendTo: function appendTo(element) {\n                    return element.appendChild(view.element);\n                },\n\n                /**\n                 * Replaces an element with the app\n                 */\n                replaceElement: function replaceElement(element) {\n                    // insert the app before the element\n                    insertBefore(view.element, element);\n\n                    // remove the original element\n                    element.parentNode.removeChild(element);\n\n                    // remember original element\n                    originalElement = element;\n                },\n\n                /**\n                 * Restores the original element\n                 */\n                restoreElement: function restoreElement() {\n                    if (!originalElement) {\n                        return; // no element to restore\n                    }\n\n                    // restore original element\n                    insertAfter(originalElement, view.element);\n\n                    // remove our element\n                    view.element.parentNode.removeChild(view.element);\n\n                    // remove reference\n                    originalElement = null;\n                },\n\n                /**\n                 * Returns true if the app root is attached to given element\n                 * @param element\n                 */\n                isAttachedTo: function isAttachedTo(element) {\n                    return view.element === element || originalElement === element;\n                },\n\n                /**\n                 * Returns the root element\n                 */\n                element: {\n                    get: function get() {\n                        return view.element;\n                    },\n                },\n\n                /**\n                 * Returns the current pond status\n                 */\n                status: {\n                    get: function get() {\n                        return store.query('GET_STATUS');\n                    },\n                },\n            }\n        );\n\n        // Done!\n        store.dispatch('DID_INIT');\n\n        // create actual api object\n        return createObject(exports);\n    };\n\n    var createAppObject = function createAppObject() {\n        var customOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        // default options\n        var defaultOptions = {};\n        forin(getOptions(), function(key, value) {\n            defaultOptions[key] = value[0];\n        });\n\n        // set app options\n        var app = createApp(\n            Object.assign(\n                {},\n\n                defaultOptions,\n                {},\n\n                customOptions\n            )\n        );\n\n        // return the plugin instance\n        return app;\n    };\n\n    var lowerCaseFirstLetter = function lowerCaseFirstLetter(string) {\n        return string.charAt(0).toLowerCase() + string.slice(1);\n    };\n\n    var attributeNameToPropertyName = function attributeNameToPropertyName(attributeName) {\n        return toCamels(attributeName.replace(/^data-/, ''));\n    };\n\n    var mapObject = function mapObject(object, propertyMap) {\n        // remove unwanted\n        forin(propertyMap, function(selector, mapping) {\n            forin(object, function(property, value) {\n                // create regexp shortcut\n                var selectorRegExp = new RegExp(selector);\n\n                // tests if\n                var matches = selectorRegExp.test(property);\n\n                // no match, skip\n                if (!matches) {\n                    return;\n                }\n\n                // if there's a mapping, the original property is always removed\n                delete object[property];\n\n                // should only remove, we done!\n                if (mapping === false) {\n                    return;\n                }\n\n                // move value to new property\n                if (isString(mapping)) {\n                    object[mapping] = value;\n                    return;\n                }\n\n                // move to group\n                var group = mapping.group;\n                if (isObject(mapping) && !object[group]) {\n                    object[group] = {};\n                }\n\n                object[group][lowerCaseFirstLetter(property.replace(selectorRegExp, ''))] = value;\n            });\n\n            // do submapping\n            if (mapping.mapping) {\n                mapObject(object[mapping.group], mapping.mapping);\n            }\n        });\n    };\n\n    var getAttributesAsObject = function getAttributesAsObject(node) {\n        var attributeMapping =\n            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        // turn attributes into object\n        var attributes = [];\n        forin(node.attributes, function(index) {\n            attributes.push(node.attributes[index]);\n        });\n\n        var output = attributes\n            .filter(function(attribute) {\n                return attribute.name;\n            })\n            .reduce(function(obj, attribute) {\n                var value = attr(node, attribute.name);\n\n                obj[attributeNameToPropertyName(attribute.name)] =\n                    value === attribute.name ? true : value;\n                return obj;\n            }, {});\n\n        // do mapping of object properties\n        mapObject(output, attributeMapping);\n\n        return output;\n    };\n\n    var createAppAtElement = function createAppAtElement(element) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        // how attributes of the input element are mapped to the options for the plugin\n        var attributeMapping = {\n            // translate to other name\n            '^class$': 'className',\n            '^multiple$': 'allowMultiple',\n            '^capture$': 'captureMethod',\n            '^webkitdirectory$': 'allowDirectoriesOnly',\n\n            // group under single property\n            '^server': {\n                group: 'server',\n                mapping: {\n                    '^process': {\n                        group: 'process',\n                    },\n\n                    '^revert': {\n                        group: 'revert',\n                    },\n\n                    '^fetch': {\n                        group: 'fetch',\n                    },\n\n                    '^restore': {\n                        group: 'restore',\n                    },\n\n                    '^load': {\n                        group: 'load',\n                    },\n                },\n            },\n\n            // don't include in object\n            '^type$': false,\n            '^files$': false,\n        };\n\n        // add additional option translators\n        applyFilters('SET_ATTRIBUTE_TO_OPTION_MAP', attributeMapping);\n\n        // create final options object by setting options object and then overriding options supplied on element\n        var mergedOptions = Object.assign({}, options);\n\n        var attributeOptions = getAttributesAsObject(\n            element.nodeName === 'FIELDSET' ? element.querySelector('input[type=file]') : element,\n            attributeMapping\n        );\n\n        // merge with options object\n        Object.keys(attributeOptions).forEach(function(key) {\n            if (isObject(attributeOptions[key])) {\n                if (!isObject(mergedOptions[key])) {\n                    mergedOptions[key] = {};\n                }\n                Object.assign(mergedOptions[key], attributeOptions[key]);\n            } else {\n                mergedOptions[key] = attributeOptions[key];\n            }\n        });\n\n        // if parent is a fieldset, get files from parent by selecting all input fields that are not file upload fields\n        // these will then be automatically set to the initial files\n        mergedOptions.files = (options.files || []).concat(\n            Array.from(element.querySelectorAll('input:not([type=file])')).map(function(input) {\n                return {\n                    source: input.value,\n                    options: {\n                        type: input.dataset.type,\n                    },\n                };\n            })\n        );\n\n        // build plugin\n        var app = createAppObject(mergedOptions);\n\n        // add already selected files\n        if (element.files) {\n            Array.from(element.files).forEach(function(file) {\n                app.addFile(file);\n            });\n        }\n\n        // replace the target element\n        app.replaceElement(element);\n\n        // expose\n        return app;\n    };\n\n    // if an element is passed, we create the instance at that element, if not, we just create an up object\n    var createApp$1 = function createApp() {\n        return isNode(arguments.length <= 0 ? undefined : arguments[0])\n            ? createAppAtElement.apply(void 0, arguments)\n            : createAppObject.apply(void 0, arguments);\n    };\n\n    var PRIVATE_METHODS = ['fire', '_read', '_write'];\n\n    var createAppAPI = function createAppAPI(app) {\n        var api = {};\n\n        copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);\n\n        return api;\n    };\n\n    /**\n     * Replaces placeholders in given string with replacements\n     * @param string - \"Foo {bar}\"\"\n     * @param replacements - { \"bar\": 10 }\n     */\n    var replaceInString = function replaceInString(string, replacements) {\n        return string.replace(/(?:{([a-zA-Z]+)})/g, function(match, group) {\n            return replacements[group];\n        });\n    };\n\n    var createWorker = function createWorker(fn) {\n        var workerBlob = new Blob(['(', fn.toString(), ')()'], {\n            type: 'application/javascript',\n        });\n\n        var workerURL = URL.createObjectURL(workerBlob);\n        var worker = new Worker(workerURL);\n\n        return {\n            transfer: function transfer(message, cb) {},\n            post: function post(message, cb, transferList) {\n                var id = getUniqueId();\n\n                worker.onmessage = function(e) {\n                    if (e.data.id === id) {\n                        cb(e.data.message);\n                    }\n                };\n\n                worker.postMessage(\n                    {\n                        id: id,\n                        message: message,\n                    },\n\n                    transferList\n                );\n            },\n            terminate: function terminate() {\n                worker.terminate();\n                URL.revokeObjectURL(workerURL);\n            },\n        };\n    };\n\n    var loadImage = function loadImage(url) {\n        return new Promise(function(resolve, reject) {\n            var img = new Image();\n            img.onload = function() {\n                resolve(img);\n            };\n            img.onerror = function(e) {\n                reject(e);\n            };\n            img.src = url;\n        });\n    };\n\n    var renameFile = function renameFile(file, name) {\n        var renamedFile = file.slice(0, file.size, file.type);\n        renamedFile.lastModifiedDate = file.lastModifiedDate;\n        renamedFile.name = name;\n        return renamedFile;\n    };\n\n    var copyFile = function copyFile(file) {\n        return renameFile(file, file.name);\n    };\n\n    // already registered plugins (can't register twice)\n    var registeredPlugins = [];\n\n    // pass utils to plugin\n    var createAppPlugin = function createAppPlugin(plugin) {\n        // already registered\n        if (registeredPlugins.includes(plugin)) {\n            return;\n        }\n\n        // remember this plugin\n        registeredPlugins.push(plugin);\n\n        // setup!\n        var pluginOutline = plugin({\n            addFilter: addFilter,\n            utils: {\n                Type: Type,\n                forin: forin,\n                isString: isString,\n                isFile: isFile,\n                toNaturalFileSize: toNaturalFileSize,\n                replaceInString: replaceInString,\n                getExtensionFromFilename: getExtensionFromFilename,\n                getFilenameWithoutExtension: getFilenameWithoutExtension,\n                guesstimateMimeType: guesstimateMimeType,\n                getFileFromBlob: getFileFromBlob,\n                getFilenameFromURL: getFilenameFromURL,\n                createRoute: createRoute,\n                createWorker: createWorker,\n                createView: createView,\n                createItemAPI: createItemAPI,\n                loadImage: loadImage,\n                copyFile: copyFile,\n                renameFile: renameFile,\n                createBlob: createBlob,\n                applyFilterChain: applyFilterChain,\n                text: text,\n                getNumericAspectRatioFromString: getNumericAspectRatioFromString,\n            },\n\n            views: {\n                fileActionButton: fileActionButton,\n            },\n        });\n\n        // add plugin options to default options\n        extendDefaultOptions(pluginOutline.options);\n    };\n\n    // feature detection used by supported() method\n    var isOperaMini = function isOperaMini() {\n        return Object.prototype.toString.call(window.operamini) === '[object OperaMini]';\n    };\n    var hasPromises = function hasPromises() {\n        return 'Promise' in window;\n    };\n    var hasBlobSlice = function hasBlobSlice() {\n        return 'slice' in Blob.prototype;\n    };\n    var hasCreateObjectURL = function hasCreateObjectURL() {\n        return 'URL' in window && 'createObjectURL' in window.URL;\n    };\n    var hasVisibility = function hasVisibility() {\n        return 'visibilityState' in document;\n    };\n    var hasTiming = function hasTiming() {\n        return 'performance' in window;\n    }; // iOS 8.x\n    var hasCSSSupports = function hasCSSSupports() {\n        return 'supports' in (window.CSS || {});\n    }; // use to detect Safari 9+\n    var isIE11 = function isIE11() {\n        return /MSIE|Trident/.test(window.navigator.userAgent);\n    };\n\n    var supported = (function() {\n        // Runs immediately and then remembers result for subsequent calls\n        var isSupported =\n            // Has to be a browser\n            isBrowser() &&\n            // Can't run on Opera Mini due to lack of everything\n            !isOperaMini() &&\n            // Require these APIs to feature detect a modern browser\n            hasVisibility() &&\n            hasPromises() &&\n            hasBlobSlice() &&\n            hasCreateObjectURL() &&\n            hasTiming() &&\n            // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)\n            (hasCSSSupports() || isIE11());\n\n        return function() {\n            return isSupported;\n        };\n    })();\n\n    /**\n     * Plugin internal state (over all instances)\n     */\n    var state = {\n        // active app instances, used to redraw the apps and to find the later\n        apps: [],\n    };\n\n    // plugin name\n    var name = 'filepond';\n\n    /**\n     * Public Plugin methods\n     */\n    var fn = function fn() {};\n    exports.Status = {};\n    exports.FileStatus = {};\n    exports.FileOrigin = {};\n    exports.OptionTypes = {};\n    exports.create = fn;\n    exports.destroy = fn;\n    exports.parse = fn;\n    exports.find = fn;\n    exports.registerPlugin = fn;\n    exports.getOptions = fn;\n    exports.setOptions = fn;\n\n    // if not supported, no API\n    if (supported()) {\n        // start painter and fire load event\n        createPainter(\n            function() {\n                state.apps.forEach(function(app) {\n                    return app._read();\n                });\n            },\n            function(ts) {\n                state.apps.forEach(function(app) {\n                    return app._write(ts);\n                });\n            }\n        );\n\n        // fire loaded event so we know when FilePond is available\n        var dispatch = function dispatch() {\n            // let others know we have area ready\n            document.dispatchEvent(\n                new CustomEvent('FilePond:loaded', {\n                    detail: {\n                        supported: supported,\n                        create: exports.create,\n                        destroy: exports.destroy,\n                        parse: exports.parse,\n                        find: exports.find,\n                        registerPlugin: exports.registerPlugin,\n                        setOptions: exports.setOptions,\n                    },\n                })\n            );\n\n            // clean up event\n            document.removeEventListener('DOMContentLoaded', dispatch);\n        };\n\n        if (document.readyState !== 'loading') {\n            // move to back of execution queue, FilePond should have been exported by then\n            setTimeout(function() {\n                return dispatch();\n            }, 0);\n        } else {\n            document.addEventListener('DOMContentLoaded', dispatch);\n        }\n\n        // updates the OptionTypes object based on the current options\n        var updateOptionTypes = function updateOptionTypes() {\n            return forin(getOptions(), function(key, value) {\n                exports.OptionTypes[key] = value[1];\n            });\n        };\n\n        exports.Status = Object.assign({}, Status);\n        exports.FileOrigin = Object.assign({}, FileOrigin);\n        exports.FileStatus = Object.assign({}, ItemStatus);\n\n        exports.OptionTypes = {};\n        updateOptionTypes();\n\n        // create method, creates apps and adds them to the app array\n        exports.create = function create() {\n            var app = createApp$1.apply(void 0, arguments);\n            app.on('destroy', exports.destroy);\n            state.apps.push(app);\n            return createAppAPI(app);\n        };\n\n        // destroys apps and removes them from the app array\n        exports.destroy = function destroy(hook) {\n            // returns true if the app was destroyed successfully\n            var indexToRemove = state.apps.findIndex(function(app) {\n                return app.isAttachedTo(hook);\n            });\n            if (indexToRemove >= 0) {\n                // remove from apps\n                var app = state.apps.splice(indexToRemove, 1)[0];\n\n                // restore original dom element\n                app.restoreElement();\n\n                return true;\n            }\n\n            return false;\n        };\n\n        // parses the given context for plugins (does not include the context element itself)\n        exports.parse = function parse(context) {\n            // get all possible hooks\n            var matchedHooks = Array.from(context.querySelectorAll('.' + name));\n\n            // filter out already active hooks\n            var newHooks = matchedHooks.filter(function(newHook) {\n                return !state.apps.find(function(app) {\n                    return app.isAttachedTo(newHook);\n                });\n            });\n\n            // create new instance for each hook\n            return newHooks.map(function(hook) {\n                return exports.create(hook);\n            });\n        };\n\n        // returns an app based on the given element hook\n        exports.find = function find(hook) {\n            var app = state.apps.find(function(app) {\n                return app.isAttachedTo(hook);\n            });\n            if (!app) {\n                return null;\n            }\n            return createAppAPI(app);\n        };\n\n        // adds a plugin extension\n        exports.registerPlugin = function registerPlugin() {\n            for (\n                var _len = arguments.length, plugins = new Array(_len), _key = 0;\n                _key < _len;\n                _key++\n            ) {\n                plugins[_key] = arguments[_key];\n            }\n\n            // register plugins\n            plugins.forEach(createAppPlugin);\n\n            // update OptionTypes, each plugin might have extended the default options\n            updateOptionTypes();\n        };\n\n        exports.getOptions = function getOptions$1() {\n            var opts = {};\n            forin(getOptions(), function(key, value) {\n                opts[key] = value[0];\n            });\n            return opts;\n        };\n\n        exports.setOptions = function setOptions$1(opts) {\n            if (isObject(opts)) {\n                // update existing plugins\n                state.apps.forEach(function(app) {\n                    app.setOptions(opts);\n                });\n\n                // override defaults\n                setOptions(opts);\n            }\n\n            // return new options\n            return exports.getOptions();\n        };\n    }\n\n    exports.supported = supported;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRTtBQUNBLFVBQVUsQ0FFNEQ7QUFDdEUsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3QkFBd0I7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGtCQUFrQjtBQUM3RCxTQUFTOztBQUVUO0FBQ0E7QUFDQSw2Q0FBNkMsb0NBQW9DO0FBQ2pGLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQywyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhOztBQUVuQztBQUNBLGtEQUFrRCwyQkFBMkI7QUFDN0U7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFD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NkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7O0FBRTFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCwrQkFBK0I7QUFDckY7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0REFBNEQsa0NBQWtDO0FBQzlGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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QWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCx3QkFBd0IsMkJBQTJCO0FBQ25HO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsSUFBSSxJQUFJO0FBQzVELGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLGdEQUFnRDtBQUNoRCx3Q0FBd0M7QUFDeEMsOENBQThDO0FBQzlDLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxhQUFhO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsdUJBQXVCOztBQUV2QixnREFBZ0Q7QUFDaEQ7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RCxhQUFhOztBQUViO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQTRDOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDBDQUEwQztBQUMzRixpQkFBaUI7QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsVUFBVSxZQUFZO0FBQzlFLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRSxjQUFjOztBQUV4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esd0RBQXdELFVBQVUsWUFBWTtBQUM5RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUwsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsY0FBYztBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEOztBQUVBO0FBQ0EsNEVBQTRFLG9CQUFvQjs7QUFFaEc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZDQUE2QyxvQ0FBb0M7O0FBRWpGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxvQ0FBb0M7QUFDckY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsb0NBQW9DOztBQUVyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBNEM7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxRQUFROztBQUVwRDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsMkJBQTJCOztBQUVoRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0QztBQUM5RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw0Q0FBNEM7O0FBRTlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4Q0FBOEM7QUFDcEUsU0FBUztBQUNULDhCQUE4QixzQkFBc0IsMkNBQTJDO0FBQy9GO0FBQ0E7QUFDQSxzQkFBc0IsaURBQWlEO0FBQ3ZFLFNBQVM7QUFDVCx5QkFBeUIsWUFBWTtBQUNyQyx5QkFBeUIsc0JBQXNCLHFDQUFxQztBQUNwRiwyQkFBMkIsc0JBQXNCLDJDQUEyQzs7QUFFNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOEJBQThCO0FBQ3pEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOEJBQThCO0FBQ3pELGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0QztBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsMENBQTBDO0FBQzFDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLDhDQUE4QztBQUM5Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHdDQUF3QztBQUN4QyxrREFBa0Q7QUFDbEQsd0NBQXdDO0FBQ3hDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isd0NBQXdDO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0I7QUFDbkU7O0FBRUE7QUFDQSw0RUFBNEUsb0JBQW9COztBQUVoRztBQUNBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0Esd0ZBQXdGOztBQUV4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0Qzs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtREFBbUQsYUFBYTtBQUNoRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5qcz9jMDYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRmlsZVBvbmQgNC4zMS4xXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xuICogUGxlYXNlIHZpc2l0IGh0dHBzOi8vcHFpbmEubmwvZmlsZXBvbmQvIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBmYWN0b3J5KGV4cG9ydHMpXG4gICAgICAgIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgICAgID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KVxuICAgICAgICA6ICgoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYpLCBmYWN0b3J5KChnbG9iYWwuRmlsZVBvbmQgPSB7fSkpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaXNOb2RlID0gZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlU3RvcmUgPSBmdW5jdGlvbiBjcmVhdGVTdG9yZShpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgdmFyIHF1ZXJpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgICAgIHZhciBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG5cbiAgICAgICAgLy8gY29udGFpbnMgYWxsIGFjdGlvbnMgZm9yIG5leHQgZnJhbWUsIGlzIGNsZWFyIHdoZW4gYWN0aW9ucyBhcmUgcmVxdWVzdGVkXG4gICAgICAgIHZhciBhY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuXG4gICAgICAgIC8vIHJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgdmFyIGdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhlIGFjdGlvbnMgYXJyYXkgYW5kIGNsZWFycyB0aGUgYWN0aW9ucyBhcnJheVxuICAgICAgICB2YXIgcHJvY2Vzc0FjdGlvblF1ZXVlID0gZnVuY3Rpb24gcHJvY2Vzc0FjdGlvblF1ZXVlKCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGNvcHkgb2YgYWN0aW9ucyBxdWV1ZVxuICAgICAgICAgICAgdmFyIHF1ZXVlID0gW10uY29uY2F0KGFjdGlvblF1ZXVlKTtcblxuICAgICAgICAgICAgLy8gY2xlYXIgYWN0aW9ucyBxdWV1ZSAod2UgZG9uJ3Qgd2FudCBubyBkb3VibGUgYWN0aW9ucylcbiAgICAgICAgICAgIGFjdGlvblF1ZXVlLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiBxdWV1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwcm9jZXNzZXMgYWN0aW9ucyB0aGF0IG1pZ2h0IGJsb2NrIHRoZSBtYWluIFVJIHRocmVhZFxuICAgICAgICB2YXIgcHJvY2Vzc0Rpc3BhdGNoUXVldWUgPSBmdW5jdGlvbiBwcm9jZXNzRGlzcGF0Y2hRdWV1ZSgpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBjb3B5IG9mIGFjdGlvbnMgcXVldWVcbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IFtdLmNvbmNhdChkaXNwYXRjaFF1ZXVlKTtcblxuICAgICAgICAgICAgLy8gY2xlYXIgYWN0aW9ucyBxdWV1ZSAod2UgZG9uJ3Qgd2FudCBubyBkb3VibGUgYWN0aW9ucylcbiAgICAgICAgICAgIGRpc3BhdGNoUXVldWUubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgLy8gbm93IGRpc3BhdGNoIHRoZXNlIGFjdGlvbnNcbiAgICAgICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24oX3JlZikge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHR5cGUsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYWRkcyBhIG5ldyBhY3Rpb24sIGNhbGxzIGl0cyBoYW5kbGVyIGFuZFxuICAgICAgICB2YXIgZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCh0eXBlLCBkYXRhLCBpc0Jsb2NraW5nKSB7XG4gICAgICAgICAgICAvLyBpcyBibG9ja2luZyBhY3Rpb24gKHNob3VsZCBuZXZlciBibG9jayBpZiBkb2N1bWVudCBpcyBoaWRkZW4pXG4gICAgICAgICAgICBpZiAoaXNCbG9ja2luZyAmJiAhZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgYWN0aW9uIGhhcyBhIGhhbmRsZXIsIGhhbmRsZSB0aGUgYWN0aW9uXG4gICAgICAgICAgICBpZiAoYWN0aW9uSGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25IYW5kbGVyc1t0eXBlXShkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm93IGFkZCBhY3Rpb25cbiAgICAgICAgICAgIGFjdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBxdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KHN0cikge1xuICAgICAgICAgICAgdmFyIF9xdWVyeUhhbmRsZXM7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxO1xuICAgICAgICAgICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICAgICAgICAgIF9rZXkrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcXVlcnlIYW5kbGVzW3N0cl1cbiAgICAgICAgICAgICAgICA/IChfcXVlcnlIYW5kbGVzID0gcXVlcnlIYW5kbGVzKVtzdHJdLmFwcGx5KF9xdWVyeUhhbmRsZXMsIGFyZ3MpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcGkgPSB7XG4gICAgICAgICAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgICAgICAgICBwcm9jZXNzQWN0aW9uUXVldWU6IHByb2Nlc3NBY3Rpb25RdWV1ZSxcbiAgICAgICAgICAgIHByb2Nlc3NEaXNwYXRjaFF1ZXVlOiBwcm9jZXNzRGlzcGF0Y2hRdWV1ZSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcXVlcnlIYW5kbGVzID0ge307XG4gICAgICAgIHF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICAgICAgcXVlcnlIYW5kbGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcXVlcnkoc3RhdGUpLCB7fSwgcXVlcnlIYW5kbGVzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFjdGlvbkhhbmRsZXJzID0ge307XG4gICAgICAgIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgIGFjdGlvbkhhbmRsZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uKGRpc3BhdGNoLCBxdWVyeSwgc3RhdGUpLCB7fSwgYWN0aW9uSGFuZGxlcnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCBkZWZpbml0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqW3Byb3BlcnR5XSA9IGRlZmluaXRpb247XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIE9iamVjdC5hc3NpZ24oe30sIGRlZmluaXRpb24pKTtcbiAgICB9O1xuXG4gICAgdmFyIGZvcmluID0gZnVuY3Rpb24gZm9yaW4ob2JqLCBjYikge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNiKGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVPYmplY3QgPSBmdW5jdGlvbiBjcmVhdGVPYmplY3QoZGVmaW5pdGlvbikge1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIGZvcmluKGRlZmluaXRpb24sIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCBkZWZpbml0aW9uW3Byb3BlcnR5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICB2YXIgYXR0ciA9IGZ1bmN0aW9uIGF0dHIobm9kZSwgbmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgdmFyIG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICB2YXIgc3ZnRWxlbWVudHMgPSBbJ3N2ZycsICdwYXRoJ107IC8vIG9ubHkgc3ZnIGVsZW1lbnRzIHVzZWRcblxuICAgIHZhciBpc1NWR0VsZW1lbnQgPSBmdW5jdGlvbiBpc1NWR0VsZW1lbnQodGFnKSB7XG4gICAgICAgIHJldHVybiBzdmdFbGVtZW50cy5pbmNsdWRlcyh0YWcpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gaXNTVkdFbGVtZW50KHRhZylcbiAgICAgICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpXG4gICAgICAgICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzU1ZHRWxlbWVudCh0YWcpKSB7XG4gICAgICAgICAgICAgICAgYXR0cihlbGVtZW50LCAnY2xhc3MnLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3JpbihhdHRyaWJ1dGVzLCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgYXR0cihlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuXG4gICAgdmFyIGFwcGVuZENoaWxkID0gZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICd1bmRlZmluZWQnICYmIHBhcmVudC5jaGlsZHJlbltpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBwYXJlbnQuY2hpbGRyZW5baW5kZXhdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGFwcGVuZENoaWxkVmlldyA9IGZ1bmN0aW9uIGFwcGVuZENoaWxkVmlldyhwYXJlbnQsIGNoaWxkVmlld3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZpZXcsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNoaWxkVmlld3Muc3BsaWNlKGluZGV4LCAwLCB2aWV3KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmlldztcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZUNoaWxkVmlldyA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkVmlldyhwYXJlbnQsIGNoaWxkVmlld3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIGNoaWxkIHZpZXdzXG4gICAgICAgICAgICBjaGlsZFZpZXdzLnNwbGljZShjaGlsZFZpZXdzLmluZGV4T2YodmlldyksIDEpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICh2aWV3LmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh2aWV3LmVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmlldztcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIElTX0JST1dTRVIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbiAgICB9KSgpO1xuICAgIHZhciBpc0Jyb3dzZXIgPSBmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgICAgIHJldHVybiBJU19CUk9XU0VSO1xuICAgIH07XG5cbiAgICB2YXIgdGVzdEVsZW1lbnQgPSBpc0Jyb3dzZXIoKSA/IGNyZWF0ZUVsZW1lbnQoJ3N2ZycpIDoge307XG4gICAgdmFyIGdldENoaWxkQ291bnQgPVxuICAgICAgICAnY2hpbGRyZW4nIGluIHRlc3RFbGVtZW50XG4gICAgICAgICAgICA/IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZWwuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIH07XG5cbiAgICB2YXIgZ2V0Vmlld1JlY3QgPSBmdW5jdGlvbiBnZXRWaWV3UmVjdChlbGVtZW50UmVjdCwgY2hpbGRWaWV3cywgb2Zmc2V0LCBzY2FsZSkge1xuICAgICAgICB2YXIgbGVmdCA9IG9mZnNldFswXSB8fCBlbGVtZW50UmVjdC5sZWZ0O1xuICAgICAgICB2YXIgdG9wID0gb2Zmc2V0WzFdIHx8IGVsZW1lbnRSZWN0LnRvcDtcbiAgICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIGVsZW1lbnRSZWN0LndpZHRoO1xuICAgICAgICB2YXIgYm90dG9tID0gdG9wICsgZWxlbWVudFJlY3QuaGVpZ2h0ICogKHNjYWxlWzFdIHx8IDEpO1xuXG4gICAgICAgIHZhciByZWN0ID0ge1xuICAgICAgICAgICAgLy8gdGhlIHJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudCBpdHNlbGZcbiAgICAgICAgICAgIGVsZW1lbnQ6IE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnRSZWN0KSxcblxuICAgICAgICAgICAgLy8gdGhlIHJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudCBleHBhbmRlZCB0byBjb250YWluIGl0cyBjaGlsZHJlbiwgZG9lcyBub3QgaW5jbHVkZSBhbnkgbWFyZ2luc1xuICAgICAgICAgICAgaW5uZXI6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBlbGVtZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogZWxlbWVudFJlY3QudG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBlbGVtZW50UmVjdC5yaWdodCxcbiAgICAgICAgICAgICAgICBib3R0b206IGVsZW1lbnRSZWN0LmJvdHRvbSxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIHRoZSByZWN0YW5nbGUgb2YgdGhlIGVsZW1lbnQgZXhwYW5kZWQgdG8gY29udGFpbiBpdHMgY2hpbGRyZW4gaW5jbHVkaW5nIG93biBtYXJnaW4gYW5kIGNoaWxkIG1hcmdpbnNcbiAgICAgICAgICAgIC8vIG1hcmdpbnMgd2lsbCBiZSBhZGRlZCBhZnRlciB3ZSd2ZSByZWNhbGN1bGF0ZWQgdGhlIHNpemVcbiAgICAgICAgICAgIG91dGVyOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGV4cGFuZCByZWN0IHRvIGZpdCBhbGwgY2hpbGQgcmVjdGFuZ2xlc1xuICAgICAgICBjaGlsZFZpZXdzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICAgICAgICAgIHJldHVybiAhY2hpbGRWaWV3LmlzUmVjdElnbm9yZWQoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFZpZXcucmVjdDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihjaGlsZFZpZXdSZWN0KSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kUmVjdChyZWN0LmlubmVyLCBPYmplY3QuYXNzaWduKHt9LCBjaGlsZFZpZXdSZWN0LmlubmVyKSk7XG4gICAgICAgICAgICAgICAgZXhwYW5kUmVjdChyZWN0Lm91dGVyLCBPYmplY3QuYXNzaWduKHt9LCBjaGlsZFZpZXdSZWN0Lm91dGVyKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgaW5uZXIgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICBjYWxjdWxhdGVSZWN0U2l6ZShyZWN0LmlubmVyKTtcblxuICAgICAgICAvLyBhcHBlbmQgYWRkaXRpb25hbCBtYXJnaW4gKHRvcCBhbmQgbGVmdCBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpbiB0b3AgYW5kIGxlZnQgYXV0b21hdGljYWxseSlcbiAgICAgICAgcmVjdC5vdXRlci5ib3R0b20gKz0gcmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbTtcbiAgICAgICAgcmVjdC5vdXRlci5yaWdodCArPSByZWN0LmVsZW1lbnQubWFyZ2luUmlnaHQ7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIG91dGVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgY2FsY3VsYXRlUmVjdFNpemUocmVjdC5vdXRlcik7XG5cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfTtcblxuICAgIHZhciBleHBhbmRSZWN0ID0gZnVuY3Rpb24gZXhwYW5kUmVjdChwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgIC8vIGFkanVzdCBmb3IgcGFyZW50IG9mZnNldFxuICAgICAgICBjaGlsZC50b3AgKz0gcGFyZW50LnRvcDtcbiAgICAgICAgY2hpbGQucmlnaHQgKz0gcGFyZW50LmxlZnQ7XG4gICAgICAgIGNoaWxkLmJvdHRvbSArPSBwYXJlbnQudG9wO1xuICAgICAgICBjaGlsZC5sZWZ0ICs9IHBhcmVudC5sZWZ0O1xuXG4gICAgICAgIGlmIChjaGlsZC5ib3R0b20gPiBwYXJlbnQuYm90dG9tKSB7XG4gICAgICAgICAgICBwYXJlbnQuYm90dG9tID0gY2hpbGQuYm90dG9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkLnJpZ2h0ID4gcGFyZW50LnJpZ2h0KSB7XG4gICAgICAgICAgICBwYXJlbnQucmlnaHQgPSBjaGlsZC5yaWdodDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY2FsY3VsYXRlUmVjdFNpemUgPSBmdW5jdGlvbiBjYWxjdWxhdGVSZWN0U2l6ZShyZWN0KSB7XG4gICAgICAgIHJlY3Qud2lkdGggPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICAgICAgICByZWN0LmhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XG4gICAgfTtcblxuICAgIHZhciBpc051bWJlciA9IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHBvc2l0aW9uIGlzIGF0IGRlc3RpbmF0aW9uXG4gICAgICogQHBhcmFtIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGRlc3RpbmF0aW9uXG4gICAgICogQHBhcmFtIHZlbG9jaXR5XG4gICAgICogQHBhcmFtIGVycm9yTWFyZ2luXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdmFyIHRoZXJlWWV0ID0gZnVuY3Rpb24gdGhlcmVZZXQocG9zaXRpb24sIGRlc3RpbmF0aW9uLCB2ZWxvY2l0eSkge1xuICAgICAgICB2YXIgZXJyb3JNYXJnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDAuMDAxO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMocG9zaXRpb24gLSBkZXN0aW5hdGlvbikgPCBlcnJvck1hcmdpbiAmJiBNYXRoLmFicyh2ZWxvY2l0eSkgPCBlcnJvck1hcmdpbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3ByaW5nIGFuaW1hdGlvblxuICAgICAqL1xuICAgIHZhciBzcHJpbmcgPVxuICAgICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgZnVuY3Rpb24gc3ByaW5nKCkgLy8gbWV0aG9kIGRlZmluaXRpb25cbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgICAgICAgIF9yZWYkc3RpZmZuZXNzID0gX3JlZi5zdGlmZm5lc3MsXG4gICAgICAgICAgICAgICAgc3RpZmZuZXNzID0gX3JlZiRzdGlmZm5lc3MgPT09IHZvaWQgMCA/IDAuNSA6IF9yZWYkc3RpZmZuZXNzLFxuICAgICAgICAgICAgICAgIF9yZWYkZGFtcGluZyA9IF9yZWYuZGFtcGluZyxcbiAgICAgICAgICAgICAgICBkYW1waW5nID0gX3JlZiRkYW1waW5nID09PSB2b2lkIDAgPyAwLjc1IDogX3JlZiRkYW1waW5nLFxuICAgICAgICAgICAgICAgIF9yZWYkbWFzcyA9IF9yZWYubWFzcyxcbiAgICAgICAgICAgICAgICBtYXNzID0gX3JlZiRtYXNzID09PSB2b2lkIDAgPyAxMCA6IF9yZWYkbWFzcztcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB2ZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICB2YXIgcmVzdGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGVzIHNwcmluZyBzdGF0ZVxuICAgICAgICAgICAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUodHMsIHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gcmVzdCwgZG9uJ3QgYW5pbWF0ZVxuICAgICAgICAgICAgICAgIGlmIChyZXN0aW5nKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBuZWVkIGF0IGxlYXN0IGEgdGFyZ2V0IG9yIHBvc2l0aW9uIHRvIGRvIHNwcmluZ3kgdGhpbmdzXG4gICAgICAgICAgICAgICAgaWYgKCEoaXNOdW1iZXIodGFyZ2V0KSAmJiBpc051bWJlcihwb3NpdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgc3ByaW5nIGZvcmNlXG4gICAgICAgICAgICAgICAgdmFyIGYgPSAtKHBvc2l0aW9uIC0gdGFyZ2V0KSAqIHN0aWZmbmVzcztcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB2ZWxvY2l0eSBieSBhZGRpbmcgZm9yY2UgYmFzZWQgb24gbWFzc1xuICAgICAgICAgICAgICAgIHZlbG9jaXR5ICs9IGYgLyBtYXNzO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9uIGJ5IGFkZGluZyB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHZlbG9jaXR5O1xuXG4gICAgICAgICAgICAgICAgLy8gc2xvdyBkb3duIGJhc2VkIG9uIGFtb3VudCBvZiBkYW1waW5nXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkgKj0gZGFtcGluZztcblxuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIGFycml2ZWQgaWYgd2UncmUgbmVhciB0YXJnZXQgYW5kIG91ciB2ZWxvY2l0eSBpcyBuZWFyIHplcm9cbiAgICAgICAgICAgICAgICBpZiAodGhlcmVZZXQocG9zaXRpb24sIHRhcmdldCwgdmVsb2NpdHkpIHx8IHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9udXBkYXRlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9uY29tcGxldGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzIHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IG5ldyB0YXJnZXQgdmFsdWVcbiAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgc2V0VGFyZ2V0ID0gZnVuY3Rpb24gc2V0VGFyZ2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudGx5IGhhcyBubyBwb3NpdGlvbiwgc2V0IHRhcmdldCBhbmQgcG9zaXRpb24gdG8gdGhpcyB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChpc051bWJlcih2YWx1ZSkgJiYgIWlzTnVtYmVyKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5leHQgdGFyZ2V0IHZhbHVlIHdpbGwgbm90IGJlIGFuaW1hdGVkIHRvXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsZXQgc3RhcnQgbW92aW5nIHRvIHRhcmdldFxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBhdCB0YXJnZXRcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IHRhcmdldCB8fCB0eXBlb2YgdGFyZ2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3cgcmVzdGluZyBhcyB0YXJnZXQgaXMgY3VycmVudCBwb3NpdGlvbiwgc3RvcCBtb3ZpbmdcbiAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZShwb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG5lZWQgJ2FwaScgdG8gY2FsbCBvbnVwZGF0ZSBjYWxsYmFja1xuICAgICAgICAgICAgdmFyIGFwaSA9IGNyZWF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgICAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgICAgICBzZXQ6IHNldFRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICByZXN0aW5nOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIG9udXBkYXRlOiBmdW5jdGlvbiBvbnVwZGF0ZSh2YWx1ZSkge30sXG4gICAgICAgICAgICAgICAgb25jb21wbGV0ZTogZnVuY3Rpb24gb25jb21wbGV0ZSh2YWx1ZSkge30sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfTtcblxuICAgIHZhciBlYXNlTGluZWFyID0gZnVuY3Rpb24gZWFzZUxpbmVhcih0KSB7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgdmFyIGVhc2VJbk91dFF1YWQgPSBmdW5jdGlvbiBlYXNlSW5PdXRRdWFkKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPCAwLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdDtcbiAgICB9O1xuXG4gICAgdmFyIHR3ZWVuID1cbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgZnVuY3Rpb24gdHdlZW4oKSAvLyBtZXRob2QgZGVmaW5pdGlvblxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgICAgICAgX3JlZiRkdXJhdGlvbiA9IF9yZWYuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBfcmVmJGR1cmF0aW9uID09PSB2b2lkIDAgPyA1MDAgOiBfcmVmJGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIF9yZWYkZWFzaW5nID0gX3JlZi5lYXNpbmcsXG4gICAgICAgICAgICAgICAgZWFzaW5nID0gX3JlZiRlYXNpbmcgPT09IHZvaWQgMCA/IGVhc2VJbk91dFF1YWQgOiBfcmVmJGVhc2luZyxcbiAgICAgICAgICAgICAgICBfcmVmJGRlbGF5ID0gX3JlZi5kZWxheSxcbiAgICAgICAgICAgICAgICBkZWxheSA9IF9yZWYkZGVsYXkgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGRlbGF5O1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICB2YXIgcmVzdGluZyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IG51bGw7XG5cbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIGludGVycG9sYXRlKHRzLCBza2lwVG9FbmRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0aW5nIHx8IHRhcmdldCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRzIC0gc3RhcnQgPCBkZWxheSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdCA9IHRzIC0gc3RhcnQgLSBkZWxheTtcblxuICAgICAgICAgICAgICAgIGlmICh0ID49IGR1cmF0aW9uIHx8IHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBwID0gcmV2ZXJzZSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUocCAqIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbmNvbXBsZXRlKHAgKiB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gdCAvIGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUoKHQgPj0gMCA/IGVhc2luZyhyZXZlcnNlID8gMSAtIHAgOiBwKSA6IDApICogdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBuZWVkICdhcGknIHRvIGNhbGwgb251cGRhdGUgY2FsbGJhY2tcbiAgICAgICAgICAgIHZhciBhcGkgPSBjcmVhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV2ZXJzZSA/IDAgOiB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLm9udXBkYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHR3ZWVuIHRvIGEgc21hbGxlciB2YWx1ZSBhbmQgaGF2ZSBhIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCB0d2VlbmluZyB0byBhIHNtYWxsZXIgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGdvIVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICByZXN0aW5nOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIG9udXBkYXRlOiBmdW5jdGlvbiBvbnVwZGF0ZSh2YWx1ZSkge30sXG4gICAgICAgICAgICAgICAgb25jb21wbGV0ZTogZnVuY3Rpb24gb25jb21wbGV0ZSh2YWx1ZSkge30sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfTtcblxuICAgIHZhciBhbmltYXRvciA9IHtcbiAgICAgICAgc3ByaW5nOiBzcHJpbmcsXG4gICAgICAgIHR3ZWVuOiB0d2VlbixcbiAgICB9O1xuXG4gICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnc3ByaW5nJywgc3RpZmZuZXNzOiAuNSwgZGFtcGluZzogLjc1LCBtYXNzOiAxMCB9O1xuICAgICAgICAgICAgICAgICAgICAgICB7IHRyYW5zbGF0aW9uOiB7IHR5cGU6ICdzcHJpbmcnLCAuLi4gfSwgLi4uIH1cbiAgICAgICAgICAgICAgICAgICAgICAgeyB0cmFuc2xhdGlvbjogeyB4OiB7IHR5cGU6ICdzcHJpbmcnLCAuLi4gfSB9IH1cbiAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIHZhciBjcmVhdGVBbmltYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZUFuaW1hdG9yKGRlZmluaXRpb24sIGNhdGVnb3J5LCBwcm9wZXJ0eSkge1xuICAgICAgICAvLyBkZWZhdWx0IGlzIHNpbmdsZSBkZWZpbml0aW9uXG4gICAgICAgIC8vIHdlIGNoZWNrIGlmIHRyYW5zZm9ybSBpcyBzZXQsIGlmIHNvLCB3ZSBjaGVjayBpZiBwcm9wZXJ0eSBpcyBzZXRcbiAgICAgICAgdmFyIGRlZiA9XG4gICAgICAgICAgICBkZWZpbml0aW9uW2NhdGVnb3J5XSAmJiB0eXBlb2YgZGVmaW5pdGlvbltjYXRlZ29yeV1bcHJvcGVydHldID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgID8gZGVmaW5pdGlvbltjYXRlZ29yeV1bcHJvcGVydHldXG4gICAgICAgICAgICAgICAgOiBkZWZpbml0aW9uW2NhdGVnb3J5XSB8fCBkZWZpbml0aW9uO1xuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGRlZiA9PT0gJ3N0cmluZycgPyBkZWYgOiBkZWYudHlwZTtcbiAgICAgICAgdmFyIHByb3BzID0gdHlwZW9mIGRlZiA9PT0gJ29iamVjdCcgPyBPYmplY3QuYXNzaWduKHt9LCBkZWYpIDoge307XG5cbiAgICAgICAgcmV0dXJuIGFuaW1hdG9yW3R5cGVdID8gYW5pbWF0b3JbdHlwZV0ocHJvcHMpIDogbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEdldFNldCA9IGZ1bmN0aW9uIGFkZEdldFNldChrZXlzLCBvYmosIHByb3BzKSB7XG4gICAgICAgIHZhciBvdmVyd3JpdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgICAgICBvYmogPSBBcnJheS5pc0FycmF5KG9iaikgPyBvYmogOiBbb2JqXTtcbiAgICAgICAgb2JqLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0ga2V5O1xuICAgICAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHByb3BzW2tleV0gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0ga2V5LmtleTtcbiAgICAgICAgICAgICAgICAgICAgZ2V0dGVyID0ga2V5LmdldHRlciB8fCBnZXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHNldHRlciA9IGtleS5zZXR0ZXIgfHwgc2V0dGVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvW25hbWVdICYmICFvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9bbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBhZGQgdG8gc3RhdGUsXG4gICAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnMgdG8gaW50ZXJuYWwgYW5kIGV4dGVybmFsIGFwaSAoaWYgbm90IHNldClcbiAgICAvLyBzZXR1cCBhbmltYXRvcnNcblxuICAgIHZhciBhbmltYXRpb25zID0gZnVuY3Rpb24gYW5pbWF0aW9ucyhfcmVmKSB7XG4gICAgICAgIHZhciBtaXhpbkNvbmZpZyA9IF9yZWYubWl4aW5Db25maWcsXG4gICAgICAgICAgICB2aWV3UHJvcHMgPSBfcmVmLnZpZXdQcm9wcyxcbiAgICAgICAgICAgIHZpZXdJbnRlcm5hbEFQSSA9IF9yZWYudmlld0ludGVybmFsQVBJLFxuICAgICAgICAgICAgdmlld0V4dGVybmFsQVBJID0gX3JlZi52aWV3RXh0ZXJuYWxBUEk7XG4gICAgICAgIC8vIGluaXRpYWwgcHJvcGVydGllc1xuICAgICAgICB2YXIgaW5pdGlhbFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdmlld1Byb3BzKTtcblxuICAgICAgICAvLyBsaXN0IG9mIGFsbCBhY3RpdmUgYW5pbWF0aW9uc1xuICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IFtdO1xuXG4gICAgICAgIC8vIHNldHVwIGFuaW1hdG9yc1xuICAgICAgICBmb3JpbihtaXhpbkNvbmZpZywgZnVuY3Rpb24ocHJvcGVydHksIGFuaW1hdGlvbikge1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9yID0gY3JlYXRlQW5pbWF0b3IoYW5pbWF0aW9uKTtcbiAgICAgICAgICAgIGlmICghYW5pbWF0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIGFuaW1hdG9yIHVwZGF0ZXMsIHVwZGF0ZSB0aGUgdmlldyBzdGF0ZSB2YWx1ZVxuICAgICAgICAgICAgYW5pbWF0b3Iub251cGRhdGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZpZXdQcm9wc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHNldCBhbmltYXRvciB0YXJnZXRcbiAgICAgICAgICAgIGFuaW1hdG9yLnRhcmdldCA9IGluaXRpYWxQcm9wc1twcm9wZXJ0eV07XG5cbiAgICAgICAgICAgIC8vIHdoZW4gdmFsdWUgaXMgc2V0LCBzZXQgdGhlIGFuaW1hdG9yIHRhcmdldCB2YWx1ZVxuICAgICAgICAgICAgdmFyIHByb3AgPSB7XG4gICAgICAgICAgICAgICAga2V5OiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBzZXR0ZXI6IGZ1bmN0aW9uIHNldHRlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGF0IHRhcmdldCwgd2UgZG9uZSFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdG9yLnRhcmdldCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdG9yLnRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0dGVyOiBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3UHJvcHNbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgICAgICAgICAgYWRkR2V0U2V0KFtwcm9wXSwgW3ZpZXdJbnRlcm5hbEFQSSwgdmlld0V4dGVybmFsQVBJXSwgdmlld1Byb3BzLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gYWRkIGl0IHRvIHRoZSBsaXN0IGZvciBlYXN5IHVwZGF0aW5nIGZyb20gdGhlIF93cml0ZSBtZXRob2RcbiAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGV4cG9zZSBpbnRlcm5hbCB3cml0ZSBhcGlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSh0cykge1xuICAgICAgICAgICAgICAgIHZhciBza2lwVG9FbmRTdGF0ZSA9IGRvY3VtZW50LmhpZGRlbjtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFuaW1hdGlvbi5yZXN0aW5nKSByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5pbnRlcnBvbGF0ZSh0cywgc2tpcFRvRW5kU3RhdGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN0aW5nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEV2ZW50ID0gZnVuY3Rpb24gYWRkRXZlbnQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVFdmVudCA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBtaXhpblxuICAgIHZhciBsaXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoX3JlZikge1xuICAgICAgICB2YXIgbWl4aW5Db25maWcgPSBfcmVmLm1peGluQ29uZmlnLFxuICAgICAgICAgICAgdmlld1Byb3BzID0gX3JlZi52aWV3UHJvcHMsXG4gICAgICAgICAgICB2aWV3SW50ZXJuYWxBUEkgPSBfcmVmLnZpZXdJbnRlcm5hbEFQSSxcbiAgICAgICAgICAgIHZpZXdFeHRlcm5hbEFQSSA9IF9yZWYudmlld0V4dGVybmFsQVBJLFxuICAgICAgICAgICAgdmlld1N0YXRlID0gX3JlZi52aWV3U3RhdGUsXG4gICAgICAgICAgICB2aWV3ID0gX3JlZi52aWV3O1xuICAgICAgICB2YXIgZXZlbnRzID0gW107XG5cbiAgICAgICAgdmFyIGFkZCA9IGFkZEV2ZW50KHZpZXcuZWxlbWVudCk7XG4gICAgICAgIHZhciByZW1vdmUgPSByZW1vdmVFdmVudCh2aWV3LmVsZW1lbnQpO1xuXG4gICAgICAgIHZpZXdFeHRlcm5hbEFQSS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBmbjogZm4sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYWRkKHR5cGUsIGZuKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2aWV3RXh0ZXJuYWxBUEkub2ZmID0gZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgICAgICAgIGV2ZW50cy5zcGxpY2UoXG4gICAgICAgICAgICAgICAgZXZlbnRzLmZpbmRJbmRleChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gdHlwZSAmJiBldmVudC5mbiA9PT0gZm47XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmVtb3ZlKHR5cGUsIGZuKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBidXN5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmUoZXZlbnQudHlwZSwgZXZlbnQuZm4pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gYWRkIHRvIGV4dGVybmFsIGFwaSBhbmQgbGluayB0byBwcm9wc1xuXG4gICAgdmFyIGFwaXMgPSBmdW5jdGlvbiBhcGlzKF9yZWYpIHtcbiAgICAgICAgdmFyIG1peGluQ29uZmlnID0gX3JlZi5taXhpbkNvbmZpZyxcbiAgICAgICAgICAgIHZpZXdQcm9wcyA9IF9yZWYudmlld1Byb3BzLFxuICAgICAgICAgICAgdmlld0V4dGVybmFsQVBJID0gX3JlZi52aWV3RXh0ZXJuYWxBUEk7XG4gICAgICAgIGFkZEdldFNldChtaXhpbkNvbmZpZywgdmlld0V4dGVybmFsQVBJLCB2aWV3UHJvcHMpO1xuICAgIH07XG5cbiAgICB2YXIgaXNEZWZpbmVkID0gZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBhZGQgdG8gc3RhdGUsXG4gICAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnMgdG8gaW50ZXJuYWwgYW5kIGV4dGVybmFsIGFwaSAoaWYgbm90IHNldClcbiAgICAvLyBzZXQgaW5pdGlhbCBzdGF0ZSBiYXNlZCBvbiBwcm9wcyBpbiB2aWV3UHJvcHNcbiAgICAvLyBhcHBseSBhcyB0cmFuc2Zvcm1zIGVhY2ggZnJhbWVcblxuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgc2NhbGVYOiAxLFxuICAgICAgICBzY2FsZVk6IDEsXG4gICAgICAgIHRyYW5zbGF0ZVg6IDAsXG4gICAgICAgIHRyYW5zbGF0ZVk6IDAsXG4gICAgICAgIHJvdGF0ZVg6IDAsXG4gICAgICAgIHJvdGF0ZVk6IDAsXG4gICAgICAgIHJvdGF0ZVo6IDAsXG4gICAgICAgIG9yaWdpblg6IDAsXG4gICAgICAgIG9yaWdpblk6IDAsXG4gICAgfTtcblxuICAgIHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXMoX3JlZikge1xuICAgICAgICB2YXIgbWl4aW5Db25maWcgPSBfcmVmLm1peGluQ29uZmlnLFxuICAgICAgICAgICAgdmlld1Byb3BzID0gX3JlZi52aWV3UHJvcHMsXG4gICAgICAgICAgICB2aWV3SW50ZXJuYWxBUEkgPSBfcmVmLnZpZXdJbnRlcm5hbEFQSSxcbiAgICAgICAgICAgIHZpZXdFeHRlcm5hbEFQSSA9IF9yZWYudmlld0V4dGVybmFsQVBJLFxuICAgICAgICAgICAgdmlldyA9IF9yZWYudmlldztcbiAgICAgICAgLy8gaW5pdGlhbCBwcm9wc1xuICAgICAgICB2YXIgaW5pdGlhbFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdmlld1Byb3BzKTtcblxuICAgICAgICAvLyBjdXJyZW50IHByb3BzXG4gICAgICAgIHZhciBjdXJyZW50UHJvcHMgPSB7fTtcblxuICAgICAgICAvLyB3ZSB3aWxsIGFkZCB0aG9zZSBwcm9wZXJ0aWVzIHRvIHRoZSBleHRlcm5hbCBBUEkgYW5kIGxpbmsgdGhlbSB0byB0aGUgdmlld1N0YXRlXG4gICAgICAgIGFkZEdldFNldChtaXhpbkNvbmZpZywgW3ZpZXdJbnRlcm5hbEFQSSwgdmlld0V4dGVybmFsQVBJXSwgdmlld1Byb3BzKTtcblxuICAgICAgICAvLyBvdmVycmlkZSByZWN0IG9uIGludGVybmFsIGFuZCBleHRlcm5hbCByZWN0IGdldHRlciBzbyBpdCB0YWtlcyBpbiBhY2NvdW50IHRyYW5zZm9ybXNcbiAgICAgICAgdmFyIGdldE9mZnNldCA9IGZ1bmN0aW9uIGdldE9mZnNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdmlld1Byb3BzWyd0cmFuc2xhdGVYJ10gfHwgMCwgdmlld1Byb3BzWyd0cmFuc2xhdGVZJ10gfHwgMF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3ZpZXdQcm9wc1snc2NhbGVYJ10gfHwgMCwgdmlld1Byb3BzWydzY2FsZVknXSB8fCAwXTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFJlY3QgPSBmdW5jdGlvbiBnZXRSZWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcucmVjdFxuICAgICAgICAgICAgICAgID8gZ2V0Vmlld1JlY3Qodmlldy5yZWN0LCB2aWV3LmNoaWxkVmlld3MsIGdldE9mZnNldCgpLCBnZXRTY2FsZSgpKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdmlld0ludGVybmFsQVBJLnJlY3QgPSB7IGdldDogZ2V0UmVjdCB9O1xuICAgICAgICB2aWV3RXh0ZXJuYWxBUEkucmVjdCA9IHsgZ2V0OiBnZXRSZWN0IH07XG5cbiAgICAgICAgLy8gYXBwbHkgdmlldyBwcm9wc1xuICAgICAgICBtaXhpbkNvbmZpZy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmlld1Byb3BzW2tleV0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbml0aWFsUHJvcHNba2V5XSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0c1trZXldIDogaW5pdGlhbFByb3BzW2tleV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGV4cG9zZSBhcGlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHtcbiAgICAgICAgICAgICAgICAvLyBzZWUgaWYgcHJvcHMgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wc0hhdmVDaGFuZ2VkKGN1cnJlbnRQcm9wcywgdmlld1Byb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbW92ZXMgZWxlbWVudCB0byBjb3JyZWN0IHBvc2l0aW9uIG9uIHNjcmVlblxuICAgICAgICAgICAgICAgIGFwcGx5U3R5bGVzKHZpZXcuZWxlbWVudCwgdmlld1Byb3BzKTtcblxuICAgICAgICAgICAgICAgIC8vIHN0b3JlIG5ldyB0cmFuc2Zvcm1zXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjdXJyZW50UHJvcHMsIE9iamVjdC5hc3NpZ24oe30sIHZpZXdQcm9wcykpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIGJ1c3lcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge30sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBwcm9wc0hhdmVDaGFuZ2VkID0gZnVuY3Rpb24gcHJvcHNIYXZlQ2hhbmdlZChjdXJyZW50UHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICAgIC8vIGRpZmZlcmVudCBhbW91bnQgb2Yga2V5c1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoY3VycmVudFByb3BzKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG5ld1Byb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0cyBhbmFseXplIHRoZSBpbmRpdmlkdWFsIHByb3BzXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChuZXdQcm9wc1twcm9wXSAhPT0gY3VycmVudFByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBhcHBseVN0eWxlcyA9IGZ1bmN0aW9uIGFwcGx5U3R5bGVzKGVsZW1lbnQsIF9yZWYyKSB7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gX3JlZjIub3BhY2l0eSxcbiAgICAgICAgICAgIHBlcnNwZWN0aXZlID0gX3JlZjIucGVyc3BlY3RpdmUsXG4gICAgICAgICAgICB0cmFuc2xhdGVYID0gX3JlZjIudHJhbnNsYXRlWCxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVkgPSBfcmVmMi50cmFuc2xhdGVZLFxuICAgICAgICAgICAgc2NhbGVYID0gX3JlZjIuc2NhbGVYLFxuICAgICAgICAgICAgc2NhbGVZID0gX3JlZjIuc2NhbGVZLFxuICAgICAgICAgICAgcm90YXRlWCA9IF9yZWYyLnJvdGF0ZVgsXG4gICAgICAgICAgICByb3RhdGVZID0gX3JlZjIucm90YXRlWSxcbiAgICAgICAgICAgIHJvdGF0ZVogPSBfcmVmMi5yb3RhdGVaLFxuICAgICAgICAgICAgb3JpZ2luWCA9IF9yZWYyLm9yaWdpblgsXG4gICAgICAgICAgICBvcmlnaW5ZID0gX3JlZjIub3JpZ2luWSxcbiAgICAgICAgICAgIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybXMgPSAnJztcbiAgICAgICAgdmFyIHN0eWxlcyA9ICcnO1xuXG4gICAgICAgIC8vIGhhbmRsZSB0cmFuc2Zvcm0gb3JpZ2luXG4gICAgICAgIGlmIChpc0RlZmluZWQob3JpZ2luWCkgfHwgaXNEZWZpbmVkKG9yaWdpblkpKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gJ3RyYW5zZm9ybS1vcmlnaW46ICcgKyAob3JpZ2luWCB8fCAwKSArICdweCAnICsgKG9yaWdpblkgfHwgMCkgKyAncHg7JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyYW5zZm9ybSBvcmRlciBpcyByZWxldmFudFxuICAgICAgICAvLyAwLiBwZXJzcGVjdGl2ZVxuICAgICAgICBpZiAoaXNEZWZpbmVkKHBlcnNwZWN0aXZlKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtcyArPSAncGVyc3BlY3RpdmUoJyArIHBlcnNwZWN0aXZlICsgJ3B4KSAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMS4gdHJhbnNsYXRlXG4gICAgICAgIGlmIChpc0RlZmluZWQodHJhbnNsYXRlWCkgfHwgaXNEZWZpbmVkKHRyYW5zbGF0ZVkpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1zICs9XG4gICAgICAgICAgICAgICAgJ3RyYW5zbGF0ZTNkKCcgKyAodHJhbnNsYXRlWCB8fCAwKSArICdweCwgJyArICh0cmFuc2xhdGVZIHx8IDApICsgJ3B4LCAwKSAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gc2NhbGVcbiAgICAgICAgaWYgKGlzRGVmaW5lZChzY2FsZVgpIHx8IGlzRGVmaW5lZChzY2FsZVkpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1zICs9XG4gICAgICAgICAgICAgICAgJ3NjYWxlM2QoJyArXG4gICAgICAgICAgICAgICAgKGlzRGVmaW5lZChzY2FsZVgpID8gc2NhbGVYIDogMSkgK1xuICAgICAgICAgICAgICAgICcsICcgK1xuICAgICAgICAgICAgICAgIChpc0RlZmluZWQoc2NhbGVZKSA/IHNjYWxlWSA6IDEpICtcbiAgICAgICAgICAgICAgICAnLCAxKSAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gcm90YXRlXG4gICAgICAgIGlmIChpc0RlZmluZWQocm90YXRlWikpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMgKz0gJ3JvdGF0ZVooJyArIHJvdGF0ZVogKyAncmFkKSAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmaW5lZChyb3RhdGVYKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtcyArPSAncm90YXRlWCgnICsgcm90YXRlWCArICdyYWQpICc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVkpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVZKCcgKyByb3RhdGVZICsgJ3JhZCkgJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0cmFuc2Zvcm1zXG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLmxlbmd0aCkge1xuICAgICAgICAgICAgc3R5bGVzICs9ICd0cmFuc2Zvcm06JyArIHRyYW5zZm9ybXMgKyAnOyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgb3BhY2l0eVxuICAgICAgICBpZiAoaXNEZWZpbmVkKG9wYWNpdHkpKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gJ29wYWNpdHk6JyArIG9wYWNpdHkgKyAnOyc7XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIHJlYWNoIHplcm8sIHdlIG1ha2UgdGhlIGVsZW1lbnQgaW5hY2Nlc3NpYmxlXG4gICAgICAgICAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0eWxlcyArPSAndmlzaWJpbGl0eTpoaWRkZW47JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2UncmUgYmVsb3cgMTAwJSBvcGFjaXR5IHRoaXMgZWxlbWVudCBjYW4ndCBiZSBjbGlja2VkXG4gICAgICAgICAgICBpZiAob3BhY2l0eSA8IDEpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMgKz0gJ3BvaW50ZXItZXZlbnRzOm5vbmU7JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBoZWlnaHRcbiAgICAgICAgaWYgKGlzRGVmaW5lZChoZWlnaHQpKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gJ2hlaWdodDonICsgaGVpZ2h0ICsgJ3B4Oyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgd2lkdGhcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh3aWR0aCkpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSAnd2lkdGg6JyArIHdpZHRoICsgJ3B4Oyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSBzdHlsZXNcbiAgICAgICAgdmFyIGVsZW1lbnRDdXJyZW50U3R5bGUgPSBlbGVtZW50LmVsZW1lbnRDdXJyZW50U3R5bGUgfHwgJyc7XG5cbiAgICAgICAgLy8gaWYgbmV3IHN0eWxlcyBkb2VzIG5vdCBtYXRjaCBjdXJyZW50IHN0eWxlcywgbGV0cyB1cGRhdGUhXG4gICAgICAgIGlmIChzdHlsZXMubGVuZ3RoICE9PSBlbGVtZW50Q3VycmVudFN0eWxlLmxlbmd0aCB8fCBzdHlsZXMgIT09IGVsZW1lbnRDdXJyZW50U3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlcztcbiAgICAgICAgICAgIC8vIHN0b3JlIGN1cnJlbnQgc3R5bGVzIHNvIHdlIGNhbiBjb21wYXJlIHRoZW0gdG8gbmV3IHN0eWxlcyBsYXRlciBvblxuICAgICAgICAgICAgLy8gX25vdF8gZ2V0dGluZyB0aGUgc3R5bGUgdmFsdWUgaXMgZmFzdGVyXG4gICAgICAgICAgICBlbGVtZW50LmVsZW1lbnRDdXJyZW50U3R5bGUgPSBzdHlsZXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIE1peGlucyA9IHtcbiAgICAgICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICBhbmltYXRpb25zOiBhbmltYXRpb25zLFxuICAgICAgICBhcGlzOiBhcGlzLFxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlUmVjdCA9IGZ1bmN0aW9uIHVwZGF0ZVJlY3QoKSB7XG4gICAgICAgIHZhciByZWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICAgIGlmICghZWxlbWVudC5sYXlvdXRDYWxjdWxhdGVkKSB7XG4gICAgICAgICAgICByZWN0LnBhZGRpbmdUb3AgPSBwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wLCAxMCkgfHwgMDtcbiAgICAgICAgICAgIHJlY3QubWFyZ2luVG9wID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luVG9wLCAxMCkgfHwgMDtcbiAgICAgICAgICAgIHJlY3QubWFyZ2luUmlnaHQgPSBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCwgMTApIHx8IDA7XG4gICAgICAgICAgICByZWN0Lm1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkJvdHRvbSwgMTApIHx8IDA7XG4gICAgICAgICAgICByZWN0Lm1hcmdpbkxlZnQgPSBwYXJzZUludChzdHlsZS5tYXJnaW5MZWZ0LCAxMCkgfHwgMDtcbiAgICAgICAgICAgIGVsZW1lbnQubGF5b3V0Q2FsY3VsYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZWN0LmxlZnQgPSBlbGVtZW50Lm9mZnNldExlZnQgfHwgMDtcbiAgICAgICAgcmVjdC50b3AgPSBlbGVtZW50Lm9mZnNldFRvcCB8fCAwO1xuICAgICAgICByZWN0LndpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAwO1xuICAgICAgICByZWN0LmhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDA7XG5cbiAgICAgICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGg7XG4gICAgICAgIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyByZWN0LmhlaWdodDtcblxuICAgICAgICByZWN0LnNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4gICAgICAgIHJlY3QuaGlkZGVuID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgPT09IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVWaWV3ID1cbiAgICAgICAgLy8gZGVmYXVsdCB2aWV3IGRlZmluaXRpb25cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlVmlldygpIHtcbiAgICAgICAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICAgICAgICBfcmVmJHRhZyA9IF9yZWYudGFnLFxuICAgICAgICAgICAgICAgIHRhZyA9IF9yZWYkdGFnID09PSB2b2lkIDAgPyAnZGl2JyA6IF9yZWYkdGFnLFxuICAgICAgICAgICAgICAgIF9yZWYkbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lID0gX3JlZiRuYW1lID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRuYW1lLFxuICAgICAgICAgICAgICAgIF9yZWYkYXR0cmlidXRlcyA9IF9yZWYuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gX3JlZiRhdHRyaWJ1dGVzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBfcmVmJHJlYWQgPSBfcmVmLnJlYWQsXG4gICAgICAgICAgICAgICAgcmVhZCA9IF9yZWYkcmVhZCA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkcmVhZCxcbiAgICAgICAgICAgICAgICBfcmVmJHdyaXRlID0gX3JlZi53cml0ZSxcbiAgICAgICAgICAgICAgICB3cml0ZSA9IF9yZWYkd3JpdGUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJHdyaXRlLFxuICAgICAgICAgICAgICAgIF9yZWYkY3JlYXRlID0gX3JlZi5jcmVhdGUsXG4gICAgICAgICAgICAgICAgY3JlYXRlID0gX3JlZiRjcmVhdGUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJGNyZWF0ZSxcbiAgICAgICAgICAgICAgICBfcmVmJGRlc3Ryb3kgPSBfcmVmLmRlc3Ryb3ksXG4gICAgICAgICAgICAgICAgZGVzdHJveSA9IF9yZWYkZGVzdHJveSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkZGVzdHJveSxcbiAgICAgICAgICAgICAgICBfcmVmJGZpbHRlckZyYW1lQWN0aW8gPSBfcmVmLmZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkLFxuICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkID1cbiAgICAgICAgICAgICAgICAgICAgX3JlZiRmaWx0ZXJGcmFtZUFjdGlvID09PSB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24oY2hpbGQsIGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IF9yZWYkZmlsdGVyRnJhbWVBY3RpbyxcbiAgICAgICAgICAgICAgICBfcmVmJGRpZENyZWF0ZVZpZXcgPSBfcmVmLmRpZENyZWF0ZVZpZXcsXG4gICAgICAgICAgICAgICAgZGlkQ3JlYXRlVmlldyA9IF9yZWYkZGlkQ3JlYXRlVmlldyA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkZGlkQ3JlYXRlVmlldyxcbiAgICAgICAgICAgICAgICBfcmVmJGRpZFdyaXRlVmlldyA9IF9yZWYuZGlkV3JpdGVWaWV3LFxuICAgICAgICAgICAgICAgIGRpZFdyaXRlVmlldyA9IF9yZWYkZGlkV3JpdGVWaWV3ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkaWRXcml0ZVZpZXcsXG4gICAgICAgICAgICAgICAgX3JlZiRpZ25vcmVSZWN0ID0gX3JlZi5pZ25vcmVSZWN0LFxuICAgICAgICAgICAgICAgIGlnbm9yZVJlY3QgPSBfcmVmJGlnbm9yZVJlY3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRpZ25vcmVSZWN0LFxuICAgICAgICAgICAgICAgIF9yZWYkaWdub3JlUmVjdFVwZGF0ZSA9IF9yZWYuaWdub3JlUmVjdFVwZGF0ZSxcbiAgICAgICAgICAgICAgICBpZ25vcmVSZWN0VXBkYXRlID0gX3JlZiRpZ25vcmVSZWN0VXBkYXRlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaWdub3JlUmVjdFVwZGF0ZSxcbiAgICAgICAgICAgICAgICBfcmVmJG1peGlucyA9IF9yZWYubWl4aW5zLFxuICAgICAgICAgICAgICAgIG1peGlucyA9IF9yZWYkbWl4aW5zID09PSB2b2lkIDAgPyBbXSA6IF9yZWYkbWl4aW5zO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIC8vIGVhY2ggdmlldyByZXF1aXJlcyByZWZlcmVuY2UgdG8gc3RvcmVcbiAgICAgICAgICAgICAgICBzdG9yZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgICAgICAgICAvLyByb290IGVsZW1lbnQgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHRhZywgJ2ZpbGVwb25kLS0nICsgbmFtZSwgYXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdHlsZSByZWZlcmVuY2Ugc2hvdWxkIGFsc28gbm90IGJlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcblxuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgcmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB1cGRhdGVSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lUmVjdCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyByZXN0IHN0YXRlXG4gICAgICAgICAgICAgICAgdmFyIGlzUmVzdGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gcHJldHR5IHNlbGYgZXhwbGFuYXRvcnlcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRWaWV3cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gbG9hZGVkIG1peGluc1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVNaXhpbnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZXMgdG8gY3JlYXRlZCBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHZhciByZWYgPSB7fTtcblxuICAgICAgICAgICAgICAgIC8vIHN0YXRlIHVzZWQgZm9yIGVhY2ggaW5zdGFuY2VcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSB7fTtcblxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2Ygd3JpdGVycyB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIHVwZGF0ZSB0aGlzIHZpZXdcbiAgICAgICAgICAgICAgICB2YXIgd3JpdGVycyA9IFtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGUsIC8vIGRlZmF1bHQgd3JpdGVyXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIHZhciByZWFkZXJzID0gW1xuICAgICAgICAgICAgICAgICAgICByZWFkLCAvLyBkZWZhdWx0IHJlYWRlclxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVzdHJveWVycyA9IFtcbiAgICAgICAgICAgICAgICAgICAgZGVzdHJveSwgLy8gZGVmYXVsdCBkZXN0cm95XG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIC8vIGNvcmUgdmlldyBtZXRob2RzXG4gICAgICAgICAgICAgICAgdmFyIGdldEVsZW1lbnQgPSBmdW5jdGlvbiBnZXRFbGVtZW50KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBnZXRDaGlsZFZpZXdzID0gZnVuY3Rpb24gZ2V0Q2hpbGRWaWV3cygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkVmlld3MuY29uY2F0KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0UmVmZXJlbmNlID0gZnVuY3Rpb24gZ2V0UmVmZXJlbmNlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGNyZWF0ZUNoaWxkVmlldyA9IGZ1bmN0aW9uIGNyZWF0ZUNoaWxkVmlldyhzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmlldywgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3KHN0b3JlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0UmVjdCA9IGZ1bmN0aW9uIGdldFJlY3QoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZVJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJhbWVSZWN0ID0gZ2V0Vmlld1JlY3QocmVjdCwgY2hpbGRWaWV3cywgWzAsIDBdLCBbMSwgMV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWVSZWN0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGdldFN0eWxlID0gZnVuY3Rpb24gZ2V0U3R5bGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVhZCBkYXRhIGZyb20gRE9NXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgX3JlYWQgPSBmdW5jdGlvbiBfcmVhZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVSZWN0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkIGNoaWxkIHZpZXdzXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVmlld3MuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLl9yZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaG91bGRVcGRhdGUgPSAhKGlnbm9yZVJlY3RVcGRhdGUgJiYgcmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlY3QocmVjdCwgZWxlbWVudCwgc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGVyc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXBpID0geyByb290OiBpbnRlcm5hbEFQSSwgcHJvcHM6IHByb3BzLCByZWN0OiByZWN0IH07XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIoYXBpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdyaXRlIGRhdGEgdG8gRE9NXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlKHRzLCBmcmFtZUFjdGlvbnMsIHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vIGFjdGlvbnMsIHdlIGFzc3VtZSB0aGF0IHRoZSB2aWV3IGlzIHJlc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RpbmcgPSBmcmFtZUFjdGlvbnMubGVuZ3RoID09PSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdyaXRlcnNcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVycy5mb3JFYWNoKGZ1bmN0aW9uKHdyaXRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdyaXRlclJlc3RpbmcgPSB3cml0ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290OiBpbnRlcm5hbEFQSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBmcmFtZUFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRPcHRpbWl6ZTogc2hvdWxkT3B0aW1pemUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdyaXRlclJlc3RpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBydW4gbWl4aW5zXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1peGlucy5mb3JFYWNoKGZ1bmN0aW9uKG1peGluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1peGlucyBpcyBzdGlsbCBidXN5IGFmdGVyIHdyaXRlIG9wZXJhdGlvbiwgd2UgYXJlIG5vdCByZXN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWl4aW5SZXN0aW5nID0gbWl4aW4ud3JpdGUodHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1peGluUmVzdGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgY2hpbGQgdmlld3MgdGhhdCBhcmUgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoZSBET01cbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWaWV3c1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWNoaWxkLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGEgY2hpbGQgdmlldyBpcyBub3QgcmVzdGluZywgd2UgYXJlIG5vdCByZXN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkUmVzdGluZyA9IGNoaWxkLl93cml0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkKGNoaWxkLCBmcmFtZUFjdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRPcHRpbWl6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkUmVzdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIG5ldyBlbGVtZW50cyB0byBET00gYW5kIHVwZGF0ZSB0aG9zZVxuICAgICAgICAgICAgICAgICAgICBjaGlsZFZpZXdzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy5maWx0ZXIoY2hpbGQgPT4gIWNoaWxkLmVsZW1lbnQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNraXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcHBlbmQgdG8gRE9NXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxBUEkuYXBwZW5kQ2hpbGQoY2hpbGQuZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCByZWFkIChuZWVkIHRvIGtub3cgdGhlIHNpemUgb2YgdGhlc2UgZWxlbWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuX3JlYWQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlLWNhbGwgd3JpdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5fd3JpdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZChjaGlsZCwgZnJhbWVBY3Rpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBhZGRlZCBzb210aGluZyB0byB0aGUgZG9tLCBubyByZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHJlc3Rpbmcgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgaXNSZXN0aW5nID0gcmVzdGluZztcblxuICAgICAgICAgICAgICAgICAgICBkaWRXcml0ZVZpZXcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdDogaW50ZXJuYWxBUEksXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBmcmFtZUFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQgcGFyZW50IGtub3cgaWYgd2UgYXJlIHJlc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3Rpbmc7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBfZGVzdHJveSA9IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVNaXhpbnMuZm9yRWFjaChmdW5jdGlvbihtaXhpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1peGluLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3llcnMuZm9yRWFjaChmdW5jdGlvbihkZXN0cm95ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3llcih7IHJvb3Q6IGludGVybmFsQVBJLCBwcm9wczogcHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFZpZXdzLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5fZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gc2hhcmVkQVBJXG4gICAgICAgICAgICAgICAgdmFyIHNoYXJlZEFQSURlZmluaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZ2V0RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXRTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBjaGlsZFZpZXdzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldENoaWxkVmlld3MsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIHByaXZhdGUgQVBJIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJuYWxBUElEZWZpbml0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgc2hhcmVkQVBJRGVmaW5pdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldFJlY3QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzIHRvIGN1c3RvbSBjaGlsZHJlbiByZWZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICAgIHJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXRSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZG9tIG1vZGlmaWVyc1xuICAgICAgICAgICAgICAgICAgICBpczogZnVuY3Rpb24gaXMobmVlZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gbmVlZGxlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNoaWxkVmlldzogY3JlYXRlQ2hpbGRWaWV3KHN0b3JlKSxcbiAgICAgICAgICAgICAgICAgICAgbGlua1ZpZXc6IGZ1bmN0aW9uIGxpbmtWaWV3KHZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkVmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1bmxpbmtWaWV3OiBmdW5jdGlvbiB1bmxpbmtWaWV3KHZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkVmlld3Muc3BsaWNlKGNoaWxkVmlld3MuaW5kZXhPZih2aWV3KSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkVmlldzogYXBwZW5kQ2hpbGRWaWV3KGVsZW1lbnQsIGNoaWxkVmlld3MpLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZFZpZXc6IHJlbW92ZUNoaWxkVmlldyhlbGVtZW50LCBjaGlsZFZpZXdzKSxcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJXcml0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyV3JpdGVyKHdyaXRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlcnMucHVzaCh3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWdpc3RlclJlYWRlcjogZnVuY3Rpb24gcmVnaXN0ZXJSZWFkZXIocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyRGVzdHJveWVyOiBmdW5jdGlvbiByZWdpc3RlckRlc3Ryb3llcihkZXN0cm95ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXN0cm95ZXJzLnB1c2goZGVzdHJveWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZGF0ZUxheW91dDogZnVuY3Rpb24gaW52YWxpZGF0ZUxheW91dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZWxlbWVudC5sYXlvdXRDYWxjdWxhdGVkID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY2VzcyB0byBkYXRhIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoOiBzdG9yZS5kaXNwYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHN0b3JlLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gcHVibGljIHZpZXcgQVBJIG1ldGhvZHNcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZXJuYWxBUElEZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWaWV3czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXRDaGlsZFZpZXdzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZ2V0UmVjdCxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICByZXN0aW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNSZXN0aW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBpc1JlY3RJZ25vcmVkOiBmdW5jdGlvbiBpc1JlY3RJZ25vcmVkKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlnbm9yZVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF9yZWFkOiBfcmVhZCxcbiAgICAgICAgICAgICAgICAgICAgX3dyaXRlOiBfd3JpdGUsXG4gICAgICAgICAgICAgICAgICAgIF9kZXN0cm95OiBfZGVzdHJveSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gbWl4aW4gQVBJIG1ldGhvZHNcbiAgICAgICAgICAgICAgICB2YXIgbWl4aW5BUElEZWZpbml0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgc2hhcmVkQVBJRGVmaW5pdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgbWl4aW4gZnVuY3Rpb25hbGl0eVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG1peGlucylcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBzdHlsZXMgdG8gdGhlIGJhY2sgb2YgdGhlIG1peGluIGxpc3QgKHNvIGFkanVzdG1lbnRzIG9mIG90aGVyIG1peGlucyBhcmUgYXBwbGllZCB0byB0aGUgcHJvcHMgY29ycmVjdGx5KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09ICdzdHlsZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09ICdzdHlsZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1peGluQVBJID0gTWl4aW5zW2tleV0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1peGluQ29uZmlnOiBtaXhpbnNba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3UHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdTdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld0ludGVybmFsQVBJOiBpbnRlcm5hbEFQSURlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld0V4dGVybmFsQVBJOiBleHRlcm5hbEFQSURlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogY3JlYXRlT2JqZWN0KG1peGluQVBJRGVmaW5pdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1peGluQVBJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlTWl4aW5zLnB1c2gobWl4aW5BUEkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnN0cnVjdCBwcml2YXRlIGFwaVxuICAgICAgICAgICAgICAgIHZhciBpbnRlcm5hbEFQSSA9IGNyZWF0ZU9iamVjdChpbnRlcm5hbEFQSURlZmluaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSB2aWV3XG4gICAgICAgICAgICAgICAgY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogaW50ZXJuYWxBUEksXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBjcmVhdGVkIGNoaWxkIHZpZXdzIHRvIHJvb3Qgbm9kZVxuICAgICAgICAgICAgICAgIHZhciBjaGlsZENvdW50ID0gZ2V0Q2hpbGRDb3VudChlbGVtZW50KTsgLy8gbmVlZCB0byBrbm93IHRoZSBjdXJyZW50IGNoaWxkIGNvdW50IHNvIGFwcGVuZGluZyBoYXBwZW5zIGluIGNvcnJlY3Qgb3JkZXJcbiAgICAgICAgICAgICAgICBjaGlsZFZpZXdzLmZvckVhY2goZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsQVBJLmFwcGVuZENoaWxkKGNoaWxkLmVsZW1lbnQsIGNoaWxkQ291bnQgKyBpbmRleCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxsIGRpZCBjcmVhdGVcbiAgICAgICAgICAgICAgICBkaWRDcmVhdGVWaWV3KGludGVybmFsQVBJKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4cG9zZSBwdWJsaWMgYXBpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdChleHRlcm5hbEFQSURlZmluaXRpb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgIHZhciBjcmVhdGVQYWludGVyID0gZnVuY3Rpb24gY3JlYXRlUGFpbnRlcihyZWFkLCB3cml0ZSkge1xuICAgICAgICB2YXIgZnBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA2MDtcblxuICAgICAgICB2YXIgbmFtZSA9ICdfX2ZyYW1lUGFpbnRlcic7XG5cbiAgICAgICAgLy8gc2V0IGdsb2JhbCBwYWludGVyXG4gICAgICAgIGlmICh3aW5kb3dbbmFtZV0pIHtcbiAgICAgICAgICAgIHdpbmRvd1tuYW1lXS5yZWFkZXJzLnB1c2gocmVhZCk7XG4gICAgICAgICAgICB3aW5kb3dbbmFtZV0ud3JpdGVycy5wdXNoKHdyaXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvd1tuYW1lXSA9IHtcbiAgICAgICAgICAgIHJlYWRlcnM6IFtyZWFkXSxcbiAgICAgICAgICAgIHdyaXRlcnM6IFt3cml0ZV0sXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHBhaW50ZXIgPSB3aW5kb3dbbmFtZV07XG5cbiAgICAgICAgdmFyIGludGVydmFsID0gMTAwMCAvIGZwcztcbiAgICAgICAgdmFyIGxhc3QgPSBudWxsO1xuICAgICAgICB2YXIgaWQgPSBudWxsO1xuICAgICAgICB2YXIgcmVxdWVzdFRpY2sgPSBudWxsO1xuICAgICAgICB2YXIgY2FuY2VsVGljayA9IG51bGw7XG5cbiAgICAgICAgdmFyIHNldFRpbWVyVHlwZSA9IGZ1bmN0aW9uIHNldFRpbWVyVHlwZSgpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uIHJlcXVlc3RUaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGljayhwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbmNlbFRpY2sgPSBmdW5jdGlvbiBjYW5jZWxUaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmNsZWFyVGltZW91dChpZCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiByZXF1ZXN0VGljaygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYW5jZWxUaWNrID0gZnVuY3Rpb24gY2FuY2VsVGljaygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY2FuY2VsVGljaykgY2FuY2VsVGljaygpO1xuICAgICAgICAgICAgc2V0VGltZXJUeXBlKCk7XG4gICAgICAgICAgICB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHRpY2sgPSBmdW5jdGlvbiB0aWNrKHRzKSB7XG4gICAgICAgICAgICAvLyBxdWV1ZSBuZXh0IHRpY2tcbiAgICAgICAgICAgIGlkID0gcmVxdWVzdFRpY2sodGljayk7XG5cbiAgICAgICAgICAgIC8vIGxpbWl0IGZwc1xuICAgICAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IHRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB0cyAtIGxhc3Q7XG5cbiAgICAgICAgICAgIGlmIChkZWx0YSA8PSBpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgZnJhbWVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFsaWduIG5leHQgZnJhbWVcbiAgICAgICAgICAgIGxhc3QgPSB0cyAtIChkZWx0YSAlIGludGVydmFsKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHZpZXdcbiAgICAgICAgICAgIHBhaW50ZXIucmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHJlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYWludGVyLndyaXRlcnMuZm9yRWFjaChmdW5jdGlvbih3cml0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZSh0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZXRUaW1lclR5cGUoKTtcbiAgICAgICAgdGljayhwZXJmb3JtYW5jZS5ub3coKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxUaWNrKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVSb3V0ZSA9IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlKHJvdXRlcywgZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICAgICAgICBfcmVmJGFjdGlvbnMgPSBfcmVmLmFjdGlvbnMsXG4gICAgICAgICAgICAgICAgYWN0aW9ucyA9IF9yZWYkYWN0aW9ucyA9PT0gdm9pZCAwID8gW10gOiBfcmVmJGFjdGlvbnMsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gX3JlZi50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemUgPSBfcmVmLnNob3VsZE9wdGltaXplO1xuICAgICAgICAgICAgYWN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZXNbYWN0aW9uLnR5cGVdO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZXNbYWN0aW9uLnR5cGVdKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvbi5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRPcHRpbWl6ZTogc2hvdWxkT3B0aW1pemUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbih7XG4gICAgICAgICAgICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplOiBzaG91bGRPcHRpbWl6ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIH07XG5cbiAgICB2YXIgaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiBpbnNlcnRBZnRlcihuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xuICAgIH07XG5cbiAgICB2YXIgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIH07XG5cbiAgICB2YXIgaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gICAgfTtcblxuICAgIHZhciB0cmltID0gZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci50cmltKCk7XG4gICAgfTtcblxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlO1xuICAgIH07XG5cbiAgICB2YXIgdG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgICAgdmFyIHNwbGl0dGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLCc7XG4gICAgICAgIGlmIChpc0VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSlcbiAgICAgICAgICAgIC5zcGxpdChzcGxpdHRlcilcbiAgICAgICAgICAgIC5tYXAodHJpbSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ci5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGlzQm9vbGVhbiA9IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gICAgfTtcblxuICAgIHZhciB0b0Jvb2xlYW4gPSBmdW5jdGlvbiB0b0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzQm9vbGVhbih2YWx1ZSkgPyB2YWx1ZSA6IHZhbHVlID09PSAndHJ1ZSc7XG4gICAgfTtcblxuICAgIHZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH07XG5cbiAgICB2YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6IGlzU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgPyB0b1N0cmluZyh2YWx1ZSkucmVwbGFjZSgvW2Etel0rL2dpLCAnJylcbiAgICAgICAgICAgIDogMDtcbiAgICB9O1xuXG4gICAgdmFyIHRvSW50ID0gZnVuY3Rpb24gdG9JbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRvTnVtYmVyKHZhbHVlKSwgMTApO1xuICAgIH07XG5cbiAgICB2YXIgdG9GbG9hdCA9IGZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodG9OdW1iZXIodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzSW50ID0gZnVuY3Rpb24gaXNJbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xuICAgIH07XG5cbiAgICB2YXIgdG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXModmFsdWUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDA7XG4gICAgICAgIC8vIGlzIGluIGJ5dGVzXG4gICAgICAgIGlmIChpc0ludCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlzIG5hdHVyYWwgZmlsZSBzaXplXG4gICAgICAgIHZhciBuYXR1cmFsRmlsZVNpemUgPSB0b1N0cmluZyh2YWx1ZSkudHJpbSgpO1xuXG4gICAgICAgIC8vIGlmIGlzIHZhbHVlIGluIG1lZ2FieXRlc1xuICAgICAgICBpZiAoL01CJC9pLnRlc3QobmF0dXJhbEZpbGVTaXplKSkge1xuICAgICAgICAgICAgbmF0dXJhbEZpbGVTaXplID0gbmF0dXJhbEZpbGVTaXplLnJlcGxhY2UoL01CJGkvLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvSW50KG5hdHVyYWxGaWxlU2l6ZSkgKiBiYXNlICogYmFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGlzIHZhbHVlIGluIGtpbG9ieXRlc1xuICAgICAgICBpZiAoL0tCL2kudGVzdChuYXR1cmFsRmlsZVNpemUpKSB7XG4gICAgICAgICAgICBuYXR1cmFsRmlsZVNpemUgPSBuYXR1cmFsRmlsZVNpemUucmVwbGFjZSgvS0IkaS8sICcnKS50cmltKCk7XG4gICAgICAgICAgICByZXR1cm4gdG9JbnQobmF0dXJhbEZpbGVTaXplKSAqIGJhc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9JbnQobmF0dXJhbEZpbGVTaXplKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgfTtcblxuICAgIHZhciB0b0Z1bmN0aW9uUmVmZXJlbmNlID0gZnVuY3Rpb24gdG9GdW5jdGlvblJlZmVyZW5jZShzdHJpbmcpIHtcbiAgICAgICAgdmFyIHJlZiA9IHNlbGY7XG4gICAgICAgIHZhciBsZXZlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIGxldmVsID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKChsZXZlbCA9IGxldmVscy5zaGlmdCgpKSkge1xuICAgICAgICAgICAgcmVmID0gcmVmW2xldmVsXTtcbiAgICAgICAgICAgIGlmICghcmVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9O1xuXG4gICAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICAgIHByb2Nlc3M6ICdQT1NUJyxcbiAgICAgICAgcGF0Y2g6ICdQQVRDSCcsXG4gICAgICAgIHJldmVydDogJ0RFTEVURScsXG4gICAgICAgIGZldGNoOiAnR0VUJyxcbiAgICAgICAgcmVzdG9yZTogJ0dFVCcsXG4gICAgICAgIGxvYWQ6ICdHRVQnLFxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlU2VydmVyQVBJID0gZnVuY3Rpb24gY3JlYXRlU2VydmVyQVBJKG91dGxpbmUpIHtcbiAgICAgICAgdmFyIGFwaSA9IHt9O1xuXG4gICAgICAgIGFwaS51cmwgPSBpc1N0cmluZyhvdXRsaW5lKSA/IG91dGxpbmUgOiBvdXRsaW5lLnVybCB8fCAnJztcbiAgICAgICAgYXBpLnRpbWVvdXQgPSBvdXRsaW5lLnRpbWVvdXQgPyBwYXJzZUludChvdXRsaW5lLnRpbWVvdXQsIDEwKSA6IDA7XG4gICAgICAgIGFwaS5oZWFkZXJzID0gb3V0bGluZS5oZWFkZXJzID8gb3V0bGluZS5oZWFkZXJzIDoge307XG5cbiAgICAgICAgZm9yaW4obWV0aG9kcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBhcGlba2V5XSA9IGNyZWF0ZUFjdGlvbihrZXksIG91dGxpbmVba2V5XSwgbWV0aG9kc1trZXldLCBhcGkudGltZW91dCwgYXBpLmhlYWRlcnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZW1vdmUgcHJvY2VzcyBpZiBubyB1cmwgb3IgcHJvY2VzcyBvbiBvdXRsaW5lXG4gICAgICAgIGFwaS5wcm9jZXNzID0gb3V0bGluZS5wcm9jZXNzIHx8IGlzU3RyaW5nKG91dGxpbmUpIHx8IG91dGxpbmUudXJsID8gYXBpLnByb2Nlc3MgOiBudWxsO1xuXG4gICAgICAgIC8vIHNwZWNpYWwgdHJlYXRtZW50IGZvciByZW1vdmVcbiAgICAgICAgYXBpLnJlbW92ZSA9IG91dGxpbmUucmVtb3ZlIHx8IG51bGw7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGdlbmVyaWMgaGVhZGVycyBmcm9tIGFwaSBvYmplY3RcbiAgICAgICAgZGVsZXRlIGFwaS5oZWFkZXJzO1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVBY3Rpb24obmFtZSwgb3V0bGluZSwgbWV0aG9kLCB0aW1lb3V0LCBoZWFkZXJzKSB7XG4gICAgICAgIC8vIGlzIGV4cGxpY2l0ZWx5IHNldCB0byBudWxsIHNvIGRpc2FibGVcbiAgICAgICAgaWYgKG91dGxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXMgY3VzdG9tIGZ1bmN0aW9uLCBkb25lISBEZXYgaGFuZGxlcyBldmVyeXRoaW5nLlxuICAgICAgICBpZiAodHlwZW9mIG91dGxpbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnVpbGQgYWN0aW9uIG9iamVjdFxuICAgICAgICB2YXIgYWN0aW9uID0ge1xuICAgICAgICAgICAgdXJsOiBtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ1BBVENIJyA/ICc/JyArIG5hbWUgKyAnPScgOiAnJyxcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgICAgICAgb25sb2FkOiBudWxsLFxuICAgICAgICAgICAgb25kYXRhOiBudWxsLFxuICAgICAgICAgICAgb25lcnJvcjogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBpcyBhIHNpbmdsZSB1cmxcbiAgICAgICAgaWYgKGlzU3RyaW5nKG91dGxpbmUpKSB7XG4gICAgICAgICAgICBhY3Rpb24udXJsID0gb3V0bGluZTtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdmVyd3JpdGVcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhY3Rpb24sIG91dGxpbmUpO1xuXG4gICAgICAgIC8vIHNlZSBpZiBzaG91bGQgcmVmb3JtYXQgaGVhZGVycztcbiAgICAgICAgaWYgKGlzU3RyaW5nKGFjdGlvbi5oZWFkZXJzKSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gYWN0aW9uLmhlYWRlcnMuc3BsaXQoLzooLispLyk7XG4gICAgICAgICAgICBhY3Rpb24uaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHBhcnRzWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJ0c1sxXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpcyBib29sIHdpdGhDcmVkZW50aWFsc1xuICAgICAgICBhY3Rpb24ud2l0aENyZWRlbnRpYWxzID0gdG9Cb29sZWFuKGFjdGlvbi53aXRoQ3JlZGVudGlhbHMpO1xuXG4gICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfTtcblxuICAgIHZhciB0b1NlcnZlckFQSSA9IGZ1bmN0aW9uIHRvU2VydmVyQVBJKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2ZXJBUEkodmFsdWUpO1xuICAgIH07XG5cbiAgICB2YXIgaXNOdWxsID0gZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBpc0FQSSA9IGZ1bmN0aW9uIGlzQVBJKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc09iamVjdCh2YWx1ZSkgJiZcbiAgICAgICAgICAgIGlzU3RyaW5nKHZhbHVlLnVybCkgJiZcbiAgICAgICAgICAgIGlzT2JqZWN0KHZhbHVlLnByb2Nlc3MpICYmXG4gICAgICAgICAgICBpc09iamVjdCh2YWx1ZS5yZXZlcnQpICYmXG4gICAgICAgICAgICBpc09iamVjdCh2YWx1ZS5yZXN0b3JlKSAmJlxuICAgICAgICAgICAgaXNPYmplY3QodmFsdWUuZmV0Y2gpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBnZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2ludCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL15bMC05XSsgPyg/OkdCfE1CfEtCKSQvZ2kudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYnl0ZXMnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQVBJKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdhcGknO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcGxhY2VTaW5nbGVRdW90ZXMgPSBmdW5jdGlvbiByZXBsYWNlU2luZ2xlUXVvdGVzKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyXG4gICAgICAgICAgICAucmVwbGFjZSgve1xccyonL2csICd7XCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoLydcXHMqfS9nLCAnXCJ9JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nXFxzKjovZywgJ1wiOicpXG4gICAgICAgICAgICAucmVwbGFjZSgvOlxccyonL2csICc6XCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyxcXHMqJy9nLCAnLFwiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nXFxzKiwvZywgJ1wiLCcpO1xuICAgIH07XG5cbiAgICB2YXIgY29udmVyc2lvblRhYmxlID0ge1xuICAgICAgICBhcnJheTogdG9BcnJheSxcbiAgICAgICAgYm9vbGVhbjogdG9Cb29sZWFuLFxuICAgICAgICBpbnQ6IGZ1bmN0aW9uIGludCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFR5cGUodmFsdWUpID09PSAnYnl0ZXMnID8gdG9CeXRlcyh2YWx1ZSkgOiB0b0ludCh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlcjogdG9GbG9hdCxcbiAgICAgICAgZmxvYXQ6IHRvRmxvYXQsXG4gICAgICAgIGJ5dGVzOiB0b0J5dGVzLFxuICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiB0b1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uOiBmdW5jdGlvbiBfZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b0Z1bmN0aW9uUmVmZXJlbmNlKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VydmVyYXBpOiB0b1NlcnZlckFQSSxcbiAgICAgICAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3QodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVwbGFjZVNpbmdsZVF1b3Rlcyh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICB2YXIgY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJzaW9uVGFibGVbdHlwZV0odmFsdWUpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VmFsdWVCeVR5cGUgPSBmdW5jdGlvbiBnZXRWYWx1ZUJ5VHlwZShuZXdWYWx1ZSwgZGVmYXVsdFZhbHVlLCB2YWx1ZVR5cGUpIHtcbiAgICAgICAgLy8gY2FuIGFsd2F5cyBhc3NpZ24gZGVmYXVsdCB2YWx1ZVxuICAgICAgICBpZiAobmV3VmFsdWUgPT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHRoZSBuZXcgdmFsdWVcbiAgICAgICAgdmFyIG5ld1ZhbHVlVHlwZSA9IGdldFR5cGUobmV3VmFsdWUpO1xuXG4gICAgICAgIC8vIGlzIHZhbGlkIHR5cGU/XG4gICAgICAgIGlmIChuZXdWYWx1ZVR5cGUgIT09IHZhbHVlVHlwZSkge1xuICAgICAgICAgICAgLy8gaXMgc3RyaW5nIGlucHV0LCBsZXQncyBhdHRlbXB0IHRvIGNvbnZlcnRcbiAgICAgICAgICAgIHZhciBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRUbyhuZXdWYWx1ZSwgdmFsdWVUeXBlKTtcblxuICAgICAgICAgICAgLy8gd2hhdCBpcyB0aGUgdHlwZSBub3dcbiAgICAgICAgICAgIG5ld1ZhbHVlVHlwZSA9IGdldFR5cGUoY29udmVydGVkVmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBubyB2YWxpZCBjb252ZXJzaW9ucyBmb3VuZFxuICAgICAgICAgICAgaWYgKGNvbnZlcnRlZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1RyeWluZyB0byBhc3NpZ24gdmFsdWUgd2l0aCBpbmNvcnJlY3QgdHlwZSB0byBcIicgK1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24gK1xuICAgICAgICAgICAgICAgICAgICAnXCIsIGFsbG93ZWQgdHlwZTogXCInICtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVUeXBlICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBjb252ZXJ0ZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFzc2lnbiBuZXcgdmFsdWVcbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlT3B0aW9uID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uKGRlZmF1bHRWYWx1ZSwgdmFsdWVUeXBlKSB7XG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGdldFZhbHVlQnlUeXBlKG5ld1ZhbHVlLCBkZWZhdWx0VmFsdWUsIHZhbHVlVHlwZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlT3B0aW9ucyA9IGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25EZWZpbml0aW9uID0gb3B0aW9uc1twcm9wXTtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IGNyZWF0ZU9wdGlvbihvcHRpb25EZWZpbml0aW9uWzBdLCBvcHRpb25EZWZpbml0aW9uWzFdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVPYmplY3Qob2JqKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBtb2RlbFxuICAgICAgICAgICAgaXRlbXM6IFtdLFxuXG4gICAgICAgICAgICAvLyB0aW1lb3V0IHVzZWQgZm9yIGNhbGxpbmcgdXBkYXRlIGl0ZW1zXG4gICAgICAgICAgICBsaXN0VXBkYXRlVGltZW91dDogbnVsbCxcblxuICAgICAgICAgICAgLy8gdGltZW91dCB1c2VkIGZvciBzdGFja2luZyBtZXRhZGF0YSB1cGRhdGVzXG4gICAgICAgICAgICBpdGVtVXBkYXRlVGltZW91dDogbnVsbCxcblxuICAgICAgICAgICAgLy8gcXVldWUgb2YgaXRlbXMgd2FpdGluZyB0byBiZSBwcm9jZXNzZWRcbiAgICAgICAgICAgIHByb2Nlc3NpbmdRdWV1ZTogW10sXG5cbiAgICAgICAgICAgIC8vIG9wdGlvbnNcbiAgICAgICAgICAgIG9wdGlvbnM6IGNyZWF0ZU9wdGlvbnMob3B0aW9ucyksXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBmcm9tQ2FtZWxzID0gZnVuY3Rpb24gZnJvbUNhbWVscyhzdHJpbmcpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJy0nO1xuICAgICAgICByZXR1cm4gc3RyaW5nXG4gICAgICAgICAgICAuc3BsaXQoLyg/PVtBLVpdKS8pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVPcHRpb25BUEkgPSBmdW5jdGlvbiBjcmVhdGVPcHRpb25BUEkoc3RvcmUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBmb3JpbihvcHRpb25zLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0ge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuZ2V0U3RhdGUoKS5vcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnU0VUXycgKyBmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU9wdGlvbkFjdGlvbnMgPSBmdW5jdGlvbiBjcmVhdGVPcHRpb25BY3Rpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRpc3BhdGNoLCBxdWVyeSwgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZnJvbUNhbWVscyhrZXksICdfJykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgIG9ialsnU0VUXycgKyBuYW1lXSA9IGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9uc1trZXldID0gYWN0aW9uLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fSAvLyBub3BlLCBmYWlsZWRcblxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzdWNjZXNzZnVsbHkgc2V0IHRoZSB2YWx1ZSBvZiB0aGlzIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1NFVF8nICsgbmFtZSwgeyB2YWx1ZTogc3RhdGUub3B0aW9uc1trZXldIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVPcHRpb25RdWVyaWVzID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uUXVlcmllcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgICAgZm9yaW4ob3B0aW9ucywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgb2JqWydHRVRfJyArIGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCldID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5vcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIEludGVyYWN0aW9uTWV0aG9kID0ge1xuICAgICAgICBBUEk6IDEsXG4gICAgICAgIERST1A6IDIsXG4gICAgICAgIEJST1dTRTogMyxcbiAgICAgICAgUEFTVEU6IDQsXG4gICAgICAgIE5PTkU6IDUsXG4gICAgfTtcblxuICAgIHZhciBnZXRVbmlxdWVJZCA9IGZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKVxuICAgICAgICAgICAgLnRvU3RyaW5nKDM2KVxuICAgICAgICAgICAgLnN1YnN0cmluZygyLCAxMSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJlxuICAgICAgICAgICAgICAgICAgICBvYmogIT09IFN5bWJvbC5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgICAgPyAnc3ltYm9sJ1xuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbiAgICB9XG5cbiAgICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG4gICAgZnVuY3Rpb24gX2pzeCh0eXBlLCBwcm9wcywga2V5LCBjaGlsZHJlbikge1xuICAgICAgICBpZiAoIVJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID1cbiAgICAgICAgICAgICAgICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAgICAgICAgICAgICAweGVhYzc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDM7XG5cbiAgICAgICAgaWYgKCFwcm9wcyAmJiBjaGlsZHJlbkxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IHZvaWQgMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMgJiYgZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgICBwcm9wcyA9IGRlZmF1bHRQcm9wcyB8fCB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEFycmF5ID0gbmV3IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgM107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGtleToga2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogJycgKyBrZXksXG4gICAgICAgICAgICByZWY6IG51bGwsXG4gICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICBfb3duZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FzeW5jSXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIG1ldGhvZDtcblxuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9IG51bGwpIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT0gbnVsbCkgcmV0dXJuIG1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBpcyBub3QgYXN5bmMgaXRlcmFibGUnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfQXdhaXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLndyYXBwZWQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfQXN5bmNHZW5lcmF0b3IoZ2VuKSB7XG4gICAgICAgIHZhciBmcm9udCwgYmFjaztcblxuICAgICAgICBmdW5jdGlvbiBzZW5kKGtleSwgYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICBhcmc6IGFyZyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0OiByZWplY3QsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2sgPSBiYWNrLm5leHQgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb250ID0gYmFjayA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VtZShrZXksIGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXN1bWUoa2V5LCBhcmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkQXdhaXQgPSB2YWx1ZSBpbnN0YW5jZW9mIF9Bd2FpdFZhbHVlO1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh3cmFwcGVkQXdhaXQgPyB2YWx1ZS53cmFwcGVkIDogdmFsdWUpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdyYXBwZWRBd2FpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZSgnbmV4dCcsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0bGUocmVzdWx0LmRvbmUgPyAncmV0dXJuJyA6ICdub3JtYWwnLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZSgndGhyb3cnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHNldHRsZSgndGhyb3cnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyZXR1cm4nOlxuICAgICAgICAgICAgICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3Rocm93JzpcbiAgICAgICAgICAgICAgICAgICAgZnJvbnQucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyb250ID0gZnJvbnQubmV4dDtcblxuICAgICAgICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgICAgICAgICAgcmVzdW1lKGZyb250LmtleSwgZnJvbnQuYXJnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFjayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnZva2UgPSBzZW5kO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZ2VuLnJldHVybiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5yZXR1cm4gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvcikge1xuICAgICAgICBfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UoJ25leHQnLCBhcmcpO1xuICAgIH07XG5cbiAgICBfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UoJ3Rocm93JywgYXJnKTtcbiAgICB9O1xuXG4gICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZSgncmV0dXJuJywgYXJnKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX3dyYXBBc3luY0dlbmVyYXRvcihmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9Bc3luY0dlbmVyYXRvcihmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXdhaXRBc3luY0dlbmVyYXRvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IF9Bd2FpdFZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZShpbm5lciwgYXdhaXRXcmFwKSB7XG4gICAgICAgIHZhciBpdGVyID0ge30sXG4gICAgICAgICAgICB3YWl0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gcHVtcChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoaW5uZXJba2V5XSh2YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhd2FpdFdyYXAodmFsdWUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgICAgICAgaXRlcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlci5uZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgICAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHB1bXAoJ25leHQnLCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbm5lci50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaXRlci50aHJvdyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdhaXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHVtcCgndGhyb3cnLCB2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbm5lci5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGl0ZXIucmV0dXJuID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVtcCgncmV0dXJuJywgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csICduZXh0JywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCAndGhyb3cnLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgICAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2RlZmluZUVudW1lcmFibGVQcm9wZXJ0aWVzKG9iaiwgZGVzY3MpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRlc2NzKSB7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IGRlc2NzW2tleV07XG4gICAgICAgICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IGRlc2MuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAgdmFyIG9iamVjdFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGRlc2NzKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5bSA9IG9iamVjdFN5bWJvbHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBkZXNjc1tzeW1dO1xuICAgICAgICAgICAgICAgIGRlc2MuY29uZmlndXJhYmxlID0gZGVzYy5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBzeW0sIGRlc2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVmYXVsdHMob2JqLCBkZWZhdWx0cykge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlZmF1bHRzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0cywga2V5KTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbmZpZ3VyYWJsZSAmJiBvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgICAgIF9leHRlbmRzID1cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24gfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICAgICAgICBpZiAoZW51bWVyYWJsZU9ubHkpXG4gICAgICAgICAgICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICAgICAgICAgIGlmIChpICUgMikge1xuICAgICAgICAgICAgICAgIG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICAgICAgICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZlxuICAgICAgICAgICAgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgICAgICAgICAgIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgX3NldFByb3RvdHlwZU9mID1cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgICAgICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgICAgICAgICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICAgICAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgIT09IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICAgICAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICAgICAgICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgICAgICAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbnN0YW5jZW9mKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCAhPSBudWxsICYmIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIHJpZ2h0W1N5bWJvbC5oYXNJbnN0YW5jZV0pIHtcbiAgICAgICAgICAgIHJldHVybiAhIXJpZ2h0W1N5bWJvbC5oYXNJbnN0YW5jZV0obGVmdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdCBpbnN0YW5jZW9mIHJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZVxuICAgICAgICAgICAgPyBvYmpcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDogb2JqLFxuICAgICAgICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgICAgICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5ld09iaiA9IHt9O1xuXG4gICAgICAgICAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcbiAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfbmV3QXJyb3dDaGVjayhpbm5lclRoaXMsIGJvdW5kVGhpcykge1xuICAgICAgICBpZiAoaW5uZXJUaGlzICE9PSBib3VuZFRoaXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBpbnN0YW50aWF0ZSBhbiBhcnJvdyBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX29iamVjdERlc3RydWN0dXJpbmdFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgZGVzdHJ1Y3R1cmUgdW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICAgICAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHt9O1xuICAgICAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIHZhciBrZXksIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gICAgICAgIHZhciBrZXksIGk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgICAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGNhbGwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5zZXQpIHtcbiAgICAgICAgICAgIHNldCA9IFJlZmxlY3Quc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVzYztcblxuICAgICAgICAgICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyZWNlaXZlciwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkZXNjLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3NldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIsIGlzU3RyaWN0KSB7XG4gICAgICAgIHZhciBzID0gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciB8fCB0YXJnZXQpO1xuXG4gICAgICAgIGlmICghcyAmJiBpc1N0cmljdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gc2V0IHByb3BlcnR5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChzdHJpbmdzLCByYXcpIHtcbiAgICAgICAgaWYgKCFyYXcpIHtcbiAgICAgICAgICAgIHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHN0cmluZ3MsIHtcbiAgICAgICAgICAgICAgICByYXc6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IE9iamVjdC5mcmVlemUocmF3KSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2Uoc3RyaW5ncywgcmF3KSB7XG4gICAgICAgIGlmICghcmF3KSB7XG4gICAgICAgICAgICByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyaW5ncy5yYXcgPSByYXc7XG4gICAgICAgIHJldHVybiBzdHJpbmdzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90ZW1wb3JhbFJlZih2YWwsIG5hbWUpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gX3RlbXBvcmFsVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IobmFtZSArICcgaXMgbm90IGRlZmluZWQgLSB0ZW1wb3JhbCBkZWFkIHpvbmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVhZE9ubHlFcnJvcihuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgbmFtZSArICdcIiBpcyByZWFkLW9ubHknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NOYW1lVERaRXJyb3IobmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsYXNzIFwiJyArIG5hbWUgKyAnXCIgY2Fubm90IGJlIHJlZmVyZW5jZWQgaW4gY29tcHV0ZWQgcHJvcGVydHkga2V5cy4nKTtcbiAgICB9XG5cbiAgICB2YXIgX3RlbXBvcmFsVW5kZWZpbmVkID0ge307XG5cbiAgICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICAgICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheUxvb3NlKGFyciwgaSkge1xuICAgICAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0TG9vc2UoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3RvQXJyYXkoYXJyKSB7XG4gICAgICAgIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICAgICAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgICAgICAgICByZXR1cm4gYXJyMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSAnW29iamVjdCBBcmd1bWVudHNdJ1xuICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgICAgIHZhciBfYXJyID0gW107XG4gICAgICAgIHZhciBfbiA9IHRydWU7XG4gICAgICAgIHZhciBfZCA9IGZhbHNlO1xuICAgICAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kID0gdHJ1ZTtcbiAgICAgICAgICAgIF9lID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9uICYmIF9pWydyZXR1cm4nXSAhPSBudWxsKSBfaVsncmV0dXJuJ10oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkge1xuICAgICAgICB2YXIgX2FyciA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKSB7XG4gICAgICAgICAgICBfYXJyLnB1c2goX3N0ZXAudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2FycjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9za2lwRmlyc3RHZW5lcmF0b3JOZXh0KGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpdC5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gaXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gICAgICAgIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcblxuICAgICAgICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8ICdkZWZhdWx0Jyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcyAhPT0gJ29iamVjdCcpIHJldHVybiByZXM7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChoaW50ID09PSAnc3RyaW5nJyA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICAgICAgICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgJ3N0cmluZycpO1xuXG4gICAgICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSAnc3ltYm9sJyA/IGtleSA6IFN0cmluZyhrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbml0aWFsaXplcldhcm5pbmdIZWxwZXIoZGVzY3JpcHRvciwgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICtcbiAgICAgICAgICAgICAgICAncHJvcG9zYWwtY2xhc3MtcHJvcGVydGllcyBpcyBlbmFibGVkIGFuZCBzZXQgdG8gdXNlIGxvb3NlIG1vZGUuICcgK1xuICAgICAgICAgICAgICAgICdUbyB1c2UgcHJvcG9zYWwtY2xhc3MtcHJvcGVydGllcyBpbiBzcGVjIG1vZGUgd2l0aCBkZWNvcmF0b3JzLCB3YWl0IGZvciAnICtcbiAgICAgICAgICAgICAgICAndGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBkZWNvcmF0b3JzIGluIHN0YWdlIDIuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFkZXNjcmlwdG9yKSByZXR1cm47XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsXG4gICAgICAgICAgICB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplciA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBkZXNjID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICBkZXNjLmVudW1lcmFibGUgPSAhIWRlc2MuZW51bWVyYWJsZTtcbiAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlO1xuXG4gICAgICAgIGlmICgndmFsdWUnIGluIGRlc2MgfHwgZGVzYy5pbml0aWFsaXplcikge1xuICAgICAgICAgICAgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBkZXNjID0gZGVjb3JhdG9yc1xuICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24oZGVzYywgZGVjb3JhdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5LCBkZXNjKSB8fCBkZXNjO1xuICAgICAgICAgICAgfSwgZGVzYyk7XG5cbiAgICAgICAgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDtcbiAgICAgICAgICAgIGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy5pbml0aWFsaXplciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYyk7XG4gICAgICAgICAgICBkZXNjID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cblxuICAgIHZhciBpZCA9IDA7XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRMb29zZUtleShuYW1lKSB7XG4gICAgICAgIHJldHVybiAnX19wcml2YXRlXycgKyBpZCsrICsgJ18nICsgbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRMb29zZUJhc2UocmVjZWl2ZXIsIHByaXZhdGVLZXkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVjZWl2ZXIsIHByaXZhdGVLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gdXNlIHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVjZWl2ZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xuXG4gICAgICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xuXG4gICAgICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWRlc2NyaXB0b3Iud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHJlYWQgb25seSBwcml2YXRlIGZpZWxkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGREZXN0cnVjdHVyZVNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xuICAgICAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgICAgICBpZiAoISgnX19kZXN0ck9iaicgaW4gZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLl9fZGVzdHJPYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIHNldCB2YWx1ZSh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5fX2Rlc3RyT2JqO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1N0YXRpY1ByaXZhdGVGaWVsZFNwZWNHZXQocmVjZWl2ZXIsIGNsYXNzQ29uc3RydWN0b3IsIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZUZpZWxkU3BlY1NldChyZWNlaXZlciwgY2xhc3NDb25zdHJ1Y3RvciwgZGVzY3JpcHRvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHJlYWQgb25seSBwcml2YXRlIGZpZWxkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NTdGF0aWNQcml2YXRlTWV0aG9kR2V0KHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yLCBtZXRob2QpIHtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NTdGF0aWNQcml2YXRlTWV0aG9kU2V0KCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHJlYWQgb25seSBzdGF0aWMgcHJpdmF0ZSBmaWVsZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9kZWNvcmF0ZShkZWNvcmF0b3JzLCBmYWN0b3J5LCBzdXBlckNsYXNzLCBtaXhpbnMpIHtcbiAgICAgICAgdmFyIGFwaSA9IF9nZXREZWNvcmF0b3JzQXBpKCk7XG5cbiAgICAgICAgaWYgKG1peGlucykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcGkgPSBtaXhpbnNbaV0oYXBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByID0gZmFjdG9yeShmdW5jdGlvbiBpbml0aWFsaXplKE8pIHtcbiAgICAgICAgICAgIGFwaS5pbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBkZWNvcmF0ZWQuZWxlbWVudHMpO1xuICAgICAgICB9LCBzdXBlckNsYXNzKTtcbiAgICAgICAgdmFyIGRlY29yYXRlZCA9IGFwaS5kZWNvcmF0ZUNsYXNzKFxuICAgICAgICAgICAgX2NvYWxlc2NlQ2xhc3NFbGVtZW50cyhyLmQubWFwKF9jcmVhdGVFbGVtZW50RGVzY3JpcHRvcikpLFxuICAgICAgICAgICAgZGVjb3JhdG9yc1xuICAgICAgICApO1xuICAgICAgICBhcGkuaW5pdGlhbGl6ZUNsYXNzRWxlbWVudHMoci5GLCBkZWNvcmF0ZWQuZWxlbWVudHMpO1xuICAgICAgICByZXR1cm4gYXBpLnJ1bkNsYXNzRmluaXNoZXJzKHIuRiwgZGVjb3JhdGVkLmZpbmlzaGVycyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7XG4gICAgICAgIF9nZXREZWNvcmF0b3JzQXBpID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcGkgPSB7XG4gICAgICAgICAgICBlbGVtZW50c0RlZmluaXRpb25PcmRlcjogW1snbWV0aG9kJ10sIFsnZmllbGQnXV0sXG4gICAgICAgICAgICBpbml0aWFsaXplSW5zdGFuY2VFbGVtZW50czogZnVuY3Rpb24oTywgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBbJ21ldGhvZCcsICdmaWVsZCddLmZvckVhY2goZnVuY3Rpb24oa2luZCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09IGtpbmQgJiYgZWxlbWVudC5wbGFjZW1lbnQgPT09ICdvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbmVDbGFzc0VsZW1lbnQoTywgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluaXRpYWxpemVDbGFzc0VsZW1lbnRzOiBmdW5jdGlvbihGLCBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHZhciBwcm90byA9IEYucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIFsnbWV0aG9kJywgJ2ZpZWxkJ10uZm9yRWFjaChmdW5jdGlvbihraW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IGVsZW1lbnQucGxhY2VtZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5raW5kID09PSBraW5kICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBsYWNlbWVudCA9PT0gJ3N0YXRpYycgfHwgcGxhY2VtZW50ID09PSAncHJvdG90eXBlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHBsYWNlbWVudCA9PT0gJ3N0YXRpYycgPyBGIDogcHJvdG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbmVDbGFzc0VsZW1lbnQocmVjZWl2ZXIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZpbmVDbGFzc0VsZW1lbnQ6IGZ1bmN0aW9uKHJlY2VpdmVyLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBlbGVtZW50LmRlc2NyaXB0b3I7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSAnZmllbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXRpYWxpemVyLmNhbGwocmVjZWl2ZXIpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgZWxlbWVudC5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29yYXRlQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0VsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnRzID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBwcm90b3R5cGU6IFtdLFxuICAgICAgICAgICAgICAgICAgICBvd246IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSkgcmV0dXJuIG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50RmluaXNoZXJzRXh0cmFzID0gdGhpcy5kZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudEZpbmlzaGVyc0V4dHJhcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RWxlbWVudHMucHVzaC5hcHBseShuZXdFbGVtZW50cywgZWxlbWVudEZpbmlzaGVyc0V4dHJhcy5leHRyYXMpO1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZmluaXNoZXJzKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIGlmICghZGVjb3JhdG9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IG5ld0VsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzOiBmaW5pc2hlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZGVjb3JhdGVDb25zdHJ1Y3RvcihuZXdFbGVtZW50cywgZGVjb3JhdG9ycyk7XG4gICAgICAgICAgICAgICAgZmluaXNoZXJzLnB1c2guYXBwbHkoZmluaXNoZXJzLCByZXN1bHQuZmluaXNoZXJzKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuZmluaXNoZXJzID0gZmluaXNoZXJzO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkRWxlbWVudFBsYWNlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgcGxhY2VtZW50cywgc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBwbGFjZW1lbnRzW2VsZW1lbnQucGxhY2VtZW50XTtcblxuICAgICAgICAgICAgICAgIGlmICghc2lsZW50ICYmIGtleXMuaW5kZXhPZihlbGVtZW50LmtleSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0R1cGxpY2F0ZWQgZWxlbWVudCAoJyArIGVsZW1lbnQua2V5ICsgJyknKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goZWxlbWVudC5rZXkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29yYXRlRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgIHZhciBleHRyYXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkZWNvcmF0b3JzID0gZWxlbWVudC5kZWNvcmF0b3JzLCBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdO1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnNwbGljZShrZXlzLmluZGV4T2YoZWxlbWVudC5rZXkpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRPYmplY3QgPSB0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRGaW5pc2hlckV4dHJhcyA9IHRoaXMudG9FbGVtZW50RmluaXNoZXJFeHRyYXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgZGVjb3JhdG9yc1tpXSkoZWxlbWVudE9iamVjdCkgfHwgZWxlbWVudE9iamVjdFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlcnMucHVzaChlbGVtZW50RmluaXNoZXJFeHRyYXMuZmluaXNoZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0V4dHJhcyA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5leHRyYXM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0V4dHJhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZXdFeHRyYXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQobmV3RXh0cmFzW2pdLCBwbGFjZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFzLnB1c2guYXBwbHkoZXh0cmFzLCBuZXdFeHRyYXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzOiBmaW5pc2hlcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhczogZXh0cmFzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb3JhdGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24oZWxlbWVudHMsIGRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5mcm9tQ2xhc3NEZXNjcmlwdG9yKGVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzQW5kRmluaXNoZXIgPSB0aGlzLnRvQ2xhc3NEZXNjcmlwdG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGRlY29yYXRvcnNbaV0pKG9iaikgfHwgb2JqXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzLnB1c2goZWxlbWVudHNBbmRGaW5pc2hlci5maW5pc2hlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlbWVudHMubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbal0ua2V5ID09PSBlbGVtZW50c1trXS5rZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW2pdLnBsYWNlbWVudCA9PT0gZWxlbWVudHNba10ucGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRHVwbGljYXRlZCBlbGVtZW50ICgnICsgZWxlbWVudHNbal0ua2V5ICsgJyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlcnM6IGZpbmlzaGVycyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb21FbGVtZW50RGVzY3JpcHRvcjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IGVsZW1lbnQua2luZCxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBlbGVtZW50LmtleSxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiBlbGVtZW50LnBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvcjogZWxlbWVudC5kZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnRGVzY3JpcHRvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFN5bWJvbC50b1N0cmluZ1RhZywgZGVzYyk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQua2luZCA9PT0gJ2ZpZWxkJykgb2JqLmluaXRpYWxpemVyID0gZWxlbWVudC5pbml0aWFsaXplcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvRWxlbWVudERlc2NyaXB0b3JzOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50T2JqZWN0cyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b0FycmF5KGVsZW1lbnRPYmplY3RzKS5tYXAoZnVuY3Rpb24oZWxlbWVudE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsICdmaW5pc2hlcicsICdBbiBlbGVtZW50IGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsICdleHRyYXMnLCAnQW4gZWxlbWVudCBkZXNjcmlwdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIga2luZCA9IFN0cmluZyhlbGVtZW50T2JqZWN0LmtpbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09ICdtZXRob2QnICYmIGtpbmQgIT09ICdmaWVsZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgZWl0aGVyIFwibWV0aG9kXCIgb3InICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIFwiZmllbGRcIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yIHdpdGgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIC5raW5kIFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfdG9Qcm9wZXJ0eUtleShlbGVtZW50T2JqZWN0LmtleSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGxhY2VtZW50ID0gU3RyaW5nKGVsZW1lbnRPYmplY3QucGxhY2VtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmIChwbGFjZW1lbnQgIT09ICdzdGF0aWMnICYmIHBsYWNlbWVudCAhPT0gJ3Byb3RvdHlwZScgJiYgcGxhY2VtZW50ICE9PSAnb3duJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvclxcJ3MgLnBsYWNlbWVudCBwcm9wZXJ0eSBtdXN0IGJlIG9uZSBvZiBcInN0YXRpY1wiLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgXCJwcm90b3R5cGVcIiBvciBcIm93blwiLCBidXQgYSBkZWNvcmF0b3IgY3JlYXRlZCBhbiBlbGVtZW50IGRlc2NyaXB0b3InICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggLnBsYWNlbWVudCBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudE9iamVjdC5kZXNjcmlwdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZWxlbWVudHMnLCAnQW4gZWxlbWVudCBkZXNjcmlwdG9yJyk7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvcjogT2JqZWN0LmFzc2lnbih7fSwgZGVzY3JpcHRvciksXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChraW5kICE9PSAnZmllbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnaW5pdGlhbGl6ZXInLCAnQSBtZXRob2QgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3InXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3InXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvcidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbml0aWFsaXplciA9IGVsZW1lbnRPYmplY3QuaW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9FbGVtZW50RmluaXNoZXJFeHRyYXM6IGZ1bmN0aW9uKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KTtcblxuICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkoZWxlbWVudE9iamVjdCwgJ2ZpbmlzaGVyJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhlbGVtZW50T2JqZWN0LmV4dHJhcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXI6IGZpbmlzaGVyLFxuICAgICAgICAgICAgICAgICAgICBleHRyYXM6IGV4dHJhcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb21DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogJ2NsYXNzJyxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLm1hcCh0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvciwgdGhpcyksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICdEZXNjcmlwdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvQ2xhc3NEZXNjcmlwdG9yOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICB2YXIga2luZCA9IFN0cmluZyhvYmoua2luZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0EgY2xhc3MgZGVzY3JpcHRvclxcJ3MgLmtpbmQgcHJvcGVydHkgbXVzdCBiZSBcImNsYXNzXCIsIGJ1dCBhIGRlY29yYXRvcicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgY3JlYXRlZCBhIGNsYXNzIGRlc2NyaXB0b3Igd2l0aCAua2luZCBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAna2V5JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosICdwbGFjZW1lbnQnLCAnQSBjbGFzcyBkZXNjcmlwdG9yJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2Rlc2NyaXB0b3InLCAnQSBjbGFzcyBkZXNjcmlwdG9yJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2luaXRpYWxpemVyJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosICdleHRyYXMnLCAnQSBjbGFzcyBkZXNjcmlwdG9yJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmluaXNoZXIgPSBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KG9iaiwgJ2ZpbmlzaGVyJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3JzKG9iai5lbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlcjogZmluaXNoZXIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5DbGFzc0ZpbmlzaGVyczogZnVuY3Rpb24oY29uc3RydWN0b3IsIGZpbmlzaGVycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluaXNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDb25zdHJ1Y3RvciA9ICgwLCBmaW5pc2hlcnNbaV0pKGNvbnN0cnVjdG9yKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q29uc3RydWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdDb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpbmlzaGVycyBtdXN0IHJldHVybiBhIGNvbnN0cnVjdG9yLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG5ld0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc2FsbG93UHJvcGVydHk6IGZ1bmN0aW9uKG9iaiwgbmFtZSwgb2JqZWN0VHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChvYmpbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG9iamVjdFR5cGUgKyBcIiBjYW4ndCBoYXZlIGEgLlwiICsgbmFtZSArICcgcHJvcGVydHkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IoZGVmKSB7XG4gICAgICAgIHZhciBrZXkgPSBfdG9Qcm9wZXJ0eUtleShkZWYua2V5KTtcblxuICAgICAgICB2YXIgZGVzY3JpcHRvcjtcblxuICAgICAgICBpZiAoZGVmLmtpbmQgPT09ICdtZXRob2QnKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkZWYudmFsdWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gJ2dldCcpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgZ2V0OiBkZWYudmFsdWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgc2V0OiBkZWYudmFsdWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gJ2ZpZWxkJykge1xuICAgICAgICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgICAgIGtpbmQ6IGRlZi5raW5kID09PSAnZmllbGQnID8gJ2ZpZWxkJyA6ICdtZXRob2QnLFxuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICBwbGFjZW1lbnQ6IGRlZi5zdGF0aWMgPyAnc3RhdGljJyA6IGRlZi5raW5kID09PSAnZmllbGQnID8gJ293bicgOiAncHJvdG90eXBlJyxcbiAgICAgICAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWYuZGVjb3JhdG9ycykgZWxlbWVudC5kZWNvcmF0b3JzID0gZGVmLmRlY29yYXRvcnM7XG4gICAgICAgIGlmIChkZWYua2luZCA9PT0gJ2ZpZWxkJykgZWxlbWVudC5pbml0aWFsaXplciA9IGRlZi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmRlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG90aGVyLmRlc2NyaXB0b3IuZ2V0ID0gZWxlbWVudC5kZXNjcmlwdG9yLmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG90aGVyLmRlc2NyaXB0b3Iuc2V0ID0gZWxlbWVudC5kZXNjcmlwdG9yLnNldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIG5ld0VsZW1lbnRzID0gW107XG5cbiAgICAgICAgdmFyIGlzU2FtZUVsZW1lbnQgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBvdGhlci5raW5kID09PSAnbWV0aG9kJyAmJlxuICAgICAgICAgICAgICAgIG90aGVyLmtleSA9PT0gZWxlbWVudC5rZXkgJiZcbiAgICAgICAgICAgICAgICBvdGhlci5wbGFjZW1lbnQgPT09IGVsZW1lbnQucGxhY2VtZW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICB2YXIgb3RoZXI7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09ICdtZXRob2QnICYmIChvdGhlciA9IG5ld0VsZW1lbnRzLmZpbmQoaXNTYW1lRWxlbWVudCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9pc0RhdGFEZXNjcmlwdG9yKGVsZW1lbnQuZGVzY3JpcHRvcikgfHwgX2lzRGF0YURlc2NyaXB0b3Iob3RoZXIuZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpIHx8IF9oYXNEZWNvcmF0b3JzKG90aGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdEdXBsaWNhdGVkIG1ldGhvZHMgKCcgKyBlbGVtZW50LmtleSArIFwiKSBjYW4ndCBiZSBkZWNvcmF0ZWQuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9oYXNEZWNvcmF0b3JzKG90aGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJEZWNvcmF0b3JzIGNhbid0IGJlIHBsYWNlZCBvbiBkaWZmZXJlbnQgYWNjZXNzb3JzIHdpdGggZm9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0aGUgc2FtZSBwcm9wZXJ0eSAoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmtleSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKS4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9jb2FsZXNjZUdldHRlclNldHRlcihlbGVtZW50LCBvdGhlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld0VsZW1lbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuZGVjb3JhdG9ycyAmJiBlbGVtZW50LmRlY29yYXRvcnMubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pc0RhdGFEZXNjcmlwdG9yKGRlc2MpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MgIT09IHVuZGVmaW5lZCAmJiAhKGRlc2MudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBkZXNjLndyaXRhYmxlID09PSB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCBuYW1lKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtuYW1lXTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBuYW1lICsgXCInIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZU1ldGhvZEdldChyZWNlaXZlciwgcHJpdmF0ZVNldCwgZm4pIHtcbiAgICAgICAgaWYgKCFwcml2YXRlU2V0LmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlTWV0aG9kU2V0KCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gcmVhc3NpZ24gcHJpdmF0ZSBtZXRob2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfd3JhcFJlZ0V4cChyZSwgZ3JvdXBzKSB7XG4gICAgICAgIF93cmFwUmVnRXhwID0gZnVuY3Rpb24ocmUsIGdyb3Vwcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCYWJlbFJlZ0V4cChyZSwgZ3JvdXBzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX1JlZ0V4cCA9IF93cmFwTmF0aXZlU3VwZXIoUmVnRXhwKTtcblxuICAgICAgICB2YXIgX3N1cGVyID0gUmVnRXhwLnByb3RvdHlwZTtcblxuICAgICAgICB2YXIgX2dyb3VwcyA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gQmFiZWxSZWdFeHAocmUsIGdyb3Vwcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX1JlZ0V4cC5jYWxsKHRoaXMsIHJlKTtcblxuICAgICAgICAgICAgX2dyb3Vwcy5zZXQoX3RoaXMsIGdyb3Vwcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIF9pbmhlcml0cyhCYWJlbFJlZ0V4cCwgX1JlZ0V4cCk7XG5cbiAgICAgICAgQmFiZWxSZWdFeHAucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIuZXhlYy5jYWxsKHRoaXMsIHN0cik7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdC5ncm91cHMgPSBidWlsZEdyb3VwcyhyZXN1bHQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBCYWJlbFJlZ0V4cC5wcm90b3R5cGVbU3ltYm9sLnJlcGxhY2VdID0gZnVuY3Rpb24oc3RyLCBzdWJzdGl0dXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3Vic3RpdHV0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBncm91cHMgPSBfZ3JvdXBzLmdldCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHN0cixcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uLnJlcGxhY2UoL1xcJDwoW14+XSspPi9nLCBmdW5jdGlvbihfLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyQnICsgZ3JvdXBzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJzdGl0dXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcltTeW1ib2wucmVwbGFjZV0uY2FsbCh0aGlzLCBzdHIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChidWlsZEdyb3VwcyhhcmdzLCBfdGhpcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcltTeW1ib2wucmVwbGFjZV0uY2FsbCh0aGlzLCBzdHIsIHN1YnN0aXR1dGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRHcm91cHMocmVzdWx0LCByZSkge1xuICAgICAgICAgICAgdmFyIGcgPSBfZ3JvdXBzLmdldChyZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhnKS5yZWR1Y2UoZnVuY3Rpb24oZ3JvdXBzLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW25hbWVdID0gcmVzdWx0W2dbbmFtZV1dO1xuICAgICAgICAgICAgICAgIHJldHVybiBncm91cHM7XG4gICAgICAgICAgICB9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfd3JhcFJlZ0V4cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHZhciBhcnJheVJlbW92ZSA9IGZ1bmN0aW9uIGFycmF5UmVtb3ZlKGFyciwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG5cbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gcnVuKGNiLCBzeW5jKSB7XG4gICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKDEpLnRoZW4oY2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9uID0gZnVuY3Rpb24gb24oKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdmFyIG9mZiA9IGZ1bmN0aW9uIG9mZihldmVudCwgY2IpIHtcbiAgICAgICAgICAgIGFycmF5UmVtb3ZlKFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZmluZEluZGV4KGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5ldmVudCA9PT0gZXZlbnQgJiYgKGxpc3RlbmVyLmNiID09PSBjYiB8fCAhY2IpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgX2ZpcmUgPSBmdW5jdGlvbiBmaXJlKGV2ZW50LCBhcmdzLCBzeW5jKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5ldmVudCA9PT0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IuYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJncykpO1xuICAgICAgICAgICAgICAgICAgICB9LCBzeW5jKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpcmVTeW5jOiBmdW5jdGlvbiBmaXJlU3luYyhldmVudCkge1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2tleSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9maXJlKGV2ZW50LCBhcmdzLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXJlOiBmdW5jdGlvbiBmaXJlKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBfa2V5MiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIF9rZXkyIDwgX2xlbjI7XG4gICAgICAgICAgICAgICAgICAgIF9rZXkyKytcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2ZpcmUoZXZlbnQsIGFyZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbjogZnVuY3Rpb24gb24oZXZlbnQsIGNiKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goeyBldmVudDogZXZlbnQsIGNiOiBjYiB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbk9uY2U6IGZ1bmN0aW9uIG9uT25jZShldmVudCwgX2NiKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGNiOiBmdW5jdGlvbiBjYigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZihldmVudCwgX2NiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jYi5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb2ZmOiBvZmYsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjb3B5T2JqZWN0UHJvcGVydGllc1RvT2JqZWN0ID0gZnVuY3Rpb24gY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdChcbiAgICAgICAgc3JjLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGV4Y2x1ZGVkXG4gICAgKSB7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNyYylcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWV4Y2x1ZGVkLmluY2x1ZGVzKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzcmMsIGtleSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBQUklWQVRFID0gW1xuICAgICAgICAnZmlyZScsXG4gICAgICAgICdwcm9jZXNzJyxcbiAgICAgICAgJ3JldmVydCcsXG4gICAgICAgICdsb2FkJyxcbiAgICAgICAgJ29uJyxcbiAgICAgICAgJ29mZicsXG4gICAgICAgICdvbk9uY2UnLFxuICAgICAgICAncmV0cnlMb2FkJyxcbiAgICAgICAgJ2V4dGVuZCcsXG4gICAgICAgICdhcmNoaXZlJyxcbiAgICAgICAgJ2FyY2hpdmVkJyxcbiAgICAgICAgJ3JlbGVhc2UnLFxuICAgICAgICAncmVsZWFzZWQnLFxuICAgICAgICAncmVxdWVzdFByb2Nlc3NpbmcnLFxuICAgICAgICAnZnJlZXplJyxcbiAgICBdO1xuXG4gICAgdmFyIGNyZWF0ZUl0ZW1BUEkgPSBmdW5jdGlvbiBjcmVhdGVJdGVtQVBJKGl0ZW0pIHtcbiAgICAgICAgdmFyIGFwaSA9IHt9O1xuICAgICAgICBjb3B5T2JqZWN0UHJvcGVydGllc1RvT2JqZWN0KGl0ZW0sIGFwaSwgUFJJVkFURSk7XG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVSZWxlYXNlZEl0ZW1zID0gZnVuY3Rpb24gcmVtb3ZlUmVsZWFzZWRJdGVtcyhpdGVtcykge1xuICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5yZWxlYXNlZCkge1xuICAgICAgICAgICAgICAgIGFycmF5UmVtb3ZlKGl0ZW1zLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgSXRlbVN0YXR1cyA9IHtcbiAgICAgICAgSU5JVDogMSxcbiAgICAgICAgSURMRTogMixcbiAgICAgICAgUFJPQ0VTU0lOR19RVUVVRUQ6IDksXG4gICAgICAgIFBST0NFU1NJTkc6IDMsXG4gICAgICAgIFBST0NFU1NJTkdfQ09NUExFVEU6IDUsXG4gICAgICAgIFBST0NFU1NJTkdfRVJST1I6IDYsXG4gICAgICAgIFBST0NFU1NJTkdfUkVWRVJUX0VSUk9SOiAxMCxcbiAgICAgICAgTE9BRElORzogNyxcbiAgICAgICAgTE9BRF9FUlJPUjogOCxcbiAgICB9O1xuXG4gICAgdmFyIEZpbGVPcmlnaW4gPSB7XG4gICAgICAgIElOUFVUOiAxLFxuICAgICAgICBMSU1CTzogMixcbiAgICAgICAgTE9DQUw6IDMsXG4gICAgfTtcblxuICAgIHZhciBnZXROb25OdW1lcmljID0gZnVuY3Rpb24gZ2V0Tm9uTnVtZXJpYyhzdHIpIHtcbiAgICAgICAgcmV0dXJuIC9bXjAtOV0rLy5leGVjKHN0cik7XG4gICAgfTtcblxuICAgIHZhciBnZXREZWNpbWFsU2VwYXJhdG9yID0gZnVuY3Rpb24gZ2V0RGVjaW1hbFNlcGFyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIGdldE5vbk51bWVyaWMoKDEuMSkudG9Mb2NhbGVTdHJpbmcoKSlbMF07XG4gICAgfTtcblxuICAgIHZhciBnZXRUaG91c2FuZHNTZXBhcmF0b3IgPSBmdW5jdGlvbiBnZXRUaG91c2FuZHNTZXBhcmF0b3IoKSB7XG4gICAgICAgIC8vIEFkZGVkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCByZXR1cm4gdGhlIHRob3VzYW5kcyBzZXBhcmF0b3IgKGhhcHBlbmQgb24gbmF0aXZlIGJyb3dzZXIgQW5kcm9pZCA0LjQuNClcbiAgICAgICAgLy8gV2UgY2hlY2sgYWdhaW5zdCB0aGUgbm9ybWFsIHRvU3RyaW5nIG91dHB1dCBhbmQgaWYgdGhleSdyZSB0aGUgc2FtZSByZXR1cm4gYSBjb21tYSB3aGVuIGRlY2ltYWwgc2VwYXJhdG9yIGlzIGEgZG90XG4gICAgICAgIHZhciBkZWNpbWFsU2VwYXJhdG9yID0gZ2V0RGVjaW1hbFNlcGFyYXRvcigpO1xuICAgICAgICB2YXIgdGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvciA9ICgxMDAwLjApLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgIHZhciB0aG91c2FuZHNTdHJpbmdXaXRob3V0U2VwYXJhdG9yID0gKDEwMDAuMCkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRob3VzYW5kc1N0cmluZ1dpdGhTZXBhcmF0b3IgIT09IHRob3VzYW5kc1N0cmluZ1dpdGhvdXRTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXROb25OdW1lcmljKHRob3VzYW5kc1N0cmluZ1dpdGhTZXBhcmF0b3IpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNpbWFsU2VwYXJhdG9yID09PSAnLicgPyAnLCcgOiAnLic7XG4gICAgfTtcblxuICAgIHZhciBUeXBlID0ge1xuICAgICAgICBCT09MRUFOOiAnYm9vbGVhbicsXG4gICAgICAgIElOVDogJ2ludCcsXG4gICAgICAgIE5VTUJFUjogJ251bWJlcicsXG4gICAgICAgIFNUUklORzogJ3N0cmluZycsXG4gICAgICAgIEFSUkFZOiAnYXJyYXknLFxuICAgICAgICBPQkpFQ1Q6ICdvYmplY3QnLFxuICAgICAgICBGVU5DVElPTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgQUNUSU9OOiAnYWN0aW9uJyxcbiAgICAgICAgU0VSVkVSX0FQSTogJ3NlcnZlcmFwaScsXG4gICAgICAgIFJFR0VYOiAncmVnZXgnLFxuICAgIH07XG5cbiAgICAvLyBhbGwgcmVnaXN0ZXJlZCBmaWx0ZXJzXG4gICAgdmFyIGZpbHRlcnMgPSBbXTtcblxuICAgIC8vIGxvb3BzIG92ZXIgbWF0Y2hpbmcgZmlsdGVycyBhbmQgcGFzc2VzIG9wdGlvbnMgdG8gZWFjaCBmaWx0ZXIsIHJldHVybmluZyB0aGUgbWFwcGVkIHJlc3VsdHNcbiAgICB2YXIgYXBwbHlGaWx0ZXJDaGFpbiA9IGZ1bmN0aW9uIGFwcGx5RmlsdGVyQ2hhaW4oa2V5LCB2YWx1ZSwgdXRpbHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gZmluZCBtYXRjaGluZyBmaWx0ZXJzIGZvciB0aGlzIGtleVxuICAgICAgICAgICAgdmFyIG1hdGNoaW5nRmlsdGVycyA9IGZpbHRlcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYua2V5ID09PSBrZXk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYuY2I7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHJlc29sdmUgbm93XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdGaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmlyc3QgZmlsdGVyIHRvIGtpY2sgdGhpbmdzIG9mXG4gICAgICAgICAgICB2YXIgaW5pdGlhbEZpbHRlciA9IG1hdGNoaW5nRmlsdGVycy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAvLyBjaGFpbiBmaWx0ZXJzXG4gICAgICAgICAgICBtYXRjaGluZ0ZpbHRlcnNcbiAgICAgICAgICAgICAgICAucmVkdWNlKFxuICAgICAgICAgICAgICAgICAgICAvLyBsb29wIG92ZXIgcHJvbWlzZXMgcGFzc2luZyB2YWx1ZSB0byBuZXh0IHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oY3VycmVudCwgbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KHZhbHVlLCB1dGlscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIGluaXRpYWwgZmlsdGVyLCB3aWxsIHJldHVybiBhIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbEZpbHRlcih2YWx1ZSwgdXRpbHMpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsIGV4ZWN1dGVkXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBhcHBseUZpbHRlcnMgPSBmdW5jdGlvbiBhcHBseUZpbHRlcnMoa2V5LCB2YWx1ZSwgdXRpbHMpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcnNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmLmtleSA9PT0ga2V5O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmLmNiKHZhbHVlLCB1dGlscyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gYWRkcyBhIG5ldyBmaWx0ZXIgdG8gdGhlIGxpc3RcbiAgICB2YXIgYWRkRmlsdGVyID0gZnVuY3Rpb24gYWRkRmlsdGVyKGtleSwgY2IpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcnMucHVzaCh7IGtleToga2V5LCBjYjogY2IgfSk7XG4gICAgfTtcblxuICAgIHZhciBleHRlbmREZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uIGV4dGVuZERlZmF1bHRPcHRpb25zKGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHZhciBnZXRPcHRpb25zID0gZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zKTtcbiAgICB9O1xuXG4gICAgdmFyIHNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdHMpIHtcbiAgICAgICAgZm9yaW4ob3B0cywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8ga2V5IGRvZXMgbm90IGV4aXN0LCBzbyB0aGlzIG9wdGlvbiBjYW5ub3QgYmUgc2V0XG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRPcHRpb25zW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzBdID0gZ2V0VmFsdWVCeVR5cGUoXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XVswXSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzFdXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gZGVmYXVsdCBvcHRpb25zIG9uIGFwcFxuICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgLy8gdGhlIGlkIHRvIGFkZCB0byB0aGUgcm9vdCBlbGVtZW50XG4gICAgICAgIGlkOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIC8vIGlucHV0IGZpZWxkIG5hbWUgdG8gdXNlXG4gICAgICAgIG5hbWU6IFsnZmlsZXBvbmQnLCBUeXBlLlNUUklOR10sXG5cbiAgICAgICAgLy8gZGlzYWJsZSB0aGUgZmllbGRcbiAgICAgICAgZGlzYWJsZWQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBjbGFzc25hbWUgdG8gcHV0IG9uIHdyYXBwZXJcbiAgICAgICAgY2xhc3NOYW1lOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIC8vIGlzIHRoZSBmaWVsZCByZXF1aXJlZFxuICAgICAgICByZXF1aXJlZDogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIEFsbG93IG1lZGlhIGNhcHR1cmUgd2hlbiB2YWx1ZSBpcyBzZXRcbiAgICAgICAgY2FwdHVyZU1ldGhvZDogW251bGwsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgLy8gLSBcImNhbWVyYVwiLCBcIm1pY3JvcGhvbmVcIiBvciBcImNhbWNvcmRlclwiLFxuICAgICAgICAvLyAtIERvZXMgbm90IHdvcmsgd2l0aCBtdWx0aXBsZSBvbiBhcHBsZSBkZXZpY2VzXG4gICAgICAgIC8vIC0gSWYgc2V0LCBhY2NlcHRlZEZpbGVUeXBlcyBtdXN0IGJlIG1hZGUgdG8gbWF0Y2ggd2l0aCBtZWRpYSB3aWxkY2FyZCBcImltYWdlLypcIiwgXCJhdWRpby8qXCIgb3IgXCJ2aWRlby8qXCJcblxuICAgICAgICAvLyBzeW5jIGBhY2NlcHRlZEZpbGVUeXBlc2AgcHJvcGVydHkgd2l0aCBgYWNjZXB0YCBhdHRyaWJ1dGVcbiAgICAgICAgYWxsb3dTeW5jQWNjZXB0QXR0cmlidXRlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBGZWF0dXJlIHRvZ2dsZXNcbiAgICAgICAgYWxsb3dEcm9wOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgZHJvcHBpbmcgb2YgZmlsZXNcbiAgICAgICAgYWxsb3dCcm93c2U6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBicm93c2luZyB0aGUgZmlsZSBzeXN0ZW1cbiAgICAgICAgYWxsb3dQYXN0ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHBhc3RpbmcgZmlsZXNcbiAgICAgICAgYWxsb3dNdWx0aXBsZTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBtdWx0aXBsZSBmaWxlcyAoZGlzYWJsZWQgYnkgZGVmYXVsdCwgYXMgbXVsdGlwbGUgYXR0cmlidXRlIGlzIGFsc28gcmVxdWlyZWQgb24gaW5wdXQgdG8gYWxsb3cgbXVsdGlwbGUpXG4gICAgICAgIGFsbG93UmVwbGFjZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IGRyb3BwaW5nIGEgZmlsZSBvbiBvdGhlciBmaWxlIHRvIHJlcGxhY2UgaXQgKG9ubHkgd29ya3Mgd2hlbiBtdWx0aXBsZSBpcyBzZXQgdG8gZmFsc2UpXG4gICAgICAgIGFsbG93UmV2ZXJ0OiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3dzIHVzZXIgdG8gcmV2ZXJ0IGZpbGUgdXBsb2FkXG4gICAgICAgIGFsbG93UmVtb3ZlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgdXNlciB0byByZW1vdmUgYSBmaWxlXG4gICAgICAgIGFsbG93UHJvY2VzczogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93cyB1c2VyIHRvIHByb2Nlc3MgYSBmaWxlLCB3aGVuIHNldCB0byBmYWxzZSwgdGhpcyByZW1vdmVzIHRoZSBmaWxlIHVwbG9hZCBidXR0b25cbiAgICAgICAgYWxsb3dSZW9yZGVyOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHJlb3JkZXJpbmcgb2YgZmlsZXNcbiAgICAgICAgYWxsb3dEaXJlY3Rvcmllc09ubHk6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgb25seSBzZWxlY3RpbmcgZGlyZWN0b3JpZXMgd2l0aCBicm93c2UgKG5vIHN1cHBvcnQgZm9yIGZpbHRlcmluZyBkbmQgYXQgdGhpcyBwb2ludClcblxuICAgICAgICAvLyBUcnkgc3RvcmUgZmlsZSBpZiBgc2VydmVyYCBub3Qgc2V0XG4gICAgICAgIHN0b3JlQXNGaWxlOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gUmV2ZXJ0IG1vZGVcbiAgICAgICAgZm9yY2VSZXZlcnQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gU2V0IHRvICdmb3JjZScgdG8gcmVxdWlyZSB0aGUgZmlsZSB0byBiZSByZXZlcnRlZCBiZWZvcmUgcmVtb3ZhbFxuXG4gICAgICAgIC8vIElucHV0IHJlcXVpcmVtZW50c1xuICAgICAgICBtYXhGaWxlczogW251bGwsIFR5cGUuSU5UXSwgLy8gTWF4IG51bWJlciBvZiBmaWxlc1xuICAgICAgICBjaGVja1ZhbGlkaXR5OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEVuYWJsZXMgY3VzdG9tIHZhbGlkaXR5IG1lc3NhZ2VzXG5cbiAgICAgICAgLy8gV2hlcmUgdG8gcHV0IGZpbGVcbiAgICAgICAgaXRlbUluc2VydExvY2F0aW9uRnJlZWRvbTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIFNldCB0byBmYWxzZSB0byBhbHdheXMgYWRkIGl0ZW1zIHRvIGJlZ2luIG9yIGVuZCBvZiBsaXN0XG4gICAgICAgIGl0ZW1JbnNlcnRMb2NhdGlvbjogWydiZWZvcmUnLCBUeXBlLlNUUklOR10sIC8vIERlZmF1bHQgaW5kZXggaW4gbGlzdCB0byBhZGQgaXRlbXMgdGhhdCBoYXZlIGJlZW4gZHJvcHBlZCBhdCB0aGUgdG9wIG9mIHRoZSBsaXN0XG4gICAgICAgIGl0ZW1JbnNlcnRJbnRlcnZhbDogWzc1LCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gRHJhZyAnbiBEcm9wIHJlbGF0ZWRcbiAgICAgICAgZHJvcE9uUGFnZTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBkcm9wcGluZyBvZiBmaWxlcyBhbnl3aGVyZSBvbiBwYWdlIChwcmV2ZW50cyBicm93c2VyIGZyb20gb3BlbmluZyBmaWxlIGlmIGRyb3BwZWQgb3V0c2lkZSBvZiBVcClcbiAgICAgICAgZHJvcE9uRWxlbWVudDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIERyb3AgbmVlZHMgdG8gaGFwcGVuIG9uIGVsZW1lbnQgKHNldCB0byBmYWxzZSB0byBhbHNvIGxvYWQgZHJvcHMgb3V0c2lkZSBvZiBVcClcbiAgICAgICAgZHJvcFZhbGlkYXRpb246IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gRW5hYmxlIG9yIGRpc2FibGUgdmFsaWRhdGluZyBmaWxlcyBvbiBkcm9wXG4gICAgICAgIGlnbm9yZWRGaWxlczogW1snLmRzX3N0b3JlJywgJ3RodW1icy5kYicsICdkZXNrdG9wLmluaSddLCBUeXBlLkFSUkFZXSxcblxuICAgICAgICAvLyBVcGxvYWQgcmVsYXRlZFxuICAgICAgICBpbnN0YW50VXBsb2FkOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gU2hvdWxkIHVwbG9hZCBmaWxlcyBpbW1lZGlhdGVseSBvbiBkcm9wXG4gICAgICAgIG1heFBhcmFsbGVsVXBsb2FkczogWzIsIFR5cGUuSU5UXSwgLy8gTWF4aW11bSBmaWxlcyB0byB1cGxvYWQgaW4gcGFyYWxsZWxcbiAgICAgICAgYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb246IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBpZiB0cnVlIHVwbG9hZHMgdGFrZSBhdCBsZWFzdCA3NTAgbXMsIHRoaXMgZW5zdXJlcyB0aGUgdXNlciBzZWVzIHRoZSB1cGxvYWQgcHJvZ3Jlc3MgZ2l2aW5nIHRydXN0IHRoZSB1cGxvYWQgYWN0dWFsbHkgaGFwcGVuZWRcblxuICAgICAgICAvLyBDaHVua3NcbiAgICAgICAgY2h1bmtVcGxvYWRzOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEVuYWJsZSBjaHVua2VkIHVwbG9hZHNcbiAgICAgICAgY2h1bmtGb3JjZTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBGb3JjZSB1c2Ugb2YgY2h1bmsgdXBsb2FkcyBldmVuIGZvciBmaWxlcyBzbWFsbGVyIHRoYW4gY2h1bmsgc2l6ZVxuICAgICAgICBjaHVua1NpemU6IFs1MDAwMDAwLCBUeXBlLklOVF0sIC8vIFNpemUgb2YgY2h1bmtzICg1TUIgZGVmYXVsdClcbiAgICAgICAgY2h1bmtSZXRyeURlbGF5czogW1s1MDAsIDEwMDAsIDMwMDBdLCBUeXBlLkFSUkFZXSwgLy8gQW1vdW50IG9mIHRpbWVzIHRvIHJldHJ5IHVwbG9hZCBvZiBhIGNodW5rIHdoZW4gaXQgZmFpbHNcblxuICAgICAgICAvLyBUaGUgc2VydmVyIGFwaSBlbmQgcG9pbnRzIHRvIHVzZSBmb3IgdXBsb2FkaW5nIChzZWUgZG9jcylcbiAgICAgICAgc2VydmVyOiBbbnVsbCwgVHlwZS5TRVJWRVJfQVBJXSxcblxuICAgICAgICAvLyBGaWxlIHNpemUgY2FsY3VsYXRpb25zLCBjYW4gc2V0IHRvIDEwMjQsIHRoaXMgaXMgb25seSB1c2VkIGZvciBkaXNwbGF5LCBwcm9wZXJ0aWVzIHVzZSBmaWxlIHNpemUgYmFzZSAxMDAwXG4gICAgICAgIGZpbGVTaXplQmFzZTogWzEwMDAsIFR5cGUuSU5UXSxcblxuICAgICAgICAvLyBMYWJlbHMgYW5kIHN0YXR1cyBtZXNzYWdlc1xuICAgICAgICBsYWJlbEZpbGVTaXplQnl0ZXM6IFsnYnl0ZXMnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVNpemVLaWxvYnl0ZXM6IFsnS0InLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVNpemVNZWdhYnl0ZXM6IFsnTUInLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVNpemVHaWdhYnl0ZXM6IFsnR0InLCBUeXBlLlNUUklOR10sXG5cbiAgICAgICAgbGFiZWxEZWNpbWFsU2VwYXJhdG9yOiBbZ2V0RGVjaW1hbFNlcGFyYXRvcigpLCBUeXBlLlNUUklOR10sIC8vIERlZmF1bHQgaXMgbG9jYWxlIHNlcGFyYXRvclxuICAgICAgICBsYWJlbFRob3VzYW5kc1NlcGFyYXRvcjogW2dldFRob3VzYW5kc1NlcGFyYXRvcigpLCBUeXBlLlNUUklOR10sIC8vIERlZmF1bHQgaXMgbG9jYWxlIHNlcGFyYXRvclxuXG4gICAgICAgIGxhYmVsSWRsZTogW1xuICAgICAgICAgICAgJ0RyYWcgJiBEcm9wIHlvdXIgZmlsZXMgb3IgPHNwYW4gY2xhc3M9XCJmaWxlcG9uZC0tbGFiZWwtYWN0aW9uXCI+QnJvd3NlPC9zcGFuPicsXG4gICAgICAgICAgICBUeXBlLlNUUklORyxcbiAgICAgICAgXSxcblxuICAgICAgICBsYWJlbEludmFsaWRGaWVsZDogWydGaWVsZCBjb250YWlucyBpbnZhbGlkIGZpbGVzJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVXYWl0aW5nRm9yU2l6ZTogWydXYWl0aW5nIGZvciBzaXplJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVTaXplTm90QXZhaWxhYmxlOiBbJ1NpemUgbm90IGF2YWlsYWJsZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlQ291bnRTaW5ndWxhcjogWydmaWxlIGluIGxpc3QnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZUNvdW50UGx1cmFsOiBbJ2ZpbGVzIGluIGxpc3QnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZUxvYWRpbmc6IFsnTG9hZGluZycsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlQWRkZWQ6IFsnQWRkZWQnLCBUeXBlLlNUUklOR10sIC8vIGFzc2lzdGl2ZSBvbmx5XG4gICAgICAgIGxhYmVsRmlsZUxvYWRFcnJvcjogWydFcnJvciBkdXJpbmcgbG9hZCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlUmVtb3ZlZDogWydSZW1vdmVkJywgVHlwZS5TVFJJTkddLCAvLyBhc3Npc3RpdmUgb25seVxuICAgICAgICBsYWJlbEZpbGVSZW1vdmVFcnJvcjogWydFcnJvciBkdXJpbmcgcmVtb3ZlJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVQcm9jZXNzaW5nOiBbJ1VwbG9hZGluZycsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0NvbXBsZXRlOiBbJ1VwbG9hZCBjb21wbGV0ZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0Fib3J0ZWQ6IFsnVXBsb2FkIGNhbmNlbGxlZCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0Vycm9yOiBbJ0Vycm9yIGR1cmluZyB1cGxvYWQnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdSZXZlcnRFcnJvcjogWydFcnJvciBkdXJpbmcgcmV2ZXJ0JywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIGxhYmVsVGFwVG9DYW5jZWw6IFsndGFwIHRvIGNhbmNlbCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxUYXBUb1JldHJ5OiBbJ3RhcCB0byByZXRyeScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxUYXBUb1VuZG86IFsndGFwIHRvIHVuZG8nLCBUeXBlLlNUUklOR10sXG5cbiAgICAgICAgbGFiZWxCdXR0b25SZW1vdmVJdGVtOiBbJ1JlbW92ZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxCdXR0b25BYm9ydEl0ZW1Mb2FkOiBbJ0Fib3J0JywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEJ1dHRvblJldHJ5SXRlbUxvYWQ6IFsnUmV0cnknLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsQnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZzogWydDYW5jZWwnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsQnV0dG9uVW5kb0l0ZW1Qcm9jZXNzaW5nOiBbJ1VuZG8nLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsQnV0dG9uUmV0cnlJdGVtUHJvY2Vzc2luZzogWydSZXRyeScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxCdXR0b25Qcm9jZXNzSXRlbTogWydVcGxvYWQnLCBUeXBlLlNUUklOR10sXG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdpZHRoIGFuZCBoZWlnaHQgcGx1cyB2aWV3cG94IGFyZSBldmVuIG51bWJlcnMgc28gaWNvbnMgYXJlIG5pY2VseSBjZW50ZXJlZFxuICAgICAgICBpY29uUmVtb3ZlOiBbXG4gICAgICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTEuNTg2IDEzbC0yLjI5MyAyLjI5M2ExIDEgMCAwIDAgMS40MTQgMS40MTRMMTMgMTQuNDE0bDIuMjkzIDIuMjkzYTEgMSAwIDAgMCAxLjQxNC0xLjQxNEwxNC40MTQgMTNsMi4yOTMtMi4yOTNhMSAxIDAgMCAwLTEuNDE0LTEuNDE0TDEzIDExLjU4NmwtMi4yOTMtMi4yOTNhMSAxIDAgMCAwLTEuNDE0IDEuNDE0TDExLjU4NiAxM3pcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgICAgIF0sXG5cbiAgICAgICAgaWNvblByb2Nlc3M6IFtcbiAgICAgICAgICAgICc8c3ZnIHdpZHRoPVwiMjZcIiBoZWlnaHQ9XCIyNlwiIHZpZXdCb3g9XCIwIDAgMjYgMjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0xNCAxMC40MTR2My41ODVhMSAxIDAgMCAxLTIgMHYtMy41ODVsLTEuMjkzIDEuMjkzYTEgMSAwIDAgMS0xLjQxNC0xLjQxNWwzLTNhMSAxIDAgMCAxIDEuNDE0IDBsMyAzYTEgMSAwIDAgMS0xLjQxNCAxLjQxNUwxNCAxMC40MTR6TTkgMThhMSAxIDAgMCAxIDAtMmg4YTEgMSAwIDAgMSAwIDJIOXpcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiLz48L3N2Zz4nLFxuICAgICAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgICAgIF0sXG5cbiAgICAgICAgaWNvblJldHJ5OiBbXG4gICAgICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTAuODEgOS4xODVsLS4wMzguMDJBNC45OTcgNC45OTcgMCAwIDAgOCAxMy42ODNhNSA1IDAgMCAwIDUgNSA1IDUgMCAwIDAgNS01IDEgMSAwIDAgMSAyIDBBNyA3IDAgMSAxIDkuNzIyIDcuNDk2bC0uODQyLS4yMWEuOTk5Ljk5OSAwIDEgMSAuNDg0LTEuOTRsMy4yMy44MDZjLjUzNS4xMzMuODYuNjc1LjczIDEuMjFsLS44MDQgMy4yMzNhLjk5Ny45OTcgMCAwIDEtMS4yMS43My45OTcuOTk3IDAgMCAxLS43My0xLjIxbC4yMy0uOTI4di0uMDAyelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICAgICAgICBUeXBlLlNUUklORyxcbiAgICAgICAgXSxcblxuICAgICAgICBpY29uVW5kbzogW1xuICAgICAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTkuMTg1IDEwLjgxbC4wMi0uMDM4QTQuOTk3IDQuOTk3IDAgMCAxIDEzLjY4MyA4YTUgNSAwIDAgMSA1IDUgNSA1IDAgMCAxLTUgNSAxIDEgMCAwIDAgMCAyQTcgNyAwIDEgMCA3LjQ5NiA5LjcyMmwtLjIxLS44NDJhLjk5OS45OTkgMCAxIDAtMS45NC40ODRsLjgwNiAzLjIzYy4xMzMuNTM1LjY3NS44NiAxLjIxLjczbDMuMjMzLS44MDNhLjk5Ny45OTcgMCAwIDAgLjczLTEuMjEuOTk3Ljk5NyAwIDAgMC0xLjIxLS43M2wtLjkyOC4yMy0uMDAyLS4wMDF6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxcbiAgICAgICAgICAgIFR5cGUuU1RSSU5HLFxuICAgICAgICBdLFxuXG4gICAgICAgIGljb25Eb25lOiBbXG4gICAgICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTguMjkzIDkuMjkzYTEgMSAwIDAgMSAxLjQxNCAxLjQxNGwtNy4wMDIgN2ExIDEgMCAwIDEtMS40MTQgMGwtMy45OTgtNGExIDEgMCAxIDEgMS40MTQtMS40MTRMMTIgMTUuNTg2bDYuMjk0LTYuMjkzelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICAgICAgICBUeXBlLlNUUklORyxcbiAgICAgICAgXSxcblxuICAgICAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgICAgICBvbmluaXQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb253YXJuaW5nOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9uZXJyb3I6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25hY3RpdmF0ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25pbml0ZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbmFkZGZpbGVzdGFydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbmFkZGZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbmFkZGZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25wcm9jZXNzZmlsZXN0YXJ0OiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ucHJvY2Vzc2ZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnByb2Nlc3NmaWxlYWJvcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25wcm9jZXNzZmlsZXJldmVydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnByb2Nlc3NmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ucHJvY2Vzc2ZpbGVzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ucmVtb3ZlZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnByZXBhcmVmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9udXBkYXRlZmlsZXM6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25yZW9yZGVyZmlsZXM6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcblxuICAgICAgICAvLyBob29rc1xuICAgICAgICBiZWZvcmVEcm9wRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBiZWZvcmVBZGRGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIGJlZm9yZVJlbW92ZUZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgYmVmb3JlUHJlcGFyZUZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcblxuICAgICAgICAvLyBzdHlsZXNcbiAgICAgICAgc3R5bGVQYW5lbExheW91dDogW251bGwsIFR5cGUuU1RSSU5HXSwgLy8gbnVsbCAnaW50ZWdyYXRlZCcsICdjb21wYWN0JywgJ2NpcmNsZSdcbiAgICAgICAgc3R5bGVQYW5lbEFzcGVjdFJhdGlvOiBbbnVsbCwgVHlwZS5TVFJJTkddLCAvLyBudWxsIG9yICczOjInIG9yIDFcbiAgICAgICAgc3R5bGVJdGVtUGFuZWxBc3BlY3RSYXRpbzogW251bGwsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgc3R5bGVCdXR0b25SZW1vdmVJdGVtUG9zaXRpb246IFsnbGVmdCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgc3R5bGVCdXR0b25Qcm9jZXNzSXRlbVBvc2l0aW9uOiBbJ3JpZ2h0JywgVHlwZS5TVFJJTkddLFxuICAgICAgICBzdHlsZUxvYWRJbmRpY2F0b3JQb3NpdGlvbjogWydyaWdodCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgc3R5bGVQcm9ncmVzc0luZGljYXRvclBvc2l0aW9uOiBbJ3JpZ2h0JywgVHlwZS5TVFJJTkddLFxuICAgICAgICBzdHlsZUJ1dHRvblJlbW92ZUl0ZW1BbGlnbjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIGN1c3RvbSBpbml0aWFsIGZpbGVzIGFycmF5XG4gICAgICAgIGZpbGVzOiBbW10sIFR5cGUuQVJSQVldLFxuXG4gICAgICAgIC8vIHNob3cgc3VwcG9ydCBieSBkaXNwbGF5aW5nIGNyZWRpdHNcbiAgICAgICAgY3JlZGl0czogW1snaHR0cHM6Ly9wcWluYS5ubC8nLCAnUG93ZXJlZCBieSBQUUlOQSddLCBUeXBlLkFSUkFZXSxcbiAgICB9O1xuXG4gICAgdmFyIGdldEl0ZW1CeVF1ZXJ5ID0gZnVuY3Rpb24gZ2V0SXRlbUJ5UXVlcnkoaXRlbXMsIHF1ZXJ5KSB7XG4gICAgICAgIC8vIGp1c3QgcmV0dXJuIGZpcnN0IGluZGV4XG4gICAgICAgIGlmIChpc0VtcHR5KHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zWzBdIHx8IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWVyeSBpcyBpbmRleFxuICAgICAgICBpZiAoaXNJbnQocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXNbcXVlcnldIHx8IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBxdWVyeSBpcyBpdGVtLCBnZXQgdGhlIGlkXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXNzdW1lIHF1ZXJ5IGlzIGEgc3RyaW5nIGFuZCByZXR1cm4gaXRlbSBieSBpZFxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXRlbXMuZmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IHF1ZXJ5O1xuICAgICAgICAgICAgfSkgfHwgbnVsbFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyA9IGZ1bmN0aW9uIGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmcoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgaWYgKGlzRW1wdHkoYXNwZWN0UmF0aW8pKSB7XG4gICAgICAgICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC86Ly50ZXN0KGFzcGVjdFJhdGlvKSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gYXNwZWN0UmF0aW8uc3BsaXQoJzonKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0c1sxXSAvIHBhcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGFzcGVjdFJhdGlvKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEFjdGl2ZUl0ZW1zID0gZnVuY3Rpb24gZ2V0QWN0aXZlSXRlbXMoaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gIWl0ZW0uYXJjaGl2ZWQ7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgU3RhdHVzID0ge1xuICAgICAgICBFTVBUWTogMCxcbiAgICAgICAgSURMRTogMSwgLy8gd2FpdGluZ1xuICAgICAgICBFUlJPUjogMiwgLy8gYSBmaWxlIGlzIGluIGVycm9yIHN0YXRlXG4gICAgICAgIEJVU1k6IDMsIC8vIGJ1c3kgcHJvY2Vzc2luZyBvciBsb2FkaW5nXG4gICAgICAgIFJFQURZOiA0LCAvLyBhbGwgZmlsZXMgdXBsb2FkZWRcbiAgICB9O1xuXG4gICAgdmFyIHJlcyA9IG51bGw7XG4gICAgdmFyIGNhblVwZGF0ZUZpbGVJbnB1dCA9IGZ1bmN0aW9uIGNhblVwZGF0ZUZpbGVJbnB1dCgpIHtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gbmV3IERhdGFUcmFuc2ZlcigpO1xuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5pdGVtcy5hZGQobmV3IEZpbGUoWydoZWxsbyB3b3JsZCddLCAnVGhpc19Xb3Jrcy50eHQnKSk7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnZmlsZScpO1xuICAgICAgICAgICAgICAgIGVsLmZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgICAgICAgICAgICAgIHJlcyA9IGVsLmZpbGVzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIHZhciBJVEVNX0VSUk9SID0gW1xuICAgICAgICBJdGVtU3RhdHVzLkxPQURfRVJST1IsXG4gICAgICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUixcbiAgICAgICAgSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUixcbiAgICBdO1xuXG4gICAgdmFyIElURU1fQlVTWSA9IFtcbiAgICAgICAgSXRlbVN0YXR1cy5MT0FESU5HLFxuICAgICAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkcsXG4gICAgICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQsXG4gICAgICAgIEl0ZW1TdGF0dXMuSU5JVCxcbiAgICBdO1xuXG4gICAgdmFyIElURU1fUkVBRFkgPSBbSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFXTtcblxuICAgIHZhciBpc0l0ZW1JbkVycm9yU3RhdGUgPSBmdW5jdGlvbiBpc0l0ZW1JbkVycm9yU3RhdGUoaXRlbSkge1xuICAgICAgICByZXR1cm4gSVRFTV9FUlJPUi5pbmNsdWRlcyhpdGVtLnN0YXR1cyk7XG4gICAgfTtcbiAgICB2YXIgaXNJdGVtSW5CdXN5U3RhdGUgPSBmdW5jdGlvbiBpc0l0ZW1JbkJ1c3lTdGF0ZShpdGVtKSB7XG4gICAgICAgIHJldHVybiBJVEVNX0JVU1kuaW5jbHVkZXMoaXRlbS5zdGF0dXMpO1xuICAgIH07XG4gICAgdmFyIGlzSXRlbUluUmVhZHlTdGF0ZSA9IGZ1bmN0aW9uIGlzSXRlbUluUmVhZHlTdGF0ZShpdGVtKSB7XG4gICAgICAgIHJldHVybiBJVEVNX1JFQURZLmluY2x1ZGVzKGl0ZW0uc3RhdHVzKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzQXN5bmMgPSBmdW5jdGlvbiBpc0FzeW5jKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc09iamVjdChzdGF0ZS5vcHRpb25zLnNlcnZlcikgJiZcbiAgICAgICAgICAgIChpc09iamVjdChzdGF0ZS5vcHRpb25zLnNlcnZlci5wcm9jZXNzKSB8fCBpc0Z1bmN0aW9uKHN0YXRlLm9wdGlvbnMuc2VydmVyLnByb2Nlc3MpKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgcXVlcmllcyA9IGZ1bmN0aW9uIHF1ZXJpZXMoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEdFVF9TVEFUVVM6IGZ1bmN0aW9uIEdFVF9TVEFUVVMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuICAgICAgICAgICAgICAgIHZhciBFTVBUWSA9IFN0YXR1cy5FTVBUWSxcbiAgICAgICAgICAgICAgICAgICAgRVJST1IgPSBTdGF0dXMuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIEJVU1kgPSBTdGF0dXMuQlVTWSxcbiAgICAgICAgICAgICAgICAgICAgSURMRSA9IFN0YXR1cy5JRExFLFxuICAgICAgICAgICAgICAgICAgICBSRUFEWSA9IFN0YXR1cy5SRUFEWTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5zb21lKGlzSXRlbUluRXJyb3JTdGF0ZSkpIHJldHVybiBFUlJPUjtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5zb21lKGlzSXRlbUluQnVzeVN0YXRlKSkgcmV0dXJuIEJVU1k7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JblJlYWR5U3RhdGUpKSByZXR1cm4gUkVBRFk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gSURMRTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEdFVF9JVEVNOiBmdW5jdGlvbiBHRVRfSVRFTShxdWVyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0FDVElWRV9JVEVNOiBmdW5jdGlvbiBHRVRfQUNUSVZFX0lURU0ocXVlcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SXRlbUJ5UXVlcnkoZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLCBxdWVyeSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfQUNUSVZFX0lURU1TOiBmdW5jdGlvbiBHRVRfQUNUSVZFX0lURU1TKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfSVRFTVM6IGZ1bmN0aW9uIEdFVF9JVEVNUygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuaXRlbXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfSVRFTV9OQU1FOiBmdW5jdGlvbiBHRVRfSVRFTV9OQU1FKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtID8gaXRlbS5maWxlbmFtZSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfSVRFTV9TSVpFOiBmdW5jdGlvbiBHRVRfSVRFTV9TSVpFKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtID8gaXRlbS5maWxlU2l6ZSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfU1RZTEVTOiBmdW5jdGlvbiBHRVRfU1RZTEVTKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZS5vcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9ec3R5bGUvLnRlc3Qoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogb3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdGF0ZS5vcHRpb25zW29wdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEdFVF9QQU5FTF9BU1BFQ1RfUkFUSU86IGZ1bmN0aW9uIEdFVF9QQU5FTF9BU1BFQ1RfUkFUSU8oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzU2hhcGVDaXJjbGUgPSAvY2lyY2xlLy50ZXN0KHN0YXRlLm9wdGlvbnMuc3R5bGVQYW5lbExheW91dCk7XG4gICAgICAgICAgICAgICAgdmFyIGFzcGVjdFJhdGlvID0gaXNTaGFwZUNpcmNsZVxuICAgICAgICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgICAgICAgOiBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nKHN0YXRlLm9wdGlvbnMuc3R5bGVQYW5lbEFzcGVjdFJhdGlvKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU86IGZ1bmN0aW9uIEdFVF9JVEVNX1BBTkVMX0FTUEVDVF9SQVRJTygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUub3B0aW9ucy5zdHlsZUl0ZW1QYW5lbEFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0lURU1TX0JZX1NUQVRVUzogZnVuY3Rpb24gR0VUX0lURU1TX0JZX1NUQVRVUyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnN0YXR1cyA9PT0gc3RhdHVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX1RPVEFMX0lURU1TOiBmdW5jdGlvbiBHRVRfVE9UQUxfSVRFTVMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBTSE9VTERfVVBEQVRFX0ZJTEVfSU5QVVQ6IGZ1bmN0aW9uIFNIT1VMRF9VUERBVEVfRklMRV9JTlBVVCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUub3B0aW9ucy5zdG9yZUFzRmlsZSAmJiBjYW5VcGRhdGVGaWxlSW5wdXQoKSAmJiAhaXNBc3luYyhzdGF0ZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBJU19BU1lOQzogZnVuY3Rpb24gSVNfQVNZTkMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzQXN5bmMoc3RhdGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0ZJTEVfU0laRV9MQUJFTFM6IGZ1bmN0aW9uIEdFVF9GSUxFX1NJWkVfTEFCRUxTKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxCeXRlczogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1NJWkVfQllURVMnKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsS2lsb2J5dGVzOiBxdWVyeSgnR0VUX0xBQkVMX0ZJTEVfU0laRV9LSUxPQllURVMnKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsTWVnYWJ5dGVzOiBxdWVyeSgnR0VUX0xBQkVMX0ZJTEVfU0laRV9NRUdBQllURVMnKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsR2lnYWJ5dGVzOiBxdWVyeSgnR0VUX0xBQkVMX0ZJTEVfU0laRV9HSUdBQllURVMnKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBoYXNSb29tRm9ySXRlbSA9IGZ1bmN0aW9uIGhhc1Jvb21Gb3JJdGVtKHN0YXRlKSB7XG4gICAgICAgIHZhciBjb3VudCA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5sZW5ndGg7XG5cbiAgICAgICAgLy8gaWYgY2Fubm90IGhhdmUgbXVsdGlwbGUgaXRlbXMsIHRvIGFkZCBvbmUgaXRlbSBpdCBzaG91bGQgY3VycmVudGx5IG5vdCBjb250YWluIGl0ZW1zXG4gICAgICAgIGlmICghc3RhdGUub3B0aW9ucy5hbGxvd011bHRpcGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gY291bnQgPT09IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhbGxvd3MgbXVsdGlwbGUgaXRlbXMsIHdlIGNoZWNrIGlmIGEgbWF4IGl0ZW0gY291bnQgaGFzIGJlZW4gc2V0LCBpZiBub3QsIHRoZXJlJ3Mgbm8gbGltaXRcbiAgICAgICAgdmFyIG1heEZpbGVDb3VudCA9IHN0YXRlLm9wdGlvbnMubWF4RmlsZXM7XG4gICAgICAgIGlmIChtYXhGaWxlQ291bnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgY2hlY2sgaWYgdGhlIGN1cnJlbnQgY291bnQgaXMgc21hbGxlciB0aGFuIHRoZSBtYXggY291bnQsIGlmIHNvLCBhbm90aGVyIGZpbGUgY2FuIHN0aWxsIGJlIGFkZGVkXG4gICAgICAgIGlmIChjb3VudCA8IG1heEZpbGVDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBtb3JlIHJvb20gZm9yIGFub3RoZXIgZmlsZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBsaW1pdCA9IGZ1bmN0aW9uIGxpbWl0KHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obWF4LCB2YWx1ZSksIG1pbik7XG4gICAgfTtcblxuICAgIHZhciBhcnJheUluc2VydCA9IGZ1bmN0aW9uIGFycmF5SW5zZXJ0KGFyciwgaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuICAgIH07XG5cbiAgICB2YXIgaW5zZXJ0SXRlbSA9IGZ1bmN0aW9uIGluc2VydEl0ZW0oaXRlbXMsIGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGlmIChpc0VtcHR5KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGluZGV4IGlzIHVuZGVmaW5lZCwgYXBwZW5kXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW1pdCB0aGUgaW5kZXggdG8gdGhlIHNpemUgb2YgdGhlIGl0ZW1zIGFycmF5XG4gICAgICAgIGluZGV4ID0gbGltaXQoaW5kZXgsIDAsIGl0ZW1zLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gYWRkIGl0ZW0gdG8gYXJyYXlcbiAgICAgICAgYXJyYXlJbnNlcnQoaXRlbXMsIGluZGV4LCBpdGVtKTtcblxuICAgICAgICAvLyBleHBvc2VcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcblxuICAgIHZhciBpc0Jhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBpc0Jhc2U2NERhdGFVUkkoc3RyKSB7XG4gICAgICAgIHJldHVybiAvXlxccypkYXRhOihbYS16XStcXC9bYS16MC05LSsuXSsoO1thLXotXSs9W2EtejAtOS1dKyk/KT8oO2Jhc2U2NCk/LChbYS16MC05ISQmJywoKSorOz1cXC0uX346QFxcLz8lXFxzXSopXFxzKiQvaS50ZXN0KFxuICAgICAgICAgICAgc3RyXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlbmFtZUZyb21VUkwgPSBmdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21VUkwodXJsKSB7XG4gICAgICAgIHJldHVybiAoJycgKyB1cmwpXG4gICAgICAgICAgICAuc3BsaXQoJy8nKVxuICAgICAgICAgICAgLnBvcCgpXG4gICAgICAgICAgICAuc3BsaXQoJz8nKVxuICAgICAgICAgICAgLnNoaWZ0KCk7XG4gICAgfTtcblxuICAgIHZhciBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUgPSBmdW5jdGlvbiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS5zcGxpdCgnLicpLnBvcCgpO1xuICAgIH07XG5cbiAgICB2YXIgZ3Vlc3N0aW1hdGVFeHRlbnNpb24gPSBmdW5jdGlvbiBndWVzc3RpbWF0ZUV4dGVuc2lvbih0eXBlKSB7XG4gICAgICAgIC8vIGlmIG5vIGV4dGVuc2lvbiBzdXBwbGllZCwgZXhpdCBoZXJlXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBzdWJ0eXBlXG4gICAgICAgIHZhciBzdWJ0eXBlID0gdHlwZS5zcGxpdCgnLycpLnBvcCgpO1xuXG4gICAgICAgIC8vIGlzIHN2ZyBzdWJ0eXBlXG4gICAgICAgIGlmICgvc3ZnLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3N2Zyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL3ppcHxjb21wcmVzc2VkLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ppcCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL3BsYWluLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3R4dCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL21zd29yZC8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXMgdmFsaWQgc3VidHlwZVxuICAgICAgICBpZiAoL1thLXpdKy8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHVzZSBqcGcgZXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAoc3VidHlwZSA9PT0gJ2pwZWcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdqcGcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXR1cm4gc3VidHlwZVxuICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcblxuICAgIHZhciBsZWZ0UGFkID0gZnVuY3Rpb24gbGVmdFBhZCh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gICAgICAgIHJldHVybiAocGFkZGluZyArIHZhbHVlKS5zbGljZSgtcGFkZGluZy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RGF0ZVN0cmluZyA9IGZ1bmN0aW9uIGdldERhdGVTdHJpbmcoKSB7XG4gICAgICAgIHZhciBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpICtcbiAgICAgICAgICAgICctJyArXG4gICAgICAgICAgICBsZWZ0UGFkKGRhdGUuZ2V0TW9udGgoKSArIDEsICcwMCcpICtcbiAgICAgICAgICAgICctJyArXG4gICAgICAgICAgICBsZWZ0UGFkKGRhdGUuZ2V0RGF0ZSgpLCAnMDAnKSArXG4gICAgICAgICAgICAnXycgK1xuICAgICAgICAgICAgbGVmdFBhZChkYXRlLmdldEhvdXJzKCksICcwMCcpICtcbiAgICAgICAgICAgICctJyArXG4gICAgICAgICAgICBsZWZ0UGFkKGRhdGUuZ2V0TWludXRlcygpLCAnMDAnKSArXG4gICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgbGVmdFBhZChkYXRlLmdldFNlY29uZHMoKSwgJzAwJylcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVGcm9tQmxvYiA9IGZ1bmN0aW9uIGdldEZpbGVGcm9tQmxvYihibG9iLCBmaWxlbmFtZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgICAgdmFyIGZpbGUgPVxuICAgICAgICAgICAgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBibG9iLnNsaWNlKDAsIGJsb2Iuc2l6ZSwgdHlwZSlcbiAgICAgICAgICAgICAgICA6IGJsb2Iuc2xpY2UoMCwgYmxvYi5zaXplLCBibG9iLnR5cGUpO1xuICAgICAgICBmaWxlLmxhc3RNb2RpZmllZERhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIC8vIGNvcHkgcmVsYXRpdmUgcGF0aFxuICAgICAgICBpZiAoYmxvYi5fcmVsYXRpdmVQYXRoKSBmaWxlLl9yZWxhdGl2ZVBhdGggPSBibG9iLl9yZWxhdGl2ZVBhdGg7XG5cbiAgICAgICAgLy8gaWYgYmxvYiBoYXMgbmFtZSBwcm9wZXJ0eSwgdXNlIGFzIGZpbGVuYW1lIGlmIG5vIGZpbGVuYW1lIHN1cHBsaWVkXG4gICAgICAgIGlmICghaXNTdHJpbmcoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IGdldERhdGVTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGZpbGVuYW1lIHN1cHBsaWVkIGJ1dCBubyBleHRlbnNpb24gYW5kIGZpbGVuYW1lIGhhcyBleHRlbnNpb25cbiAgICAgICAgaWYgKGZpbGVuYW1lICYmIGV4dGVuc2lvbiA9PT0gbnVsbCAmJiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICBmaWxlLm5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiB8fCBndWVzc3RpbWF0ZUV4dGVuc2lvbihmaWxlLnR5cGUpO1xuICAgICAgICAgICAgZmlsZS5uYW1lID0gZmlsZW5hbWUgKyAoZXh0ZW5zaW9uID8gJy4nICsgZXh0ZW5zaW9uIDogJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfTtcblxuICAgIHZhciBnZXRCbG9iQnVpbGRlciA9IGZ1bmN0aW9uIGdldEJsb2JCdWlsZGVyKCkge1xuICAgICAgICByZXR1cm4gKHdpbmRvdy5CbG9iQnVpbGRlciA9XG4gICAgICAgICAgICB3aW5kb3cuQmxvYkJ1aWxkZXIgfHxcbiAgICAgICAgICAgIHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fFxuICAgICAgICAgICAgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8XG4gICAgICAgICAgICB3aW5kb3cuTVNCbG9iQnVpbGRlcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVCbG9iID0gZnVuY3Rpb24gY3JlYXRlQmxvYihhcnJheUJ1ZmZlciwgbWltZVR5cGUpIHtcbiAgICAgICAgdmFyIEJCID0gZ2V0QmxvYkJ1aWxkZXIoKTtcblxuICAgICAgICBpZiAoQkIpIHtcbiAgICAgICAgICAgIHZhciBiYiA9IG5ldyBCQigpO1xuICAgICAgICAgICAgYmIuYXBwZW5kKGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiBiYi5nZXRCbG9iKG1pbWVUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbYXJyYXlCdWZmZXJdLCB7XG4gICAgICAgICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRCbG9iRnJvbUJ5dGVTdHJpbmdXaXRoTWltZVR5cGUgPSBmdW5jdGlvbiBnZXRCbG9iRnJvbUJ5dGVTdHJpbmdXaXRoTWltZVR5cGUoXG4gICAgICAgIGJ5dGVTdHJpbmcsXG4gICAgICAgIG1pbWVUeXBlXG4gICAgKSB7XG4gICAgICAgIHZhciBhYiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU3RyaW5nLmxlbmd0aCk7XG4gICAgICAgIHZhciBpYSA9IG5ldyBVaW50OEFycmF5KGFiKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJsb2IoYWIsIG1pbWVUeXBlKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldE1pbWVUeXBlRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpIHtcbiAgICAgICAgcmV0dXJuICgvXmRhdGE6KC4rKTsvLmV4ZWMoZGF0YVVSSSkgfHwgW10pWzFdIHx8IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBnZXRCYXNlNjREYXRhRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRCYXNlNjREYXRhRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSkge1xuICAgICAgICAvLyBnZXQgZGF0YSBwYXJ0IG9mIHN0cmluZyAocmVtb3ZlIGRhdGE6aW1hZ2UvanBlZy4uLiwpXG4gICAgICAgIHZhciBkYXRhID0gZGF0YVVSSS5zcGxpdCgnLCcpWzFdO1xuXG4gICAgICAgIC8vIHJlbW92ZSBhbnkgd2hpdGVzcGFjZSBhcyB0aGF0IGNhdXNlcyBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IgaW4gSUVcbiAgICAgICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSB7XG4gICAgICAgIHJldHVybiBhdG9iKGdldEJhc2U2NERhdGFGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRCbG9iRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRCbG9iRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSkge1xuICAgICAgICB2YXIgbWltZVR5cGUgPSBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpO1xuICAgICAgICB2YXIgYnl0ZVN0cmluZyA9IGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKTtcblxuICAgICAgICByZXR1cm4gZ2V0QmxvYkZyb21CeXRlU3RyaW5nV2l0aE1pbWVUeXBlKGJ5dGVTdHJpbmcsIG1pbWVUeXBlKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVGcm9tQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGdldEZpbGVGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJLCBmaWxlbmFtZSwgZXh0ZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBnZXRGaWxlRnJvbUJsb2IoZ2V0QmxvYkZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpLCBmaWxlbmFtZSwgbnVsbCwgZXh0ZW5zaW9uKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVOYW1lRnJvbUhlYWRlciA9IGZ1bmN0aW9uIGdldEZpbGVOYW1lRnJvbUhlYWRlcihoZWFkZXIpIHtcbiAgICAgICAgLy8gdGVzdCBpZiBpcyBjb250ZW50IGRpc3Bvc2l0aW9uIGhlYWRlciwgaWYgbm90IGV4aXRcbiAgICAgICAgaWYgKCEvXmNvbnRlbnQtZGlzcG9zaXRpb246L2kudGVzdChoZWFkZXIpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBnZXQgZmlsZW5hbWUgcGFydHNcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBoZWFkZXJcbiAgICAgICAgICAgIC5zcGxpdCgvZmlsZW5hbWU9fGZpbGVuYW1lXFwqPS4rJycvKVxuICAgICAgICAgICAgLnNwbGljZSgxKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUudHJpbSgpLnJlcGxhY2UoL15bXCInXXxbO1wiJ117MCwyfSQvZywgJycpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXRjaGVzLmxlbmd0aCA/IGRlY29kZVVSSShtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0pIDogbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVTaXplRnJvbUhlYWRlciA9IGZ1bmN0aW9uIGdldEZpbGVTaXplRnJvbUhlYWRlcihoZWFkZXIpIHtcbiAgICAgICAgaWYgKC9jb250ZW50LWxlbmd0aDovaS50ZXN0KGhlYWRlcikpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gaGVhZGVyLm1hdGNoKC9bMC05XSsvKVswXTtcbiAgICAgICAgICAgIHJldHVybiBzaXplID8gcGFyc2VJbnQoc2l6ZSwgMTApIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGdldFRyYW5mc2VySWRGcm9tSGVhZGVyID0gZnVuY3Rpb24gZ2V0VHJhbmZzZXJJZEZyb21IZWFkZXIoaGVhZGVyKSB7XG4gICAgICAgIGlmICgveC1jb250ZW50LXRyYW5zZmVyLWlkOi9pLnRlc3QoaGVhZGVyKSkge1xuICAgICAgICAgICAgdmFyIGlkID0gKGhlYWRlci5zcGxpdCgnOicpWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICByZXR1cm4gaWQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVJbmZvRnJvbUhlYWRlcnMgPSBmdW5jdGlvbiBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgc2l6ZTogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcm93cyA9IGhlYWRlcnMuc3BsaXQoJ1xcbicpO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSByb3dzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7XG4gICAgICAgICAgICAgICAgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZ2V0RmlsZU5hbWVGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBnZXRGaWxlU2l6ZUZyb21IZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gZ2V0VHJhbmZzZXJJZEZyb21IZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8uc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRmlsZUxvYWRlciA9IGZ1bmN0aW9uIGNyZWF0ZUZpbGVMb2FkZXIoZmV0Y2hGbikge1xuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgICAgIHNpemU6IG51bGwsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFByb2dyZXNzID0gZnVuY3Rpb24gZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUucHJvZ3Jlc3M7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlcXVlc3QgJiYgc3RhdGUucmVxdWVzdC5hYm9ydCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBsb2FkIHNvdXJjZVxuICAgICAgICB2YXIgbG9hZCA9IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICAgICAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlXG4gICAgICAgICAgICB2YXIgc291cmNlID0gc3RhdGUuc291cmNlO1xuXG4gICAgICAgICAgICBhcGkuZmlyZSgnaW5pdCcsIHNvdXJjZSk7XG5cbiAgICAgICAgICAgIC8vIExvYWQgRmlsZXNcbiAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2xvYWQnLCBzb3VyY2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9hZCBibG9icywgc2V0IGRlZmF1bHQgbmFtZSB0byBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIGdldEZpbGVGcm9tQmxvYihzb3VyY2UsIHNvdXJjZS5uYW1lKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQmFzZTY0RGF0YVVSSShzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9hZCBiYXNlIDY0LCBzZXQgZGVmYXVsdCBuYW1lIHRvIGN1cnJlbnQgZGF0ZVxuICAgICAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkJywgZ2V0RmlsZUZyb21CYXNlNjREYXRhVVJJKHNvdXJjZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEZWFsIGFzIGlmIGlzIGV4dGVybmFsIFVSTCwgbGV0J3MgbG9hZCBpdCFcbiAgICAgICAgICAgICAgICBsb2FkVVJMKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbG9hZHMgYSB1cmxcbiAgICAgICAgdmFyIGxvYWRVUkwgPSBmdW5jdGlvbiBsb2FkVVJMKHVybCkge1xuICAgICAgICAgICAgLy8gaXMgcmVtb3RlIHVybCBhbmQgbm8gZmV0Y2ggbWV0aG9kIHN1cHBsaWVkXG4gICAgICAgICAgICBpZiAoIWZldGNoRm4pIHtcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IFwiQ2FuJ3QgbG9hZCBVUkxcIixcbiAgICAgICAgICAgICAgICAgICAgY29kZTogNDAwLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgcmVxdWVzdCBzdGFydFxuICAgICAgICAgICAgc3RhdGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgLy8gbG9hZCBmaWxlXG4gICAgICAgICAgICBzdGF0ZS5yZXF1ZXN0ID0gZmV0Y2hGbihcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdHVybiBibG9iIHJlc3BvbnNlIGludG8gYSBmaWxlXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZ2V0RmlsZUZyb21CbG9iKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcGkuZmlyZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGhhcyByZWNlaXZlZCBibG9iLCB3ZSBnbyB3aXRoIGJsb2IsIGlmIG5vIHJlc3BvbnNlLCB3ZSByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgaW5zdGFuY2VvZiBCbG9iID8gcmVzcG9uc2UgOiByZXNwb25zZSA/IHJlc3BvbnNlLmJvZHkgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBhcGkuZmlyZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGNvbXB1dGFibGUsIGN1cnJlbnQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbGxlY3RlZCBzb21lIG1ldGEgZGF0YSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2l6ZSA9IHRvdGFsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBjb21wdXRlIHByb2dyZXNzLCB3ZSdyZSBub3QgZ29pbmcgdG8gZmlyZSBwcm9ncmVzcyBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcHJvZ3Jlc3MgcGVyY2VudGFnZVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IGN1cnJlbnQgLyB0b3RhbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvc2VcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoJ3Byb2dyZXNzJywgc3RhdGUucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5maXJlKCdhYm9ydCcpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVpbmZvID0gZ2V0RmlsZUluZm9Gcm9tSGVhZGVycyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXNwb25zZSA9PT0gJ3N0cmluZycgPyByZXNwb25zZSA6IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoJ21ldGEnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzdGF0ZS5zaXplIHx8IGZpbGVpbmZvLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZWluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZmlsZWluZm8uc291cmNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcGkgPSBPYmplY3QuYXNzaWduKHt9LCBvbigpLCB7XG4gICAgICAgICAgICBzZXRTb3VyY2U6IGZ1bmN0aW9uIHNldFNvdXJjZShzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHN0YXRlLnNvdXJjZSA9IHNvdXJjZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UHJvZ3Jlc3M6IGdldFByb2dyZXNzLCAvLyBmaWxlIGxvYWQgcHJvZ3Jlc3NcbiAgICAgICAgICAgIGFib3J0OiBhYm9ydCwgLy8gYWJvcnQgZmlsZSBsb2FkXG4gICAgICAgICAgICBsb2FkOiBsb2FkLCAvLyBzdGFydCBsb2FkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBpc0dldCA9IGZ1bmN0aW9uIGlzR2V0KG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gL0dFVHxIRUFELy50ZXN0KG1ldGhvZCk7XG4gICAgfTtcblxuICAgIHZhciBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KGRhdGEsIHVybCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXBpID0ge1xuICAgICAgICAgICAgb25oZWFkZXJzOiBmdW5jdGlvbiBvbmhlYWRlcnMoKSB7fSxcbiAgICAgICAgICAgIG9ucHJvZ3Jlc3M6IGZ1bmN0aW9uIG9ucHJvZ3Jlc3MoKSB7fSxcbiAgICAgICAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKCkge30sXG4gICAgICAgICAgICBvbnRpbWVvdXQ6IGZ1bmN0aW9uIG9udGltZW91dCgpIHt9LFxuICAgICAgICAgICAgb25lcnJvcjogZnVuY3Rpb24gb25lcnJvcigpIHt9LFxuICAgICAgICAgICAgb25hYm9ydDogZnVuY3Rpb24gb25hYm9ydCgpIHt9LFxuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0aW1lb3V0IGlkZW50aWZpZXIsIG9ubHkgdXNlZCB3aGVuIHRpbWVvdXQgaXMgZGVmaW5lZFxuICAgICAgICB2YXIgYWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaGVhZGVyc1JlY2VpdmVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBlbmNvZGUgdXJsXG4gICAgICAgIHVybCA9IGVuY29kZVVSSSh1cmwpO1xuXG4gICAgICAgIC8vIGlmIG1ldGhvZCBpcyBHRVQsIGFkZCBhbnkgcmVjZWl2ZWQgZGF0YSB0byB1cmxcblxuICAgICAgICBpZiAoaXNHZXQob3B0aW9ucy5tZXRob2QpICYmIGRhdGEpIHtcbiAgICAgICAgICAgIHVybCA9XG4gICAgICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgICAgIHVybCArXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgcmVxdWVzdFxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgLy8gcHJvZ3Jlc3Mgb2YgbG9hZFxuICAgICAgICB2YXIgcHJvY2VzcyA9IGlzR2V0KG9wdGlvbnMubWV0aG9kKSA/IHhociA6IHhoci51cGxvYWQ7XG4gICAgICAgIHByb2Nlc3Mub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vIG5vIHByb2dyZXNzIGV2ZW50IHdoZW4gYWJvcnRlZCAoIG9ucHJvZ3Jlc3MgaXMgY2FsbGVkIG9uY2UgYWZ0ZXIgYWJvcnQoKSApXG4gICAgICAgICAgICBpZiAoYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXBpLm9ucHJvZ3Jlc3MoZS5sZW5ndGhDb21wdXRhYmxlLCBlLmxvYWRlZCwgZS50b3RhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdHJpZXMgdG8gZ2V0IGhlYWRlciBpbmZvIHRvIHRoZSBhcHAgYXMgZmFzdCBhcyBwb3NzaWJsZVxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBub3QgaW50ZXJlc3RpbmcgaW4gdGhlc2Ugc3RhdGVzICgndW5zZW50JyBhbmQgJ29wZW5lbmQnIGFzIHRoZXkgZG9uJ3QgZ2l2ZSB1cyBhbnkgYWRkaXRpb25hbCBpbmZvKVxuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlIDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gc2VydmVyIHJlc3BvbnNlXG4gICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhlYWRlcnNSZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGVhZGVyc1JlY2VpdmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gd2UndmUgcHJvYmFibHkgcmVjZWl2ZWQgc29tZSB1c2VmdWwgZGF0YSBpbiByZXNwb25zZSBoZWFkZXJzXG4gICAgICAgICAgICBhcGkub25oZWFkZXJzKHhocik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbG9hZCBzdWNjZXNzZnVsXG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGlzIGNsYXNzaWZpZWQgYXMgdmFsaWQgcmVzcG9uc2VcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgYXBpLm9ubG9hZCh4aHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcGkub25lcnJvcih4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGVycm9yIGR1cmluZyBsb2FkXG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBpLm9uZXJyb3IoeGhyKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZXF1ZXN0IGFib3J0ZWRcbiAgICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYXBpLm9uYWJvcnQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZXF1ZXN0IHRpbWVvdXRcbiAgICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwaS5vbnRpbWVvdXQoeGhyKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBvcGVuIHVwIG9wZW4gdXAhXG4gICAgICAgIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgICAgIC8vIHNldCB0aW1lb3V0IGlmIGRlZmluZWQgKGRvIGl0IGFmdGVyIG9wZW4gc28gSUUxMSBwbGF5cyBiYWxsKVxuICAgICAgICBpZiAoaXNJbnQob3B0aW9ucy50aW1lb3V0KSkge1xuICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgaGVhZGVyc1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5oZWFkZXJzW2tleV0pKTtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXQgdHlwZSBvZiByZXNwb25zZVxuICAgICAgICBpZiAob3B0aW9ucy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBjcmVkZW50aWFsc1xuICAgICAgICBpZiAob3B0aW9ucy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0J3Mgc2VuZCBvdXIgZGF0YVxuICAgICAgICB4aHIuc2VuZChkYXRhKTtcblxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUmVzcG9uc2UgPSBmdW5jdGlvbiBjcmVhdGVSZXNwb25zZSh0eXBlLCBjb2RlLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlVGltZW91dFJlc3BvbnNlID0gZnVuY3Rpb24gY3JlYXRlVGltZW91dFJlc3BvbnNlKGNiKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgIGNiKGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdUaW1lb3V0JywgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBoYXNRUyA9IGZ1bmN0aW9uIGhhc1FTKHN0cikge1xuICAgICAgICByZXR1cm4gL1xcPy8udGVzdChzdHIpO1xuICAgIH07XG4gICAgdmFyIGJ1aWxkVVJMID0gZnVuY3Rpb24gYnVpbGRVUkwoKSB7XG4gICAgICAgIHZhciB1cmwgPSAnJztcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcnRzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgcGFydHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICB1cmwgKz0gaGFzUVModXJsKSAmJiBoYXNRUyhwYXJ0KSA/IHBhcnQucmVwbGFjZSgvXFw/LywgJyYnKSA6IHBhcnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRmV0Y2hGdW5jdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUZldGNoRnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcGlVcmwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgICAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGN1c3RvbSBoYW5kbGVyIChzaG91bGQgYWxzbyBoYW5kbGUgZmlsZSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzIGFuZCBhYm9ydClcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWRcbiAgICAgICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBvbmxvYWQgaGFubGRlclxuICAgICAgICB2YXIgb25sb2FkID1cbiAgICAgICAgICAgIGFjdGlvbi5vbmxvYWQgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgICAgICBhY3Rpb24ub25lcnJvciB8fFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIGludGVybmFsIGhhbmRsZXJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgaGVhZGVycykge1xuICAgICAgICAgICAgLy8gZG8gbG9jYWwgb3IgcmVtb3RlIHJlcXVlc3QgYmFzZWQgb24gaWYgdGhlIHVybCBpcyBleHRlcm5hbFxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBzZW5kUmVxdWVzdChcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSxcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnYmxvYicsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGhlYWRlcnNcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblxuICAgICAgICAgICAgICAgIC8vIGdldCBmaWxlbmFtZVxuICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoaGVhZGVycykubmFtZSB8fCBnZXRGaWxlbmFtZUZyb21VUkwodXJsKTtcblxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIGxvYWQoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5tZXRob2QgPT09ICdIRUFEJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZ2V0RmlsZUZyb21CbG9iKG9ubG9hZCh4aHIucmVzcG9uc2UpLCBmaWxlbmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uaGVhZGVycyA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMoY3JlYXRlUmVzcG9uc2UoJ2hlYWRlcnMnLCB4aHIuc3RhdHVzLCBudWxsLCB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmFib3J0ID0gYWJvcnQ7XG5cbiAgICAgICAgICAgIC8vIHNob3VsZCByZXR1cm4gcmVxdWVzdFxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBDaHVua1N0YXR1cyA9IHtcbiAgICAgICAgUVVFVUVEOiAwLFxuICAgICAgICBDT01QTEVURTogMSxcbiAgICAgICAgUFJPQ0VTU0lORzogMixcbiAgICAgICAgRVJST1I6IDMsXG4gICAgICAgIFdBSVRJTkc6IDQsXG4gICAgfTtcblxuICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2lnbmF0dXJlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2Zlciwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydDooKSA9PiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgLy8gYXBpVXJsLCBhY3Rpb24sIG5hbWUsIGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2Zlciwgb3B0aW9uc1xuICAgIHZhciBwcm9jZXNzRmlsZUNodW5rZWQgPSBmdW5jdGlvbiBwcm9jZXNzRmlsZUNodW5rZWQoXG4gICAgICAgIGFwaVVybCxcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBuYW1lLFxuICAgICAgICBmaWxlLFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgbG9hZCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHByb2dyZXNzLFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgdHJhbnNmZXIsXG4gICAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgICAgLy8gYWxsIGNodW5rc1xuICAgICAgICB2YXIgY2h1bmtzID0gW107XG4gICAgICAgIHZhciBjaHVua1RyYW5zZmVySWQgPSBvcHRpb25zLmNodW5rVHJhbnNmZXJJZCxcbiAgICAgICAgICAgIGNodW5rU2VydmVyID0gb3B0aW9ucy5jaHVua1NlcnZlcixcbiAgICAgICAgICAgIGNodW5rU2l6ZSA9IG9wdGlvbnMuY2h1bmtTaXplLFxuICAgICAgICAgICAgY2h1bmtSZXRyeURlbGF5cyA9IG9wdGlvbnMuY2h1bmtSZXRyeURlbGF5cztcblxuICAgICAgICAvLyBkZWZhdWx0IHN0YXRlXG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIHNlcnZlcklkOiBjaHVua1RyYW5zZmVySWQsXG4gICAgICAgICAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXQgb25sb2FkIGhhbmRsZXJzXG4gICAgICAgIHZhciBvbmRhdGEgPVxuICAgICAgICAgICAgYWN0aW9uLm9uZGF0YSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24oZmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgb25sb2FkID1cbiAgICAgICAgICAgIGFjdGlvbi5vbmxvYWQgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHhociwgbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZCA9PT0gJ0hFQUQnID8geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdVcGxvYWQtT2Zmc2V0JykgOiB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgICAgICBhY3Rpb24ub25lcnJvciB8fFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzZXJ2ZXIgaG9va1xuICAgICAgICB2YXIgcmVxdWVzdFRyYW5zZmVySWQgPSBmdW5jdGlvbiByZXF1ZXN0VHJhbnNmZXJJZChjYikge1xuICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBtZXRhZGF0YSB1bmRlciBzYW1lIG5hbWVcbiAgICAgICAgICAgIGlmIChpc09iamVjdChtZXRhZGF0YSkpIGZvcm1EYXRhLmFwcGVuZChuYW1lLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGFjdGlvbi5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gYWN0aW9uLmhlYWRlcnMoZmlsZSwgbWV0YWRhdGEpXG4gICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzZW5kIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIG9uZGF0YShmb3JtRGF0YSksXG4gICAgICAgICAgICAgICAgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihvbmxvYWQoeGhyLCByZXF1ZXN0UGFyYW1zLm1ldGhvZCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXF1ZXN0VHJhbnNmZXJPZmZzZXQgPSBmdW5jdGlvbiByZXF1ZXN0VHJhbnNmZXJPZmZzZXQoY2IpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0VXJsID0gYnVpbGRVUkwoYXBpVXJsLCBjaHVua1NlcnZlci51cmwsIHN0YXRlLnNlcnZlcklkKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBhY3Rpb24uaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IGFjdGlvbi5oZWFkZXJzKHN0YXRlLnNlcnZlcklkKVxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbi5oZWFkZXJzKTtcblxuICAgICAgICAgICAgdmFyIHJlcXVlc3RQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdIRUFEJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gc2VuZFJlcXVlc3QobnVsbCwgcmVxdWVzdFVybCwgcmVxdWVzdFBhcmFtcyk7XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG9ubG9hZCh4aHIsIHJlcXVlc3RQYXJhbXMubWV0aG9kKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY3JlYXRlIGNodW5rc1xuICAgICAgICB2YXIgbGFzdENodW5rSW5kZXggPSBNYXRoLmZsb29yKGZpbGUuc2l6ZSAvIGNodW5rU2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxhc3RDaHVua0luZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogY2h1bmtTaXplO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBmaWxlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY2h1bmtTaXplLCAnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpO1xuICAgICAgICAgICAgY2h1bmtzW2ldID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHNpemU6IGRhdGEuc2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICAgICAgcmV0cmllczogX3RvQ29uc3VtYWJsZUFycmF5KGNodW5rUmV0cnlEZWxheXMpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogQ2h1bmtTdGF0dXMuUVVFVUVELFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgICAgICAgICAgICAgdGltZW91dDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzID0gZnVuY3Rpb24gY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWQoc3RhdGUuc2VydmVySWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjYW5Qcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiBjYW5Qcm9jZXNzQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLlFVRVVFRCB8fCBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLkVSUk9SO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiBwcm9jZXNzQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgICAgIC8vIHByb2Nlc3NpbmcgaXMgcGF1c2VkLCB3YWl0IGhlcmVcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIGdldCBuZXh0IGNodW5rIHRvIHByb2Nlc3NcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsgfHwgY2h1bmtzLmZpbmQoY2FuUHJvY2Vzc0NodW5rKTtcblxuICAgICAgICAgICAgLy8gbm8gbW9yZSBjaHVua3MgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKCFjaHVuaykge1xuICAgICAgICAgICAgICAgIC8vIGFsbCBkb25lP1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLmV2ZXJ5KGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbm8gY2h1bmsgdG8gaGFuZGxlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgcHJvY2Vzc2luZyB0aGlzIGNodW5rXG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5QUk9DRVNTSU5HO1xuICAgICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBhbGxvdyBwYXJzaW5nIG9mIGZvcm1kYXRhXG4gICAgICAgICAgICB2YXIgb25kYXRhID1cbiAgICAgICAgICAgICAgICBjaHVua1NlcnZlci5vbmRhdGEgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihmZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbmVycm9yID1cbiAgICAgICAgICAgICAgICBjaHVua1NlcnZlci5vbmVycm9yIHx8XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHNlbmQgcmVxdWVzdCBvYmplY3RcbiAgICAgICAgICAgIHZhciByZXF1ZXN0VXJsID0gYnVpbGRVUkwoYXBpVXJsLCBjaHVua1NlcnZlci51cmwsIHN0YXRlLnNlcnZlcklkKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBjaHVua1NlcnZlci5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gY2h1bmtTZXJ2ZXIuaGVhZGVycyhjaHVuaylcbiAgICAgICAgICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBjaHVua1NlcnZlci5oZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogY2h1bmsub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VwbG9hZC1OYW1lJzogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IChjaHVuay5yZXF1ZXN0ID0gc2VuZFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgb25kYXRhKGNodW5rLmRhdGEpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RVcmwsXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgY2h1bmtTZXJ2ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5DT01QTEVURTtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSByZXF1ZXN0IHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgcHJvY2Vzc2luZyBtb3JlIGNodW5rc1xuICAgICAgICAgICAgICAgIHByb2Nlc3NDaHVua3MoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGxlbmd0aENvbXB1dGFibGUsIGxvYWRlZCwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5wcm9ncmVzcyA9IGxlbmd0aENvbXB1dGFibGUgPyBsb2FkZWQgOiBudWxsO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRvdGFsUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkVSUk9SO1xuICAgICAgICAgICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNodW5rLmVycm9yID0gb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgICAgIGlmICghcmV0cnlQcm9jZXNzQ2h1bmsoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkVSUk9SO1xuICAgICAgICAgICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghcmV0cnlQcm9jZXNzQ2h1bmsoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcikoeGhyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5RVUVVRUQ7XG4gICAgICAgICAgICAgICAgY2h1bmsucmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJldHJ5UHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gcmV0cnlQcm9jZXNzQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgICAgIC8vIG5vIG1vcmUgcmV0cmllcyBsZWZ0XG4gICAgICAgICAgICBpZiAoY2h1bmsucmV0cmllcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gbmV3IHJldHJ5XG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5XQUlUSU5HO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNodW5rLnRpbWVvdXQpO1xuICAgICAgICAgICAgY2h1bmsudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgICAgICAgICAgIH0sIGNodW5rLnJldHJpZXMuc2hpZnQoKSk7XG5cbiAgICAgICAgICAgIC8vIHdlJ3JlIGdvaW5nIHRvIHJldHJ5XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBkYXRlVG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uIHVwZGF0ZVRvdGFsUHJvZ3Jlc3MoKSB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdG90YWwgcHJvZ3Jlc3MgZnJhY3Rpb25cbiAgICAgICAgICAgIHZhciB0b3RhbEJ5dGVzVHJhbnNmZXJlZCA9IGNodW5rcy5yZWR1Y2UoZnVuY3Rpb24ocCwgY2h1bmspIHtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gbnVsbCB8fCBjaHVuay5wcm9ncmVzcyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAgKyBjaHVuay5wcm9ncmVzcztcbiAgICAgICAgICAgIH0sIDApO1xuXG4gICAgICAgICAgICAvLyBjYW4ndCBjb21wdXRlIHByb2dyZXNzXG4gICAgICAgICAgICBpZiAodG90YWxCeXRlc1RyYW5zZmVyZWQgPT09IG51bGwpIHJldHVybiBwcm9ncmVzcyhmYWxzZSwgMCwgMCk7XG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBwcm9ncmVzcyB2YWx1ZXNcbiAgICAgICAgICAgIHZhciB0b3RhbFNpemUgPSBjaHVua3MucmVkdWNlKGZ1bmN0aW9uKHRvdGFsLCBjaHVuaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b3RhbCArIGNodW5rLnNpemU7XG4gICAgICAgICAgICB9LCAwKTtcblxuICAgICAgICAgICAgLy8gY2FuIHVwZGF0ZSBwcm9ncmVzcyBpbmRpY2F0b3JcbiAgICAgICAgICAgIHByb2dyZXNzKHRydWUsIHRvdGFsQnl0ZXNUcmFuc2ZlcmVkLCB0b3RhbFNpemUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHByb2Nlc3MgbmV3IGNodW5rc1xuICAgICAgICB2YXIgcHJvY2Vzc0NodW5rcyA9IGZ1bmN0aW9uIHByb2Nlc3NDaHVua3MoKSB7XG4gICAgICAgICAgICB2YXIgdG90YWxQcm9jZXNzaW5nID0gY2h1bmtzLmZpbHRlcihmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLlBST0NFU1NJTkc7XG4gICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG90YWxQcm9jZXNzaW5nID49IDEpIHJldHVybjtcbiAgICAgICAgICAgIHByb2Nlc3NDaHVuaygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhYm9ydENodW5rcyA9IGZ1bmN0aW9uIGFib3J0Q2h1bmtzKCkge1xuICAgICAgICAgICAgY2h1bmtzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY2h1bmsudGltZW91dCk7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLnJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsucmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGxldCdzIGdvIVxuICAgICAgICBpZiAoIXN0YXRlLnNlcnZlcklkKSB7XG4gICAgICAgICAgICByZXF1ZXN0VHJhbnNmZXJJZChmdW5jdGlvbihzZXJ2ZXJJZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0b3AgaGVyZSBpZiBhYm9ydGVkLCBtaWdodCBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gcmVxdWVzdCBhbmQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFzcyBiYWNrIHRvIGl0ZW0gc28gd2UgY2FuIHVzZSBpdCBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZ1xuICAgICAgICAgICAgICAgIHRyYW5zZmVyKHNlcnZlcklkKTtcblxuICAgICAgICAgICAgICAgIC8vIHN0b3JlIGludGVybmFsbHlcbiAgICAgICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJJZCA9IHNlcnZlcklkO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NDaHVua3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFRyYW5zZmVyT2Zmc2V0KGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICAgICAgICAgIC8vIHN0b3AgaGVyZSBpZiBhYm9ydGVkLCBtaWdodCBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gcmVxdWVzdCBhbmQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gbWFyayBjaHVua3Mgd2l0aCBsb3dlciBvZmZzZXQgYXMgY29tcGxldGVcbiAgICAgICAgICAgICAgICBjaHVua3NcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rLm9mZnNldCA8IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkNPTVBMRVRFO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSBjaHVuay5zaXplO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ2h1bmtzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWJvcnRDaHVua3MoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaWduYXR1cmU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQ6KCkgPT4ge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICB2YXIgY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uID0gZnVuY3Rpb24gY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uKFxuICAgICAgICBhcGlVcmwsXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgbmFtZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZmlsZSwgbWV0YWRhdGEsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIHRyYW5zZmVyKSB7XG4gICAgICAgICAgICAvLyBubyBmaWxlIHJlY2VpdmVkXG4gICAgICAgICAgICBpZiAoIWZpbGUpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gaWYgd2FzIHBhc3NlZCBhIGZpbGUsIGFuZCB3ZSBjYW4gY2h1bmsgaXQsIGV4aXQgaGVyZVxuICAgICAgICAgICAgdmFyIGNhbkNodW5rVXBsb2FkID0gb3B0aW9ucy5jaHVua1VwbG9hZHM7XG4gICAgICAgICAgICB2YXIgc2hvdWxkQ2h1bmtVcGxvYWQgPSBjYW5DaHVua1VwbG9hZCAmJiBmaWxlLnNpemUgPiBvcHRpb25zLmNodW5rU2l6ZTtcbiAgICAgICAgICAgIHZhciB3aWxsQ2h1bmtVcGxvYWQgPSBjYW5DaHVua1VwbG9hZCAmJiAoc2hvdWxkQ2h1bmtVcGxvYWQgfHwgb3B0aW9ucy5jaHVua0ZvcmNlKTtcbiAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgQmxvYiAmJiB3aWxsQ2h1bmtVcGxvYWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NGaWxlQ2h1bmtlZChcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBsb2FkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2ZlcixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIHNldCBoYW5kbGVyc1xuICAgICAgICAgICAgdmFyIG9uZGF0YSA9XG4gICAgICAgICAgICAgICAgYWN0aW9uLm9uZGF0YSB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGZkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9ubG9hZCA9XG4gICAgICAgICAgICAgICAgYWN0aW9uLm9ubG9hZCB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgICAgICAgICAgYWN0aW9uLm9uZXJyb3IgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBhY3Rpb24uaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IGFjdGlvbi5oZWFkZXJzKGZpbGUsIG1ldGFkYXRhKSB8fCB7fVxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFyIHJlcXVlc3RQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24sIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBmb3JtZGF0YSBvYmplY3RcbiAgICAgICAgICAgIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgICAgICAvLyBhZGQgbWV0YWRhdGEgdW5kZXIgc2FtZSBuYW1lXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QobWV0YWRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFR1cm4gaW50byBhbiBhcnJheSBvZiBvYmplY3RzIHNvIG5vIG1hdHRlciB3aGF0IHRoZSBpbnB1dCwgd2UgY2FuIGhhbmRsZSBpdCB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAgIChmaWxlIGluc3RhbmNlb2YgQmxvYiA/IFt7IG5hbWU6IG51bGwsIGZpbGU6IGZpbGUgfV0gOiBmaWxlKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5uYW1lID09PSBudWxsID8gaXRlbS5maWxlLm5hbWUgOiAnJyArIGl0ZW0ubmFtZSArIGl0ZW0uZmlsZS5uYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzZW5kIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIG9uZGF0YShmb3JtRGF0YSksXG4gICAgICAgICAgICAgICAgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICBsb2FkKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uYWJvcnQgPSBhYm9ydDtcblxuICAgICAgICAgICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVByb2Nlc3NvckZ1bmN0aW9uID0gZnVuY3Rpb24gY3JlYXRlUHJvY2Vzc29yRnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcGlVcmwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgICAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gY3VzdG9tIGhhbmRsZXIgKHNob3VsZCBhbHNvIGhhbmRsZSBmaWxlLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MgYW5kIGFib3J0KVxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uLmFwcGx5KHZvaWQgMCwgW25hbWVdLmNvbmNhdChwYXJhbXMsIFtvcHRpb25zXSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWRcbiAgICAgICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBpbnRlcm5hbCBoYW5kbGVyXG4gICAgICAgIHJldHVybiBjcmVhdGVGaWxlUHJvY2Vzc29yRnVuY3Rpb24oYXBpVXJsLCBhY3Rpb24sIG5hbWUsIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2lnbmF0dXJlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHVuaXF1ZUZpbGVJZCwgbG9hZCwgZXJyb3IpID0+IHsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICB2YXIgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVSZXZlcnRGdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFwaVVybCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gaXMgY3VzdG9tIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkLCByZXR1cm4gc3R1YiBmdW5jdGlvbiwgaW50ZXJmYWNlIHdpbGwgd29yaywgYnV0IGZpbGUgd29uJ3QgYmUgcmVtb3ZlZFxuICAgICAgICBpZiAoIWFjdGlvbiB8fCAhaXNTdHJpbmcoYWN0aW9uLnVybCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih1bmlxdWVGaWxlSWQsIGxvYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBvbmxvYWQgaGFubGRlclxuICAgICAgICB2YXIgb25sb2FkID1cbiAgICAgICAgICAgIGFjdGlvbi5vbmxvYWQgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgICAgICBhY3Rpb24ub25lcnJvciB8fFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIGludGVybmFsIGltcGxlbWVudGF0aW9uXG4gICAgICAgIHJldHVybiBmdW5jdGlvbih1bmlxdWVGaWxlSWQsIGxvYWQsIGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIHVuaXF1ZUZpbGVJZCxcbiAgICAgICAgICAgICAgICBhcGlVcmwgKyBhY3Rpb24udXJsLFxuICAgICAgICAgICAgICAgIGFjdGlvbiAvLyBjb250YWlucyBtZXRob2QsIGhlYWRlcnMgYW5kIHdpdGhDcmVkZW50aWFscyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICBsb2FkKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFJhbmRvbU51bWJlciA9IGZ1bmN0aW9uIGdldFJhbmRvbU51bWJlcigpIHtcbiAgICAgICAgdmFyIG1pbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgdmFyIG1heCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICAgICAgcmV0dXJuIG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlciA9IGZ1bmN0aW9uIGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlcihjYikge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgIHZhciB0aWNrTWluID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAyNTtcbiAgICAgICAgdmFyIHRpY2tNYXggPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDI1MDtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHZhciB0aWNrID0gZnVuY3Rpb24gdGljaygpIHtcbiAgICAgICAgICAgIHZhciBydW50aW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgdmFyIGRlbGF5ID0gZ2V0UmFuZG9tTnVtYmVyKHRpY2tNaW4sIHRpY2tNYXgpO1xuXG4gICAgICAgICAgICBpZiAocnVudGltZSArIGRlbGF5ID4gZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkZWxheSA9IHJ1bnRpbWUgKyBkZWxheSAtIGR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBydW50aW1lIC8gZHVyYXRpb247XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPj0gMSB8fCBkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBjYigxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNiKHByb2dyZXNzKTtcblxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQodGljaywgZGVsYXkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkdXJhdGlvbiA+IDApIHRpY2soKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVGaWxlUHJvY2Vzc29yID0gZnVuY3Rpb24gY3JlYXRlRmlsZVByb2Nlc3Nvcihwcm9jZXNzRm4sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgICAgcGVyY2VpdmVkUHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICBwZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXI6IG51bGwsXG4gICAgICAgICAgICBwcm9ncmVzczogbnVsbCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgIHBlcmNlaXZlZER1cmF0aW9uOiAwLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICByZXF1ZXN0OiBudWxsLFxuICAgICAgICAgICAgcmVzcG9uc2U6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbiA9IG9wdGlvbnMuYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb247XG5cbiAgICAgICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGZpbGUsIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NGbiA9IGZ1bmN0aW9uIHByb2dyZXNzRm4oKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UndmUgbm90IHlldCBzdGFydGVkIHRoZSByZWFsIGRvd25sb2FkLCBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBtaWdodCBub3QgZ28gdGhyb3VnaCwgZm9yIGluc3RhbmNlLCB0aGVyZSBtaWdodCBiZSBzb21lIHNlcnZlciB0cm91YmxlXG4gICAgICAgICAgICAgICAgLy8gaWYgc3RhdGUucHJvZ3Jlc3MgaXMgbnVsbCwgdGhlIHNlcnZlciBkb2VzIG5vdCBhbGxvdyBjb21wdXRpbmcgcHJvZ3Jlc3MgYW5kIHdlIHNob3cgdGhlIHNwaW5uZXIgaW5zdGVhZFxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5kdXJhdGlvbiA9PT0gMCB8fCBzdGF0ZS5wcm9ncmVzcyA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gYXMgd2UncmUgbm93IHByb2Nlc3NpbmcsIGZpcmUgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ3Byb2dyZXNzJywgYXBpLmdldFByb2dyZXNzKCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlRm4gPSBmdW5jdGlvbiBjb21wbGV0ZUZuKCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnbG9hZC1wZXJjZWl2ZWQnLCBzdGF0ZS5yZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGxldCdzIHN0YXJ0IHByb2Nlc3NpbmdcbiAgICAgICAgICAgIGFwaS5maXJlKCdzdGFydCcpO1xuXG4gICAgICAgICAgICAvLyBzZXQgcmVxdWVzdCBzdGFydFxuICAgICAgICAgICAgc3RhdGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHBlcmNlaXZlZCBwZXJmb3JtYW5jZSBwcm9ncmVzcyBpbmRpY2F0b3JcbiAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlciA9IGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlcihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWREdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NGbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGZha2UgcHJvZ3Jlc3MgaXMgZG9uZSwgYW5kIGEgcmVzcG9uc2UgaGFzIGJlZW4gcmVjZWl2ZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSd2ZSBub3QgeWV0IGNhbGxlZCB0aGUgY29tcGxldGUgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5yZXNwb25zZSAmJiBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcyA9PT0gMSAmJiAhc3RhdGUuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbmUhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHJhbmRvbSBkZWxheSBhcyBpbiBhIGxpc3Qgb2YgZmlsZXMgeW91IHN0YXJ0IG5vdGljaW5nXG4gICAgICAgICAgICAgICAgLy8gZmlsZXMgdXBsb2FkaW5nIGF0IHRoZSBleGFjdCBzYW1lIHNwZWVkXG4gICAgICAgICAgICAgICAgYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb24gPyBnZXRSYW5kb21OdW1iZXIoNzUwLCAxNTAwKSA6IDBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHJlcXVlc3Qgc28gd2UgY2FuIGFib3J0IGl0IGxhdGVyXG4gICAgICAgICAgICBzdGF0ZS5yZXF1ZXN0ID0gcHJvY2Vzc0ZuKFxuICAgICAgICAgICAgICAgIC8vIHRoZSBmaWxlIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICBmaWxlLFxuXG4gICAgICAgICAgICAgICAgLy8gdGhlIG1ldGFkYXRhIHRvIHNlbmQgYWxvbmdcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcblxuICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrcyAobG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIpXG4gICAgICAgICAgICAgICAgLy8gbG9hZCBleHBlY3RzIHRoZSBib2R5IHRvIGJlIGEgc2VydmVyIGlkIGlmXG4gICAgICAgICAgICAgICAgLy8geW91IHdhbnQgdG8gbWFrZSB1c2Ugb2YgcmV2ZXJ0XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgcHV0IHRoZSByZXNwb25zZSBpbiBzdGF0ZSBzbyB3ZSBjYW4gYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IG91dHNpZGUgb2YgdGhpcyBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucmVzcG9uc2UgPSBpc09iamVjdChyZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogJycgKyByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgcHJvZ3Jlc3MgdG8gMSBhcyB3ZSdyZSBub3cgZG9uZVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsIGxvYWQgaXMgZG9uZSBsZXQncyBzaGFyZSByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkJywgc3RhdGUucmVzcG9uc2UuYm9keSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIHJlYWxseSBkb25lXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHBlcmNlaXZlZCBwcm9ncmVzcyBpcyAxICggd2FpdCBmb3IgcGVyY2VpdmVkIHByb2dyZXNzIHRvIGNvbXBsZXRlIClcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgaWYgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgcHJvZ3Jlc3MgKCBudWxsIClcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgIWFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb24gJiYgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIGVycm9yIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCB3aXRoIHR5cGUsIGNvZGUsIGJvZHlcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYW5jZWwgdXBkYXRlclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgb3RoZXJzIGFib3V0IHRoaXMgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAnJyArIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBhY3R1YWwgcHJvY2Vzc2luZyBwcm9ncmVzc1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGNvbXB1dGFibGUsIGN1cnJlbnQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBhY3R1YWwgZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBhY3R1YWwgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBjb21wdXRhYmxlID8gY3VycmVudCAvIHRvdGFsIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0ZuKCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIGFib3J0IGRvZXMgbm90IGV4cGVjdCBhIHZhbHVlXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgdXBkYXRlclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlIHRoZSBhYm9ydCBldmVudCBzbyB3ZSBjYW4gc3dpdGNoIHZpc3VhbHNcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2Fib3J0Jywgc3RhdGUucmVzcG9uc2UgPyBzdGF0ZS5yZXNwb25zZS5ib2R5IDogbnVsbCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBpZCBmb3IgdGhpcyB0cmFuc2ZlclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHRyYW5zZmVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoJ3RyYW5zZmVyJywgdHJhbnNmZXJJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICAgIC8vIG5vIHJlcXVlc3QgcnVubmluZywgY2FuJ3QgYWJvcnRcbiAgICAgICAgICAgIGlmICghc3RhdGUucmVxdWVzdCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHVwZGF0ZXJcbiAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlci5jbGVhcigpO1xuXG4gICAgICAgICAgICAvLyBhYm9ydCBhY3R1YWwgcmVxdWVzdFxuICAgICAgICAgICAgaWYgKHN0YXRlLnJlcXVlc3QuYWJvcnQpIHN0YXRlLnJlcXVlc3QuYWJvcnQoKTtcblxuICAgICAgICAgICAgLy8gaWYgaGFzIHJlc3BvbnNlIG9iamVjdCwgd2UndmUgY29tcGxldGVkIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIHN0YXRlLnByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIHN0YXRlLnRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWREdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBzdGF0ZS5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLnJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0UHJvZ3Jlc3MgPSBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvblxuICAgICAgICAgICAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5wcm9ncmVzcyA/IE1hdGgubWluKHN0YXRlLnByb2dyZXNzLCBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcykgOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnByb2dyZXNzIHx8IG51bGw7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldER1cmF0aW9uID0gYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb25cbiAgICAgICAgICAgID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oc3RhdGUuZHVyYXRpb24sIHN0YXRlLnBlcmNlaXZlZER1cmF0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXBpID0gT2JqZWN0LmFzc2lnbih7fSwgb24oKSwge1xuICAgICAgICAgICAgcHJvY2VzczogcHJvY2VzcywgLy8gc3RhcnQgcHJvY2Vzc2luZyBmaWxlXG4gICAgICAgICAgICBhYm9ydDogYWJvcnQsIC8vIGFib3J0IGFjdGl2ZSBwcm9jZXNzIHJlcXVlc3RcbiAgICAgICAgICAgIGdldFByb2dyZXNzOiBnZXRQcm9ncmVzcyxcbiAgICAgICAgICAgIGdldER1cmF0aW9uOiBnZXREdXJhdGlvbixcbiAgICAgICAgICAgIHJlc2V0OiByZXNldCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxhc3RJbmRleE9mKCcuJykpIHx8IG5hbWU7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVGaWxlU3R1YiA9IGZ1bmN0aW9uIGNyZWF0ZUZpbGVTdHViKHNvdXJjZSkge1xuICAgICAgICB2YXIgZGF0YSA9IFtzb3VyY2UubmFtZSwgc291cmNlLnNpemUsIHNvdXJjZS50eXBlXTtcblxuICAgICAgICAvLyBpcyBibG9iIG9yIGJhc2U2NCwgdGhlbiB3ZSBuZWVkIHRvIHNldCB0aGUgbmFtZVxuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQmxvYiB8fCBpc0Jhc2U2NERhdGFVUkkoc291cmNlKSkge1xuICAgICAgICAgICAgZGF0YVswXSA9IHNvdXJjZS5uYW1lIHx8IGdldERhdGVTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jhc2U2NERhdGFVUkkoc291cmNlKSkge1xuICAgICAgICAgICAgLy8gaWYgaXMgYmFzZTY0IGRhdGEgdXJpIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHRoZSBhdmVyYWdlIHNpemUgYW5kIHR5cGVcbiAgICAgICAgICAgIGRhdGFbMV0gPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgZGF0YVsyXSA9IGdldE1pbWVUeXBlRnJvbUJhc2U2NERhdGFVUkkoc291cmNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhzb3VyY2UpKSB7XG4gICAgICAgICAgICAvLyB1cmxcbiAgICAgICAgICAgIGRhdGFbMF0gPSBnZXRGaWxlbmFtZUZyb21VUkwoc291cmNlKTtcbiAgICAgICAgICAgIGRhdGFbMV0gPSAwO1xuICAgICAgICAgICAgZGF0YVsyXSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGRhdGFbMF0sXG4gICAgICAgICAgICBzaXplOiBkYXRhWzFdLFxuICAgICAgICAgICAgdHlwZTogZGF0YVsyXSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRmlsZSA9IGZ1bmN0aW9uIGlzRmlsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgaW5zdGFuY2VvZiBGaWxlIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IgJiYgdmFsdWUubmFtZSkpO1xuICAgIH07XG5cbiAgICB2YXIgZGVlcENsb25lT2JqZWN0ID0gZnVuY3Rpb24gZGVlcENsb25lT2JqZWN0KHNyYykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHNyYykpIHJldHVybiBzcmM7XG4gICAgICAgIHZhciB0YXJnZXQgPSBpc0FycmF5KHNyYykgPyBbXSA6IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICAgICAgICBpZiAoIXNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciB2ID0gc3JjW2tleV07XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHYgJiYgaXNPYmplY3QodikgPyBkZWVwQ2xvbmVPYmplY3QodikgOiB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJdGVtID0gZnVuY3Rpb24gY3JlYXRlSXRlbSgpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgdmFyIHNlcnZlckZpbGVSZWZlcmVuY2UgPVxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgICB2YXIgZmlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgICAgLy8gdW5pcXVlIGlkIGZvciB0aGlzIGl0ZW0sIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGl0ZW0gYWNyb3NzIHZpZXdzXG4gICAgICAgIHZhciBpZCA9IGdldFVuaXF1ZUlkKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGl0ZW0gc3RhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIC8vIGlzIGFyY2hpdmVkXG4gICAgICAgICAgICBhcmNoaXZlZDogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIGlmIGlzIGZyb3plbiwgbm8gbG9uZ2VyIGZpcmVzIGV2ZW50c1xuICAgICAgICAgICAgZnJvemVuOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gcmVtb3ZlZCBmcm9tIHZpZXdcbiAgICAgICAgICAgIHJlbGVhc2VkOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gb3JpZ2luYWwgc291cmNlXG4gICAgICAgICAgICBzb3VyY2U6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIGZpbGUgbW9kZWwgcmVmZXJlbmNlXG4gICAgICAgICAgICBmaWxlOiBmaWxlLFxuXG4gICAgICAgICAgICAvLyBpZCBvZiBmaWxlIG9uIHNlcnZlclxuICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogc2VydmVyRmlsZVJlZmVyZW5jZSxcblxuICAgICAgICAgICAgLy8gaWQgb2YgZmlsZSB0cmFuc2ZlciBvbiBzZXJ2ZXJcbiAgICAgICAgICAgIHRyYW5zZmVySWQ6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIGlzIGFib3J0ZWRcbiAgICAgICAgICAgIHByb2Nlc3NpbmdBYm9ydGVkOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gY3VycmVudCBpdGVtIHN0YXR1c1xuICAgICAgICAgICAgc3RhdHVzOiBzZXJ2ZXJGaWxlUmVmZXJlbmNlID8gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFIDogSXRlbVN0YXR1cy5JTklULFxuXG4gICAgICAgICAgICAvLyBhY3RpdmUgcHJvY2Vzc2VzXG4gICAgICAgICAgICBhY3RpdmVMb2FkZXI6IG51bGwsXG4gICAgICAgICAgICBhY3RpdmVQcm9jZXNzb3I6IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2FsbGJhY2sgdXNlZCB3aGVuIGFib3J0IHByb2Nlc3NpbmcgaXMgY2FsbGVkIHRvIGxpbmsgYmFjayB0byB0aGUgcmVzb2x2ZSBtZXRob2RcbiAgICAgICAgdmFyIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4dGVybmFsbHkgYWRkZWQgaXRlbSBtZXRhZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIG1ldGFkYXRhID0ge307XG5cbiAgICAgICAgLy8gaXRlbSBkYXRhXG4gICAgICAgIHZhciBzZXRTdGF0dXMgPSBmdW5jdGlvbiBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICByZXR1cm4gKHN0YXRlLnN0YXR1cyA9IHN0YXR1cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZmlyZSBldmVudCB1bmxlc3MgdGhlIGl0ZW0gaGFzIGJlZW4gYXJjaGl2ZWRcbiAgICAgICAgdmFyIGZpcmUgPSBmdW5jdGlvbiBmaXJlKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUucmVsZWFzZWQgfHwgc3RhdGUuZnJvemVuKSByZXR1cm47XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7XG4gICAgICAgICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXBpLmZpcmUuYXBwbHkoYXBpLCBbZXZlbnRdLmNvbmNhdChwYXJhbXMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBmaWxlIGRhdGFcbiAgICAgICAgdmFyIGdldEZpbGVFeHRlbnNpb24gPSBmdW5jdGlvbiBnZXRGaWxlRXh0ZW5zaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZShzdGF0ZS5maWxlLm5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0RmlsZVR5cGUgPSBmdW5jdGlvbiBnZXRGaWxlVHlwZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5maWxlLnR5cGU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRGaWxlU2l6ZSA9IGZ1bmN0aW9uIGdldEZpbGVTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZpbGUuc2l6ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldEZpbGUgPSBmdW5jdGlvbiBnZXRGaWxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZpbGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbG9naWMgdG8gbG9hZCBhIGZpbGVcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIGxvYWQgPSBmdW5jdGlvbiBsb2FkKHNvdXJjZSwgbG9hZGVyLCBvbmxvYWQpIHtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBvcmlnaW5hbCBpdGVtIHNvdXJjZVxuICAgICAgICAgICAgc3RhdGUuc291cmNlID0gc291cmNlO1xuXG4gICAgICAgICAgICAvLyBzb3VyY2UgaXMga25vd25cbiAgICAgICAgICAgIGFwaS5maXJlU3luYygnaW5pdCcpO1xuXG4gICAgICAgICAgICAvLyBmaWxlIHN0dWIgaXMgYWxyZWFkeSB0aGVyZVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZpbGUpIHtcbiAgICAgICAgICAgICAgICBhcGkuZmlyZVN5bmMoJ2xvYWQtc2tpcCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IGEgc3R1YiBmaWxlIG9iamVjdCB3aGlsZSBsb2FkaW5nIHRoZSBhY3R1YWwgZGF0YVxuICAgICAgICAgICAgc3RhdGUuZmlsZSA9IGNyZWF0ZUZpbGVTdHViKHNvdXJjZSk7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0cyBsb2FkaW5nXG4gICAgICAgICAgICBsb2FkZXIub24oJ2luaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLWluaXQnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB3ZSdldmUgcmVjZWl2ZWQgYSBzaXplIGluZGljYXRpb24sIGxldCdzIHVwZGF0ZSB0aGUgc3R1YlxuICAgICAgICAgICAgbG9hZGVyLm9uKCdtZXRhJywgZnVuY3Rpb24obWV0YSkge1xuICAgICAgICAgICAgICAgIC8vIHNldCBzaXplIG9mIGZpbGUgc3R1YlxuICAgICAgICAgICAgICAgIHN0YXRlLmZpbGUuc2l6ZSA9IG1ldGEuc2l6ZTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCBuYW1lIG9mIGZpbGUgc3R1YlxuICAgICAgICAgICAgICAgIHN0YXRlLmZpbGUuZmlsZW5hbWUgPSBtZXRhLmZpbGVuYW1lO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgaGFzIHJlY2VpdmVkIHNvdXJjZSwgd2UgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChtZXRhLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW4gPSBGaWxlT3JpZ2luLkxJTUJPO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlID0gbWV0YS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA9IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzaXplIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLW1ldGEnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB0aGUgZmlsZSBpcyBub3cgbG9hZGluZyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yc1xuICAgICAgICAgICAgbG9hZGVyLm9uKCdwcm9ncmVzcycsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuTE9BRElORyk7XG5cbiAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLXByb2dyZXNzJywgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGFuIGVycm9yIHdhcyB0aHJvd24gd2hpbGUgbG9hZGluZyB0aGUgZmlsZSwgd2UgbmVlZCB0byBzd2l0Y2ggdG8gZXJyb3Igc3RhdGVcbiAgICAgICAgICAgIGxvYWRlci5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLkxPQURfRVJST1IpO1xuXG4gICAgICAgICAgICAgICAgZmlyZSgnbG9hZC1yZXF1ZXN0LWVycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHVzZXIgb3IgYW5vdGhlciBwcm9jZXNzIGFib3J0ZWQgdGhlIGZpbGUgbG9hZCAoY2Fubm90IHJldHJ5KVxuICAgICAgICAgICAgbG9hZGVyLm9uKCdhYm9ydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklOSVQpO1xuICAgICAgICAgICAgICAgIGZpcmUoJ2xvYWQtYWJvcnQnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBkb25lIGxvYWRpbmdcbiAgICAgICAgICAgIGxvYWRlci5vbignbG9hZCcsIGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBhcyB3ZSd2ZSBub3cgbG9hZGVkIHRoZSBmaWxlIHRoZSBsb2FkZXIgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIGZpbGUgaGFzIGxvYWRlZCBzdWNjZXNmdWxseVxuICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzID0gZnVuY3Rpb24gc3VjY2VzcyhyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IChwb3NzaWJseSkgdHJhbnNmb3JtZWQgZmlsZVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5maWxlID0gaXNGaWxlKHJlc3VsdCkgPyByZXN1bHQgOiBzdGF0ZS5maWxlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbGUgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MSU1CTyAmJiBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZmlyZSgnbG9hZCcpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IG9yaWdpbmFsIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGZpcmUoJ2xvYWQtbWV0YScpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLkxPQURfRVJST1IpO1xuICAgICAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLWZpbGUtZXJyb3InLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzZXJ2ZXIgZmlsZSByZWZlcmVuY2UsIHdlIGRvbid0IG5lZWQgdG8gY2FsbCB0aGUgb25sb2FkIG1ldGhvZFxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBubyBzZXJ2ZXIgaWQsIGxldCdzIGdpdmUgdGhpcyBmaWxlIHRoZSBmdWxsIHRyZWF0bWVudFxuICAgICAgICAgICAgICAgIG9ubG9hZChmaWxlLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gc2V0IGxvYWRlciBzb3VyY2UgZGF0YVxuICAgICAgICAgICAgbG9hZGVyLnNldFNvdXJjZShzb3VyY2UpO1xuXG4gICAgICAgICAgICAvLyBzZXQgYXMgYWN0aXZlIGxvYWRlclxuICAgICAgICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyID0gbG9hZGVyO1xuXG4gICAgICAgICAgICAvLyBsb2FkIHRoZSBzb3VyY2UgZGF0YVxuICAgICAgICAgICAgbG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmV0cnlMb2FkID0gZnVuY3Rpb24gcmV0cnlMb2FkKCkge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5hY3RpdmVMb2FkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhYm9ydExvYWQgPSBmdW5jdGlvbiBhYm9ydExvYWQoKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlTG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSU5JVCk7XG4gICAgICAgICAgICBmaXJlKCdsb2FkLWFib3J0Jyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbG9naWMgdG8gcHJvY2VzcyBhIGZpbGVcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKHByb2Nlc3Nvciwgb25wcm9jZXNzKSB7XG4gICAgICAgICAgICAvLyBwcm9jZXNzaW5nIHdhcyBhYm9ydGVkXG4gICAgICAgICAgICBpZiAoc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcm9jZXNzaW5nQWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm93IHByb2Nlc3NpbmdcbiAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkcpO1xuXG4gICAgICAgICAgICAvLyByZXNldCBhYm9ydCBjYWxsYmFja1xuICAgICAgICAgICAgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gaWYgbm8gZmlsZSBsb2FkZWQgd2UnbGwgd2FpdCBmb3IgdGhlIGxvYWQgZXZlbnRcbiAgICAgICAgICAgIGlmICghKHN0YXRlLmZpbGUgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgICAgICAgICAgICAgIGFwaS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKHByb2Nlc3Nvciwgb25wcm9jZXNzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldHVwIHByb2Nlc3NvclxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uKCdsb2FkJywgZnVuY3Rpb24oc2VydmVyRmlsZVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdGhpcyBpZCB0byBiZSBhYmxlIHRvIHJldmVydCB0aGUgdXBsb2FkXG4gICAgICAgICAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IHNlcnZlckZpbGVSZWZlcmVuY2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcmVnaXN0ZXIgdHJhbnNmZXIgaWRcbiAgICAgICAgICAgIHByb2Nlc3Nvci5vbigndHJhbnNmZXInLCBmdW5jdGlvbih0cmFuc2ZlcklkKSB7XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGlkIHRvIGJlIGFibGUgdG8gcmV2ZXJ0IHRoZSB1cGxvYWRcbiAgICAgICAgICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gdHJhbnNmZXJJZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9jZXNzb3Iub24oJ2xvYWQtcGVyY2VpdmVkJywgZnVuY3Rpb24oc2VydmVyRmlsZVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciByZXF1aXJlZFxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3NvciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRoaXMgaWQgdG8gYmUgYWJsZSB0byByZXZlciB0aGUgdXBsb2FkXG4gICAgICAgICAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IHNlcnZlckZpbGVSZWZlcmVuY2U7XG5cbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKTtcbiAgICAgICAgICAgICAgICBmaXJlKCdwcm9jZXNzLWNvbXBsZXRlJywgc2VydmVyRmlsZVJlZmVyZW5jZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3Mtc3RhcnQnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9jZXNzb3Iub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfRVJST1IpO1xuICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uKCdhYm9ydCcsIGZ1bmN0aW9uKHNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgZmlsZSB3YXMgdXBsb2FkZWQgYnV0IHByb2Nlc3Npbmcgd2FzIGNhbmNlbGxlZCBkdXJpbmcgcGVyY2VpdmVkIHByb2Nlc3NvciB0aW1lIHN0b3JlIGZpbGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IHNlcnZlckZpbGVSZWZlcmVuY2U7XG5cbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgICAgICAgICBmaXJlKCdwcm9jZXNzLWFib3J0Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBoYXMgdGltZW91dCBzbyBkb2Vzbid0IGludGVyZmVyZSB3aXRoIHJlbW92ZSBhY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9jZXNzb3Iub24oJ3Byb2dyZXNzJywgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBmaXJlKCdwcm9jZXNzLXByb2dyZXNzJywgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHdoZW4gc3VjY2Vzc2Z1bGx5IHRyYW5zZm9ybWVkXG4gICAgICAgICAgICB2YXIgc3VjY2VzcyA9IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdhcyBhcmNoaXZlZCBpbiB0aGUgbWVhbiB0aW1lLCBkb24ndCBwcm9jZXNzXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmFyY2hpdmVkKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGZpbGUhXG4gICAgICAgICAgICAgICAgcHJvY2Vzc29yLnByb2Nlc3MoZmlsZSwgT2JqZWN0LmFzc2lnbih7fSwgbWV0YWRhdGEpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyB0cmFuc2Zvcm0gcGhhc2VcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGNvbnNvbGUuZXJyb3I7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIGZpbGVcbiAgICAgICAgICAgIG9ucHJvY2VzcyhzdGF0ZS5maWxlLCBzdWNjZXNzLCBlcnJvcik7XG5cbiAgICAgICAgICAgIC8vIHNldCBhcyBhY3RpdmUgcHJvY2Vzc29yXG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlcXVlc3RQcm9jZXNzaW5nID0gZnVuY3Rpb24gcmVxdWVzdFByb2Nlc3NpbmcoKSB7XG4gICAgICAgICAgICBzdGF0ZS5wcm9jZXNzaW5nQWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhYm9ydFByb2Nlc3NpbmcgPSBmdW5jdGlvbiBhYm9ydFByb2Nlc3NpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuYWN0aXZlUHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1hYm9ydCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSA9IGZ1bmN0aW9uIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IuYWJvcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGxvZ2ljIHRvIHJldmVydCBhIHByb2Nlc3NlZCBmaWxlXG4gICAgICAgIC8vXG4gICAgICAgIHZhciByZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQocmV2ZXJ0RmlsZVVwbG9hZCwgZm9yY2VSZXZlcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBhIGNvbXBsZXRlZCB1cGxvYWQgd2lsbCBoYXZlIGEgc2VydmVyRmlsZVJlZmVyZW5jZSwgYSBmYWlsZWQgY2h1bmtlZCB1cGxvYWQgd2hlcmVcbiAgICAgICAgICAgICAgICAvLyBnZXR0aW5nIGEgc2VydmVySWQgc3VjY2VlZGVkIGJ1dCA+PTAgY2h1bmtzIGhhdmUgYmVlbiB1cGxvYWRlZCB3aWxsIGhhdmUgdHJhbnNmZXJJZCBzZXRcbiAgICAgICAgICAgICAgICB2YXIgc2VydmVyVHJhbnNmZXJJZCA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgIT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzdGF0ZS50cmFuc2ZlcklkO1xuXG4gICAgICAgICAgICAgICAgLy8gY2Fubm90IHJldmVydCB3aXRob3V0IGEgc2VydmVyIGlkIGZvciB0aGlzIHByb2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyVHJhbnNmZXJJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByZXZlcnQgdGhlIHVwbG9hZCAoZmlyZSBhbmQgZm9yZ2V0KVxuICAgICAgICAgICAgICAgIHJldmVydEZpbGVVcGxvYWQoXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclRyYW5zZmVySWQsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgZmlsZSBzZXJ2ZXIgaWQgYW5kIHRyYW5zZmVyIGlkIGFzIG5vdyBpdCdzIG5vdCBhdmFpbGFibGUgb24gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHNldCBlcnJvciBzdGF0ZSB3aGVuIHJldmVydGluZyBpcyBvcHRpb25hbCwgaXQgd2lsbCBhbHdheXMgcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3JjZVJldmVydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9oIG5vIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1yZXZlcnQtZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlyZSBldmVudFxuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtcmV2ZXJ0Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBleHBvc2VkIG1ldGhvZHNcbiAgICAgICAgdmFyIF9zZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIHNldE1ldGFkYXRhKGtleSwgdmFsdWUsIHNpbGVudCkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciByb290ID0ga2V5c1swXTtcbiAgICAgICAgICAgIHZhciBsYXN0ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkYXRhID0gZGF0YVtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjb21wYXJlIG9sZCB2YWx1ZSBhZ2FpbnN0IG5ldyB2YWx1ZSwgaWYgdGhleSdyZSB0aGUgc2FtZSwgd2UncmUgbm90IHVwZGF0aW5nXG4gICAgICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoZGF0YVtsYXN0XSkgPT09IEpTT04uc3RyaW5naWZ5KHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdmFsdWVcbiAgICAgICAgICAgIGRhdGFbbGFzdF0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gZmlyZSB1cGRhdGVcbiAgICAgICAgICAgIGZpcmUoJ21ldGFkYXRhLXVwZGF0ZScsIHtcbiAgICAgICAgICAgICAgICBrZXk6IHJvb3QsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1ldGFkYXRhW3Jvb3RdLFxuICAgICAgICAgICAgICAgIHNpbGVudDogc2lsZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldE1ldGFkYXRhID0gZnVuY3Rpb24gZ2V0TWV0YWRhdGEoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZGVlcENsb25lT2JqZWN0KGtleSA/IG1ldGFkYXRhW2tleV0gOiBtZXRhZGF0YSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFwaSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChvcmlnaW4gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJJZDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJJZDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS50cmFuc2ZlcklkO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24oc3RhdGUuZmlsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpbGVFeHRlbnNpb246IHsgZ2V0OiBnZXRGaWxlRXh0ZW5zaW9uIH0sXG4gICAgICAgICAgICAgICAgZmlsZVR5cGU6IHsgZ2V0OiBnZXRGaWxlVHlwZSB9LFxuICAgICAgICAgICAgICAgIGZpbGVTaXplOiB7IGdldDogZ2V0RmlsZVNpemUgfSxcbiAgICAgICAgICAgICAgICBmaWxlOiB7IGdldDogZ2V0RmlsZSB9LFxuICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5maWxlLl9yZWxhdGl2ZVBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGdldE1ldGFkYXRhOiBnZXRNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBzZXRNZXRhZGF0YTogZnVuY3Rpb24gc2V0TWV0YWRhdGEoa2V5LCB2YWx1ZSwgc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NldE1ldGFkYXRhKGtleSwgZGF0YVtrZXldLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3NldE1ldGFkYXRhKGtleSwgdmFsdWUsIHNpbGVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQobmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGl0ZW1BUElbbmFtZV0gPSBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgYWJvcnRMb2FkOiBhYm9ydExvYWQsXG4gICAgICAgICAgICAgICAgcmV0cnlMb2FkOiByZXRyeUxvYWQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdFByb2Nlc3Npbmc6IHJlcXVlc3RQcm9jZXNzaW5nLFxuICAgICAgICAgICAgICAgIGFib3J0UHJvY2Vzc2luZzogYWJvcnRQcm9jZXNzaW5nLFxuXG4gICAgICAgICAgICAgICAgbG9hZDogbG9hZCxcbiAgICAgICAgICAgICAgICBwcm9jZXNzOiBwcm9jZXNzLFxuICAgICAgICAgICAgICAgIHJldmVydDogcmV2ZXJ0LFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb24oKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcmVlemU6IGZ1bmN0aW9uIGZyZWV6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzdGF0ZS5mcm96ZW4gPSB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcmVsZWFzZTogZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzdGF0ZS5yZWxlYXNlZCA9IHRydWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVsZWFzZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUucmVsZWFzZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGFyY2hpdmU6IGZ1bmN0aW9uIGFyY2hpdmUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoc3RhdGUuYXJjaGl2ZWQgPSB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyY2hpdmVkOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmFyY2hpdmVkO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHNvdXJjZSBhbmQgZmlsZSBvYmplY3RcbiAgICAgICAgICAgICAgICBzZXRGaWxlOiBmdW5jdGlvbiBzZXRGaWxlKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzdGF0ZS5maWxlID0gZmlsZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBjcmVhdGUgaXQgaGVyZSBpbnN0ZWFkIG9mIHJldHVybmluZyBpdCBpbnN0YW50bHkgc28gd2UgY2FuIGV4dGVuZCBpdCBsYXRlclxuICAgICAgICB2YXIgaXRlbUFQSSA9IGNyZWF0ZU9iamVjdChhcGkpO1xuXG4gICAgICAgIHJldHVybiBpdGVtQVBJO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SXRlbUluZGV4QnlRdWVyeSA9IGZ1bmN0aW9uIGdldEl0ZW1JbmRleEJ5UXVlcnkoaXRlbXMsIHF1ZXJ5KSB7XG4gICAgICAgIC8vIGp1c3QgcmV0dXJuIGZpcnN0IGluZGV4XG4gICAgICAgIGlmIChpc0VtcHR5KHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbnZhbGlkIHF1ZXJpZXNcbiAgICAgICAgaWYgKCFpc1N0cmluZyhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBpdGVtIGJ5IGlkIChvciAtMSBpZiBub3QgZm91bmQpXG4gICAgICAgIHJldHVybiBpdGVtcy5maW5kSW5kZXgoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IHF1ZXJ5O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEl0ZW1CeUlkID0gZnVuY3Rpb24gZ2V0SXRlbUJ5SWQoaXRlbXMsIGl0ZW1JZCkge1xuICAgICAgICB2YXIgaW5kZXggPSBnZXRJdGVtSW5kZXhCeVF1ZXJ5KGl0ZW1zLCBpdGVtSWQpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zW2luZGV4XSB8fCBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgZmV0Y2hCbG9iID0gZnVuY3Rpb24gZmV0Y2hCbG9iKHVybCwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgaGVhZGVycykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KG51bGwsIHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2Jsb2InLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgLy8gZ2V0IGhlYWRlcnNcbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuXG4gICAgICAgICAgICAvLyBnZXQgZmlsZW5hbWVcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoaGVhZGVycykubmFtZSB8fCBnZXRGaWxlbmFtZUZyb21VUkwodXJsKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHJlc3BvbnNlXG4gICAgICAgICAgICBsb2FkKFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKCdsb2FkJywgeGhyLnN0YXR1cywgZ2V0RmlsZUZyb21CbG9iKHhoci5yZXNwb25zZSwgZmlsZW5hbWUpLCBoZWFkZXJzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgIGVycm9yKGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIHhoci5zdGF0dXMsIHhoci5zdGF0dXNUZXh0LCB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uaGVhZGVycyA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgaGVhZGVycyhjcmVhdGVSZXNwb25zZSgnaGVhZGVycycsIHhoci5zdGF0dXMsIG51bGwsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGFib3J0O1xuXG4gICAgICAgIC8vIHNob3VsZCByZXR1cm4gcmVxdWVzdFxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9O1xuXG4gICAgdmFyIGdldERvbWFpbkZyb21VUkwgPSBmdW5jdGlvbiBnZXREb21haW5Gcm9tVVJMKHVybCkge1xuICAgICAgICBpZiAodXJsLmluZGV4T2YoJy8vJykgPT09IDApIHtcbiAgICAgICAgICAgIHVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgdXJsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmxcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAucmVwbGFjZSgnYmxvYjonLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oW2Etel0pPzpcXC9cXC8vLCAnJDEnKVxuICAgICAgICAgICAgLnNwbGl0KCcvJylbMF07XG4gICAgfTtcblxuICAgIHZhciBpc0V4dGVybmFsVVJMID0gZnVuY3Rpb24gaXNFeHRlcm5hbFVSTCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh1cmwuaW5kZXhPZignOicpID4gLTEgfHwgdXJsLmluZGV4T2YoJy8vJykgPiAtMSkgJiZcbiAgICAgICAgICAgIGdldERvbWFpbkZyb21VUkwobG9jYXRpb24uaHJlZikgIT09IGdldERvbWFpbkZyb21VUkwodXJsKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgZHluYW1pY0xhYmVsID0gZnVuY3Rpb24gZHluYW1pY0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGxhYmVsKSA/IGxhYmVsLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKSA6IGxhYmVsO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgaXNNb2NrSXRlbSA9IGZ1bmN0aW9uIGlzTW9ja0l0ZW0oaXRlbSkge1xuICAgICAgICByZXR1cm4gIWlzRmlsZShpdGVtLmZpbGUpO1xuICAgIH07XG5cbiAgICB2YXIgbGlzdFVwZGF0ZWQgPSBmdW5jdGlvbiBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLmxpc3RVcGRhdGVUaW1lb3V0KTtcbiAgICAgICAgc3RhdGUubGlzdFVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTVMnLCB7IGl0ZW1zOiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykgfSk7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG5cbiAgICB2YXIgb3B0aW9uYWxQcm9taXNlID0gZnVuY3Rpb24gb3B0aW9uYWxQcm9taXNlKGZuKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxO1xuICAgICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgICBfa2V5KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBwYXJhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHNvcnRJdGVtcyA9IGZ1bmN0aW9uIHNvcnRJdGVtcyhzdGF0ZSwgY29tcGFyZSkge1xuICAgICAgICBzdGF0ZS5pdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKGNyZWF0ZUl0ZW1BUEkoYSksIGNyZWF0ZUl0ZW1BUEkoYikpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gcmV0dXJucyBpdGVtIGJhc2VkIG9uIHN0YXRlXG4gICAgdmFyIGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlID0gZnVuY3Rpb24gZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGl0ZW1IYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IF9yZWYucXVlcnksXG4gICAgICAgICAgICAgICAgX3JlZiRzdWNjZXNzID0gX3JlZi5zdWNjZXNzLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBfcmVmJHN1Y2Nlc3MgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgX3JlZiRmYWlsdXJlID0gX3JlZi5mYWlsdXJlLFxuICAgICAgICAgICAgICAgIGZhaWx1cmUgPSBfcmVmJGZhaWx1cmUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJGZhaWx1cmUsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3F1ZXJ5JywgJ3N1Y2Nlc3MnLCAnZmFpbHVyZSddKTtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUoe1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ2Vycm9yJywgMCwgJ0l0ZW0gbm90IGZvdW5kJyksXG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtSGFuZGxlcihpdGVtLCBzdWNjZXNzLCBmYWlsdXJlLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGFjdGlvbnMgPSBmdW5jdGlvbiBhY3Rpb25zKGRpc3BhdGNoLCBxdWVyeSwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWJvcnRzIGFsbCBvbmdvaW5nIHByb2Nlc3Nlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBQk9SVF9BTEw6IGZ1bmN0aW9uIEFCT1JUX0FMTCgpIHtcbiAgICAgICAgICAgICAgICBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZnJlZXplKCk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYWJvcnRMb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYWJvcnRQcm9jZXNzaW5nKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldHMgaW5pdGlhbCBmaWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBESURfU0VUX0ZJTEVTOiBmdW5jdGlvbiBESURfU0VUX0ZJTEVTKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWYyJHZhbHVlID0gX3JlZjIudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3JlZjIkdmFsdWUgPT09IHZvaWQgMCA/IFtdIDogX3JlZjIkdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gbWFwIHZhbHVlcyB0byBmaWxlIG9iamVjdHNcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSB2YWx1ZS5tYXAoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBmaWxlLnNvdXJjZSA/IGZpbGUuc291cmNlIDogZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGZpbGUub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGxvb3Agb3ZlciBmaWxlcywgaWYgZmlsZSBpcyBpbiBsaXN0LCBsZWF2ZSBpdCBiZSwgaWYgbm90LCByZW1vdmVcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IGlmIGl0ZW1zIHNob3VsZCBiZSBtb3ZlZFxuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVJdGVtcyA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKTtcblxuICAgICAgICAgICAgICAgIGFjdGl2ZUl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdGVtIG5vdCBpcyBpbiBuZXcgdmFsdWUsIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhZmlsZXMuZmluZChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUuc291cmNlID09PSBpdGVtLnNvdXJjZSB8fCBmaWxlLnNvdXJjZSA9PT0gaXRlbS5maWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtLCByZW1vdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgbmV3IGZpbGVzXG4gICAgICAgICAgICAgICAgYWN0aXZlSXRlbXMgPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyk7XG4gICAgICAgICAgICAgICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBmaWxlIGlzIGFscmVhZHkgaW4gbGlzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVJdGVtcy5maW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5zb3VyY2UgPT09IGZpbGUuc291cmNlIHx8IGl0ZW0uZmlsZSA9PT0gZmlsZS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGluIGxpc3QsIGFkZFxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICdBRERfSVRFTScsXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBmaWxlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLk5PTkUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIERJRF9VUERBVEVfSVRFTV9NRVRBREFUQTogZnVuY3Rpb24gRElEX1VQREFURV9JVEVNX01FVEFEQVRBKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX3JlZjMuaWQsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlID0gX3JlZjMuY2hhbmdlO1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5zaWxlbnQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBjbG9zZSBzdWNjZXNzaW9uIHdlIGNvbWJpbmVkIGFsbCBjYWxscyB0b2dldGhlciB0byBzYXZlIHJlc291cmNlc1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzdGF0ZS5pdGVtVXBkYXRlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXRlbVVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGdldEl0ZW1CeUlkKHN0YXRlLml0ZW1zLCBpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSByZXZlcnQgYW5kIGF0dGVtcHQgdG8gdXBsb2FkIHdoZW4gd2UncmUgdXBsb2FkaW5nIHRvIGEgc2VydmVyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcXVlcnkoJ0lTX0FTWU5DJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCB3ZSB1cGRhdGUgdGhlIG91dHB1dCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdTSE9VTERfUFJFUEFSRV9PVVRQVVQnLCBmYWxzZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihzaG91bGRQcmVwYXJlT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGx1Z2lucyBkZXRlcm1pbmVkIHRoZSBvdXRwdXQgZGF0YSBzaG91bGQgYmUgcHJlcGFyZWQgKG9yIG5vdCksIGNhbiBiZSBhZGp1c3RlZCB3aXRoIGJlZm9yZVByZXBhcmVPdXRwdXQgaG9va1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZWZvcmVQcmVwYXJlRmlsZSA9IHF1ZXJ5KCdHRVRfQkVGT1JFX1BSRVBBUkVfRklMRScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVQcmVwYXJlRmlsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkUHJlcGFyZU91dHB1dCA9IGJlZm9yZVByZXBhcmVGaWxlKGl0ZW0sIHNob3VsZFByZXBhcmVPdXRwdXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRQcmVwYXJlT3V0cHV0KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1JFUVVFU1RfUFJFUEFSRV9PVVRQVVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGlkLCBmaWxlOiBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpcyBsb2NhbCBpdGVtIHdlIG5lZWQgdG8gZW5hYmxlIHVwbG9hZCBidXR0b24gc28gY2hhbmdlIGNhbiBiZSBwcm9wYWdhdGVkIHRvIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfTE9BRF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IGl0ZW0uc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYXN5bmMgc2NlbmFyaW9zXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGxvYWQgPSBmdW5jdGlvbiB1cGxvYWQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBwdXNoIHRoaXMgZm9yd2FyZCBhIGJpdCBzbyB0aGUgaW50ZXJmYWNlIGlzIHVwZGF0ZWQgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMzIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQoZG9VcGxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucmV2ZXJ0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJldmVydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGRvVXBsb2FkID8gdXBsb2FkIDogZnVuY3Rpb24oKSB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoZG9VcGxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYWJvcnRQcm9jZXNzaW5nKCkudGhlbihkb1VwbG9hZCA/IHVwbG9hZCA6IGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIHNob3VsZCByZS11cGxvYWQgdGhlIGZpbGUgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXZlcnQoc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGN1cnJlbnRseSB1cGxvYWRpbmcsIGNhbmNlbCB1cGxvYWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhYm9ydChzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIE1PVkVfSVRFTTogZnVuY3Rpb24gTU9WRV9JVEVNKF9yZWY0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjQucXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gX3JlZjQuaW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBzdGF0ZS5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gbGltaXQoaW5kZXgsIDAsIHN0YXRlLml0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IGluZGV4KSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3RhdGUuaXRlbXMuc3BsaWNlKGluZGV4LCAwLCBzdGF0ZS5pdGVtcy5zcGxpY2UoY3VycmVudEluZGV4LCAxKVswXSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBTT1JUOiBmdW5jdGlvbiBTT1JUKF9yZWY1KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBhcmUgPSBfcmVmNS5jb21wYXJlO1xuICAgICAgICAgICAgICAgIHNvcnRJdGVtcyhzdGF0ZSwgY29tcGFyZSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9TT1JUX0lURU1TJywge1xuICAgICAgICAgICAgICAgICAgICBpdGVtczogcXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEFERF9JVEVNUzogZnVuY3Rpb24gQUREX0lURU1TKF9yZWY2KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gX3JlZjYuaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gX3JlZjYuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kID0gX3JlZjYuaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY2JHN1Y2Nlc3MgPSBfcmVmNi5zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gX3JlZjYkc3VjY2VzcyA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWY2JHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY2JGZhaWx1cmUgPSBfcmVmNi5mYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlID0gX3JlZjYkZmFpbHVyZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWY2JGZhaWx1cmU7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSB8fCB0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnNlcnRMb2NhdGlvbiA9IHF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT04nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsSXRlbXMgPSBxdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGluc2VydExvY2F0aW9uID09PSAnYmVmb3JlJyA/IDAgOiB0b3RhbEl0ZW1zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpZ25vcmVkRmlsZXMgPSBxdWVyeSgnR0VUX0lHTk9SRURfRklMRVMnKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNWYWxpZEZpbGUgPSBmdW5jdGlvbiBpc1ZhbGlkRmlsZShzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRmlsZShzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICFpZ25vcmVkRmlsZXMuaW5jbHVkZXMoc291cmNlLm5hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogIWlzRW1wdHkoc291cmNlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciB2YWxpZEl0ZW1zID0gaXRlbXMuZmlsdGVyKGlzVmFsaWRGaWxlKTtcblxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IHZhbGlkSXRlbXMubWFwKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnQUREX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IGludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLnNvdXJjZSB8fCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiByZWplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCsrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHNvdXJjZS5vcHRpb25zIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmYWlsdXJlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHNvdXJjZVxuICAgICAgICAgICAgICogQHBhcmFtIGluZGV4XG4gICAgICAgICAgICAgKiBAcGFyYW0gaW50ZXJhY3Rpb25NZXRob2RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQUREX0lURU06IGZ1bmN0aW9uIEFERF9JVEVNKF9yZWY3KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IF9yZWY3LnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjckaW5kZXggPSBfcmVmNy5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBfcmVmNyRpbmRleCA9PT0gdm9pZCAwID8gLTEgOiBfcmVmNyRpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2QgPSBfcmVmNy5pbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjckc3VjY2VzcyA9IF9yZWY3LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBfcmVmNyRzdWNjZXNzID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjckc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjckZmFpbHVyZSA9IF9yZWY3LmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmUgPSBfcmVmNyRmYWlsdXJlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjckZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjckb3B0aW9ucyA9IF9yZWY3Lm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmNyRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWY3JG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gc291cmNlIHN1cHBsaWVkXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnTm8gc291cmNlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBpbnZhbGlkIGZpbGUgaXRlbXMsIHVzZWQgdG8gZmlsdGVyIGRyb3BwZWQgZGlyZWN0b3J5IGNvbnRlbnRzXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBpc0ZpbGUoc291cmNlKSAmJlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLmlnbm9yZWRGaWxlcy5pbmNsdWRlcyhzb3VyY2UubmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWlsIHNpbGVudGx5XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0ZXN0IGlmIHRoZXJlJ3Mgc3RpbGwgcm9vbSBpbiB0aGUgbGlzdCBvZiBmaWxlc1xuICAgICAgICAgICAgICAgIGlmICghaGFzUm9vbUZvckl0ZW0oc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG11bHRpcGxlIGFsbG93ZWQsIHdlIGNhbid0IHJlcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgaWYgb25seSBhIHNpbmdsZSBpdGVtIGlzIGFsbG93ZWQgYnV0IHdlJ3JlIG5vdCBhbGxvd2VkIHRvIHJlcGxhY2UgaXQgd2UgZXhpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLmFsbG93TXVsdGlwbGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICghc3RhdGUub3B0aW9ucy5hbGxvd011bHRpcGxlICYmICFzdGF0ZS5vcHRpb25zLmFsbG93UmVwbGFjZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBjcmVhdGVSZXNwb25zZSgnd2FybmluZycsIDAsICdNYXggZmlsZXMnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19NQVhfRklMRVMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmUoeyBlcnJvcjogZXJyb3IsIGZpbGU6IG51bGwgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIHJlcGxhY2UgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWQgb2YgZmlyc3QgaXRlbSB3ZSdyZSBhYm91dCB0byByZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVtID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGhhcyBiZWVuIHByb2Nlc3NlZCByZW1vdmUgaXQgZnJvbSB0aGUgc2VydmVyIGFzIHdlbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JjZVJldmVydCA9IHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXZlcnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlUmV2ZXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvcmNlUmV2ZXJ0KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGFkZCBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0FERF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZTogZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge30pOyAvLyBubyBuZWVkIHRvIGhhbmRsZSB0aGlzIGNhdGNoIHN0YXRlIGZvciBub3dcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlUmV2ZXJ0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZmlyc3QgaXRlbSBhcyBpdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoaXMgaXRlbVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBfaXRlbS5pZCB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBkaWQgdGhlIGZpbGUgb3JpZ2luYXRlXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9PT0gJ2xvY2FsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBGaWxlT3JpZ2luLkxPQ0FMXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbnMudHlwZSA9PT0gJ2xpbWJvJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBGaWxlT3JpZ2luLkxJTUJPXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEZpbGVPcmlnaW4uSU5QVVQ7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgYmxhbmsgaXRlbVxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gY3JlYXRlSXRlbShcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlcmUgZGlkIHRoaXMgZmlsZSBjb21lIGZyb21cbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGlucHV0IGZpbGUgbmV2ZXIgaGFzIGEgc2VydmVyIGZpbGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbiA9PT0gRmlsZU9yaWdpbi5JTlBVVCA/IG51bGwgOiBzb3VyY2UsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsZSBtb2NrIGRhdGEsIGlmIGRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5maWxlXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCBpbml0aWFsIG1ldGEgZGF0YVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMubWV0YWRhdGEgfHwge30pLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0TWV0YWRhdGEoa2V5LCBvcHRpb25zLm1ldGFkYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlZCB0aGUgaXRlbSwgbGV0IHBsdWdpbnMgYWRkIG1ldGhvZHNcbiAgICAgICAgICAgICAgICBhcHBseUZpbHRlcnMoJ0RJRF9DUkVBVEVfSVRFTScsIGl0ZW0sIHsgcXVlcnk6IHF1ZXJ5LCBkaXNwYXRjaDogZGlzcGF0Y2ggfSk7XG5cbiAgICAgICAgICAgICAgICAvLyB3aGVyZSB0byBpbnNlcnQgbmV3IGl0ZW1zXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1JbnNlcnRMb2NhdGlvbiA9IHF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT04nKTtcblxuICAgICAgICAgICAgICAgIC8vIGFkanVzdCBpbmRleCBpZiBpcyBub3QgYWxsb3dlZCB0byBwaWNrIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5vcHRpb25zLml0ZW1JbnNlcnRMb2NhdGlvbkZyZWVkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpdGVtSW5zZXJ0TG9jYXRpb24gPT09ICdiZWZvcmUnID8gLTEgOiBzdGF0ZS5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWRkIGl0ZW0gdG8gbGlzdFxuICAgICAgICAgICAgICAgIGluc2VydEl0ZW0oc3RhdGUuaXRlbXMsIGl0ZW0sIGluZGV4KTtcblxuICAgICAgICAgICAgICAgIC8vIHNvcnQgaXRlbXMgaW4gbGlzdFxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGl0ZW1JbnNlcnRMb2NhdGlvbikgJiYgc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRJdGVtcyhzdGF0ZSwgaXRlbUluc2VydExvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgYSBxdWljayByZWZlcmVuY2UgdG8gdGhlIGl0ZW0gaWRcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBpdGVtLmlkO1xuXG4gICAgICAgICAgICAgICAgLy8gb2JzZXJ2ZSBpdGVtIGV2ZW50c1xuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ2luaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9JTklUX0lURU0nLCB7IGlkOiBpZCB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ2xvYWQtaW5pdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1NUQVJUX0lURU1fTE9BRCcsIHsgaWQ6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbignbG9hZC1tZXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fTUVUQScsIHsgaWQ6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbignbG9hZC1wcm9ncmVzcycsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUycsIHsgaWQ6IGlkLCBwcm9ncmVzczogcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdsb2FkLXJlcXVlc3QtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFpblN0YXR1cyA9IGR5bmFtaWNMYWJlbChzdGF0ZS5vcHRpb25zLmxhYmVsRmlsZUxvYWRFcnJvcikoZXJyb3IpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGNsaWVudCBlcnJvciwgbm8gd2F5IHRvIHJlY292ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPj0gNDAwICYmIGVycm9yLmNvZGUgPCA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9JTlZBTElEJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IG1haW5TdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YjogZXJyb3IuY29kZSArICcgKCcgKyBlcnJvci5ib2R5ICsgJyknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0IHRoZSBmaWxlIHNvIGNhbiBiZSBkZWFsdCB3aXRoIHRocm91Z2ggQVBJXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3I6IGVycm9yLCBmaWxlOiBjcmVhdGVJdGVtQVBJKGl0ZW0pIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgcG9zc2libGUgc2VydmVyIGVycm9yLCBzbyBtaWdodCBiZSBwb3NzaWJsZSB0byByZXRyeVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IG1haW5TdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbignbG9hZC1maWxlLWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0lOVkFMSUQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmUoeyBlcnJvcjogZXJyb3Iuc3RhdHVzLCBmaWxlOiBjcmVhdGVJdGVtQVBJKGl0ZW0pIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbignbG9hZC1hYm9ydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpZCB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ2xvYWQtc2tpcCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLm9uKCdtZXRhZGF0YS11cGRhdGUnLCBmdW5jdGlvbihjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaWxlKGl0ZW0uZmlsZSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fTUVUQURBVEEnLCB7IGlkOiBpZCwgY2hhbmdlOiBjaGFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdDT01QTEVURV9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUFkZCA9IGZ1bmN0aW9uIGhhbmRsZUFkZChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHNob3VsZCBub3QgYWRkIHRoaXMgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IGludGVyZXN0ZWQgaW4gbWV0YWRhdGEgdXBkYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vbignbWV0YWRhdGEtdXBkYXRlJywgZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9NRVRBREFUQScsIHsgaWQ6IGlkLCBjaGFuZ2U6IGNoYW5nZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgcGx1Z2lucyBkZWNpZGUgaWYgdGhlIG91dHB1dCBkYXRhIHNob3VsZCBiZSBwcmVwYXJlZCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZWFucyB3ZSdsbCBkbyB0aGlzIGFuZCB3YWl0IGZvciBpZGxlIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdTSE9VTERfUFJFUEFSRV9PVVRQVVQnLCBmYWxzZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihzaG91bGRQcmVwYXJlT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGx1Z2lucyBkZXRlcm1pbmVkIHRoZSBvdXRwdXQgZGF0YSBzaG91bGQgYmUgcHJlcGFyZWQgKG9yIG5vdCksIGNhbiBiZSBhZGp1c3RlZCB3aXRoIGJlZm9yZVByZXBhcmVPdXRwdXQgaG9va1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZWZvcmVQcmVwYXJlRmlsZSA9IHF1ZXJ5KCdHRVRfQkVGT1JFX1BSRVBBUkVfRklMRScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVQcmVwYXJlRmlsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkUHJlcGFyZU91dHB1dCA9IGJlZm9yZVByZXBhcmVGaWxlKGl0ZW0sIHNob3VsZFByZXBhcmVPdXRwdXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIGxvYWRDb21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0NPTVBMRVRFX0xPQURfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4aXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUHJlcGFyZU91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciBpZGxlIHN0YXRlIGFuZCB0aGVuIHJ1biBQUkVQQVJFX09VVFBVVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSRVFVRVNUX1BSRVBBUkVfT1VUUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGlkLCBmaWxlOiBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gbG9hZGVkLCBhbGxvdyBwbHVnaW5zIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gcmVhZCBkYXRhIChxdWlja2x5KVxuICAgICAgICAgICAgICAgICAgICAvLyAtIGFkZCBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdESURfTE9BRF9JVEVNJywgaXRlbSwgeyBxdWVyeTogcXVlcnksIGRpc3BhdGNoOiBkaXNwYXRjaCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxQcm9taXNlKHF1ZXJ5KCdHRVRfQkVGT1JFX0FERF9GSUxFJyksIGNyZWF0ZUl0ZW1BUEkoaXRlbSkpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUFkZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgIWUuZXJyb3IgfHwgIWUuc3RhdHVzKSByZXR1cm4gaGFuZGxlQWRkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fSU5WQUxJRCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZS5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1zdGFydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1wcm9ncmVzcycsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUycsIHsgaWQ6IGlkLCBwcm9ncmVzczogcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVQcm9jZXNzaW5nRXJyb3IpKGVycm9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWI6IHN0YXRlLm9wdGlvbnMubGFiZWxUYXBUb1JldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLXJldmVydC1lcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IGR5bmFtaWNMYWJlbChzdGF0ZS5vcHRpb25zLmxhYmVsRmlsZVByb2Nlc3NpbmdSZXZlcnRFcnJvcikoZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtY29tcGxldGUnLCBmdW5jdGlvbihzZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlOiBzZXJ2ZXJGaWxlUmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0RFRklORV9WQUxVRScsIHsgaWQ6IGlkLCB2YWx1ZTogc2VydmVyRmlsZVJlZmVyZW5jZSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtYWJvcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkcnLCB7IGlkOiBpZCB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcmV2ZXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGlkIH0pO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0RFRklORV9WQUxVRScsIHsgaWQ6IGlkLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGxldCB2aWV3IGtub3cgdGhlIGl0ZW0gaGFzIGJlZW4gaW5zZXJ0ZWRcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0FERF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IGludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbGlzdFVwZGF0ZWQoZGlzcGF0Y2gsIHN0YXRlKTtcblxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGxvYWRpbmcgdGhlIHNvdXJjZVxuICAgICAgICAgICAgICAgIHZhciBfcmVmOCA9IHN0YXRlLm9wdGlvbnMuc2VydmVyIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBfcmVmOC51cmwsXG4gICAgICAgICAgICAgICAgICAgIGxvYWQgPSBfcmVmOC5sb2FkLFxuICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gX3JlZjgucmVzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2ggPSBfcmVmOC5mZXRjaDtcblxuICAgICAgICAgICAgICAgIGl0ZW0ubG9hZChcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbG9hZHMgdGhlIGZpbGUgYmFzZWQgb24gdGhlIHR5cGUgb2YgZmlsZSAoc3RyaW5nLCBiYXNlNjQsIGJsb2IsIGZpbGUpIGFuZCBsb2NhdGlvbiBvZiBmaWxlIChsb2NhbCwgcmVtb3RlLCBsaW1ibylcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRmlsZUxvYWRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbiA9PT0gRmlsZU9yaWdpbi5JTlBVVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gLy8gaW5wdXQsIGlmIGlzIHJlbW90ZSwgc2VlIGlmIHNob3VsZCB1c2UgY3VzdG9tIGZldGNoLCBlbHNlIHVzZSBkZWZhdWx0IGZldGNoQmxvYlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTdHJpbmcoc291cmNlKSAmJiBpc0V4dGVybmFsVVJMKHNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVGZXRjaEZ1bmN0aW9uKHVybCwgZmV0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZldGNoQmxvYiAvLyByZW1vdGUgdXJsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmV0Y2hCbG9iIC8vIHRyeSB0byBmZXRjaCB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8vIGxpbWJvIG9yIGxvY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVGZXRjaEZ1bmN0aW9uKHVybCwgcmVzdG9yZSkgLy8gbGltYm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZUZldGNoRnVuY3Rpb24odXJsLCBsb2FkKSAvLyBsb2NhbFxuICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSBmaWxlIGlzIGxvYWRlZCBzbyBpdCBjYW4gYmUgcGlwZWQgdGhyb3VnaCB0aGUgZmlsdGVyc1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihmaWxlLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgcHJvY2VzcyB0aGUgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignTE9BRF9GSUxFJywgZmlsZSwgeyBxdWVyeTogcXVlcnkgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihzdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgUkVRVUVTVF9QUkVQQVJFX09VVFBVVDogZnVuY3Rpb24gUkVRVUVTVF9QUkVQQVJFX09VVFBVVChfcmVmOSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3JlZjkuaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IF9yZWY5LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY5JGZhaWx1cmUgPSBfcmVmOS5mYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlID0gX3JlZjkkZmFpbHVyZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWY5JGZhaWx1cmU7XG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgcmVzcG9uc2UgaWYgaXRlbSBhcmNoaXZlZFxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnSXRlbSBub3QgZm91bmQnKSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgaGFuZGxlIGFyY2hpdmVkIGl0ZW1zLCBhbiBpdGVtIGNvdWxkIGhhdmUgYmVlbiBhcmNoaXZlZCAobG9hZCBhYm9ydGVkKSB3aGlsZSB3YWl0aW5nIHRvIGJlIHByZXBhcmVkXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uYXJjaGl2ZWQpIHJldHVybiBmYWlsdXJlKGVycik7XG5cbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBwbHVnaW5zIHRvIGFsdGVyIHRoZSBmaWxlIGRhdGFcbiAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdQUkVQQVJFX09VVFBVVCcsIGl0ZW0uZmlsZSwgeyBxdWVyeTogcXVlcnksIGl0ZW06IGl0ZW0gfSkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdDT01QTEVURV9QUkVQQVJFX09VVFBVVCcsIHJlc3VsdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBoYW5kbGUgYXJjaGl2ZWQgaXRlbXMsIGFuIGl0ZW0gY291bGQgaGF2ZSBiZWVuIGFyY2hpdmVkIChsb2FkIGFib3J0ZWQpIHdoaWxlIGJlaW5nIHByZXBhcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uYXJjaGl2ZWQpIHJldHVybiBmYWlsdXJlKGVycik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb25lIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIENPTVBMRVRFX0xPQURfSVRFTTogZnVuY3Rpb24gQ09NUExFVEVfTE9BRF9JVEVNKF9yZWYxMCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3JlZjEwLml0ZW0sXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfcmVmMTAuZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgc3VjY2VzcyA9IGRhdGEuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gZGF0YS5zb3VyY2U7XG5cbiAgICAgICAgICAgICAgICAvLyBzb3J0IGl0ZW1zIGluIGxpc3RcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUluc2VydExvY2F0aW9uID0gcXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTicpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGl0ZW1JbnNlcnRMb2NhdGlvbikgJiYgc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRJdGVtcyhzdGF0ZSwgaXRlbUluc2VydExvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsZXQgaW50ZXJmYWNlIGtub3cgdGhlIGl0ZW0gaGFzIGxvYWRlZFxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfTE9BRF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLklOUFVUID8gbnVsbCA6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGl0ZW0gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGxvYWRlZCBhbmQgYWRkZWQgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBpdGVtcyBzbyBjYW4gbm93IGJlIHNhZmVseSByZXR1cm5lZCBmb3IgdXNlXG4gICAgICAgICAgICAgICAgc3VjY2VzcyhjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsb2NhbCBzZXJ2ZXIgZmlsZSB3ZSBuZWVkIHRvIHNob3cgYSBkaWZmZXJlbnQgc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0xPQ0FMX0lURU0nLCB7IGlkOiBpdGVtLmlkIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgaXMgYSB0ZW1wIHNlcnZlciBmaWxlIHdlIHByZXZlbnQgYXN5bmMgdXBsb2FkIGNhbGwgaGVyZSAoYXMgdGhlIGZpbGUgaXMgYWxyZWFkeSBvbiB0aGUgc2VydmVyKVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MSU1CTykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfREVGSU5FX1ZBTFVFJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbS5zZXJ2ZXJJZCB8fCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZCB3ZSBhcmUgYWxsb3dlZCB0byB1cGxvYWQgdGhlIGZpbGUgaW1tZWRpYXRlbHksIGxldHMgZG8gaXRcbiAgICAgICAgICAgICAgICBpZiAocXVlcnkoJ0lTX0FTWU5DJykgJiYgc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgUkVUUllfSVRFTV9MT0FEOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIHRyeSBsb2FkaW5nIHRoZSBzb3VyY2Ugb25lIG1vcmUgdGltZVxuICAgICAgICAgICAgICAgIGl0ZW0ucmV0cnlMb2FkKCk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgUkVRVUVTVF9JVEVNX1BSRVBBUkU6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtLCBfc3VjY2VzcywgZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgICAgICAgICAnUkVRVUVTVF9QUkVQQVJFX09VVFBVVCcsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkOiBpdGVtLmlkLCBmaWxlOiBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdWNjZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBmaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IGZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZmFpbHVyZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gY2Fubm90IGJlIHF1ZXVlZCAob3IgaXMgYWxyZWFkeSBxdWV1ZWQpXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1DYW5CZVF1ZXVlZEZvclByb2Nlc3NpbmcgPVxuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0aW5nIGZvciBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuSURMRSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzaW5nIHdlbnQgd3JvbmcgZWFybGllclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0VSUk9SO1xuXG4gICAgICAgICAgICAgICAgLy8gbm90IHJlYWR5IHRvIGJlIHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIGlmICghaXRlbUNhbkJlUXVldWVkRm9yUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc05vdyA9IGZ1bmN0aW9uIHByb2Nlc3NOb3coKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZTogZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5oaWRkZW4gPyBwcm9jZXNzTm93KCkgOiBzZXRUaW1lb3V0KHByb2Nlc3NOb3csIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGRvbmUgcHJvY2Vzc2luZyBvciB0cmllZCB0byByZXZlcnQgYnV0IGRpZG4ndCB3b3JrLCB0cnkgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1JcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnJldmVydChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihwcm9jZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHt9KTsgLy8gZG9uJ3QgY29udGludWUgd2l0aCBwcm9jZXNzaW5nIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKHByb2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgcXVldWVkIGZvciBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUVVFVUVEKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpdGVtLnJlcXVlc3RQcm9jZXNzaW5nKCk7XG5cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaXRlbS5pZCB9KTtcblxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdQUk9DRVNTX0lURU0nLCB7IHF1ZXJ5OiBpdGVtLCBzdWNjZXNzOiBzdWNjZXNzLCBmYWlsdXJlOiBmYWlsdXJlIH0sIHRydWUpO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFBST0NFU1NfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4UGFyYWxsZWxVcGxvYWRzID0gcXVlcnkoJ0dFVF9NQVhfUEFSQUxMRUxfVVBMT0FEUycpO1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbEN1cnJlbnRVcGxvYWRzID0gcXVlcnkoJ0dFVF9JVEVNU19CWV9TVEFUVVMnLCBJdGVtU3RhdHVzLlBST0NFU1NJTkcpXG4gICAgICAgICAgICAgICAgICAgIC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyBxdWV1ZSBhbmQgd2FpdCB0aWxsIHF1ZXVlIGlzIGZyZWVkIHVwXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsQ3VycmVudFVwbG9hZHMgPT09IG1heFBhcmFsbGVsVXBsb2Fkcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBxdWV1ZSBmb3IgbGF0ZXIgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wcm9jZXNzaW5nUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiBmYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIGl0IVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgd2FzIG5vdCBxdWV1ZWQgb3IgaXMgYWxyZWFkeSBwcm9jZXNzaW5nIGV4aXQgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc05leHQgPSBmdW5jdGlvbiBwcm9jZXNzTmV4dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyBxdWV1ZXVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWV1ZUVudHJ5ID0gc3RhdGUucHJvY2Vzc2luZ1F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gaXRlbXMgbGVmdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXF1ZXVlRW50cnkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgaXRlbSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gcXVldWVFbnRyeS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBxdWV1ZUVudHJ5LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlID0gcXVldWVFbnRyeS5mYWlsdXJlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbVJlZmVyZW5jZSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXRlbSB3YXMgYXJjaGl2ZWQgd2hpbGUgaW4gcXVldWUsIGp1bXAgdG8gbmV4dFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1SZWZlcmVuY2UgfHwgaXRlbVJlZmVyZW5jZS5hcmNoaXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgcXVldWVkIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgICAgICAgICAnUFJPQ0VTU19JVEVNJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcXVlcnk6IGlkLCBzdWNjZXNzOiBzdWNjZXNzLCBmYWlsdXJlOiBmYWlsdXJlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbmUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBpdGVtLm9uT25jZSgncHJvY2Vzcy1jb21wbGV0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG9yaWdpbiBpcyBsb2NhbCwgYW5kIHdlJ3JlIGluc3RhbnQgdXBsb2FkaW5nLCB0cmlnZ2VyIHJlbW92ZSBvZiBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAvLyBhcyByZXZlcnQgd2lsbCByZW1vdmUgZmlsZSBmcm9tIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcnZlciA9IHN0YXRlLm9wdGlvbnMuc2VydmVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFudFVwbG9hZCA9IHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFudFVwbG9hZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oc2VydmVyLnJlbW92ZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3JpZ2luID0gRmlsZU9yaWdpbi5MSU1CTztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJlbW92ZShpdGVtLnNvdXJjZSwgbm9vcCwgbm9vcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBbGwgaXRlbXMgcHJvY2Vzc2VkPyBObyBlcnJvcnM/XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxJdGVtc1Byb2Nlc3NlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0lURU1TX0JZX1NUQVRVUycsIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSkubGVuZ3RoID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsSXRlbXNQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HX0FMTCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBlcnJvciBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGl0ZW0ub25PbmNlKCdwcm9jZXNzLWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSh7IGVycm9yOiBlcnJvciwgZmlsZTogY3JlYXRlSXRlbUFQSShpdGVtKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc05leHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGZpbGUgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gc3RhdGUub3B0aW9ucztcbiAgICAgICAgICAgICAgICBpdGVtLnByb2Nlc3MoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZpbGVQcm9jZXNzb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVQcm9jZXNzb3JGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZXJ2ZXIucHJvY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua1RyYW5zZmVySWQ6IGl0ZW0udHJhbnNmZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtTZXJ2ZXI6IG9wdGlvbnMuc2VydmVyLnBhdGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua1VwbG9hZHM6IG9wdGlvbnMuY2h1bmtVcGxvYWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua0ZvcmNlOiBvcHRpb25zLmNodW5rRm9yY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rU2l6ZTogb3B0aW9ucy5jaHVua1NpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rUmV0cnlEZWxheXM6IG9wdGlvbnMuY2h1bmtSZXRyeURlbGF5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb246IHF1ZXJ5KCdHRVRfQUxMT1dfTUlOSU1VTV9VUExPQURfRFVSQVRJT04nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgZmlsZSBpcyBhYm91dCB0byBiZSBwcm9jZXNzZWQgc28gaXQgY2FuIGJlIHBpcGVkIHRocm91Z2ggdGhlIHRyYW5zZm9ybSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGZpbGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyBwbHVnaW5zIHRvIGFsdGVyIHRoZSBmaWxlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1BSRVBBUkVfT1VUUFVUJywgZmlsZSwgeyBxdWVyeTogcXVlcnksIGl0ZW06IGl0ZW0gfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkOiBpdGVtLmlkLCBmaWxlOiBmaWxlIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBSRVRSWV9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbSB9KTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBSRVFVRVNUX1JFTU9WRV9JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbmFsUHJvbWlzZShxdWVyeSgnR0VUX0JFRk9SRV9SRU1PVkVfRklMRScpLCBjcmVhdGVJdGVtQVBJKGl0ZW0pKS50aGVuKGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRSZW1vdmVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFJFTEVBU0VfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLnJlbGVhc2UoKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBSRU1PVkVfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlRnJvbVZpZXcgPSBmdW5jdGlvbiByZW1vdmVGcm9tVmlldygpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGlkIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBpdGVtLmlkO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFyY2hpdmUgdGhlIGl0ZW0sIHRoaXMgZG9lcyBub3QgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbUJ5SWQoc3RhdGUuaXRlbXMsIGlkKS5hcmNoaXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGVsbCB0aGUgdmlldyB0aGUgaXRlbSBoYXMgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUkVNT1ZFX0lURU0nLCB7IGVycm9yOiBudWxsLCBpZDogaWQsIGl0ZW06IGl0ZW0gfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbm93IHRoZSBsaXN0IGhhcyBiZWVuIG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdGx5IHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGxvY2FsIGZpbGUgYW5kIHRoZSBgc2VydmVyLnJlbW92ZWAgZnVuY3Rpb24gaGFzIGJlZW4gY29uZmlndXJlZCxcbiAgICAgICAgICAgICAgICAvLyBzZW5kIHNvdXJjZSB0aGVyZSBzbyBkZXYgY2FuIHJlbW92ZSBmaWxlIGZyb20gc2VydmVyXG4gICAgICAgICAgICAgICAgdmFyIHNlcnZlciA9IHN0YXRlLm9wdGlvbnMuc2VydmVyO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyICYmXG4gICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oc2VydmVyLnJlbW92ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZW1vdmUgIT09IGZhbHNlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9SRU1PVkUnLCB7IGlkOiBpdGVtLmlkIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlci5yZW1vdmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVGcm9tVmlldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ2Vycm9yJywgMCwgc3RhdHVzLCBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVSZW1vdmVFcnJvcikoc3RhdHVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXMgcmVxdWVzdGluZyByZXZlcnQgYW5kIGNhbiByZXZlcnQgbmVlZCB0byBjYWxsIHJldmVydCBoYW5kbGVyIChub3QgY2FsbGluZyByZXF1ZXN0XyBiZWNhdXNlIHRoYXQgd291bGQgYWxzbyB0cmlnZ2VyIGJlZm9yZVJlbW92ZUhvb2spXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25zLnJldmVydCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3JpZ2luICE9PSBGaWxlT3JpZ2luLkxPQ0FMICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXJ2ZXJJZCAhPT0gbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNodW5rZWQgdXBsb2FkcyBhcmUgZW5hYmxlZCBhbmQgd2UncmUgdXBsb2FkaW5nIGluIGNodW5rcyBmb3IgdGhpcyBzcGVjaWZpYyBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiB0aGUgZmlsZSBpc24ndCBiaWcgZW5vdWdoIGZvciBjaHVua2VkIHVwbG9hZHMgYnV0IGNodW5rRm9yY2UgaXMgc2V0IHRoZW4gY2FsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV2ZXJ0IGJlZm9yZSByZW1vdmluZyBmcm9tIHRoZSB2aWV3Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUub3B0aW9ucy5jaHVua1VwbG9hZHMgJiYgaXRlbS5maWxlLnNpemUgPiBzdGF0ZS5vcHRpb25zLmNodW5rU2l6ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5vcHRpb25zLmNodW5rVXBsb2FkcyAmJiBzdGF0ZS5vcHRpb25zLmNodW5rRm9yY2UpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZPUkNFX1JFVkVSVCcpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIG5vdyBzYWZlbHkgcmVtb3ZlIGZyb20gdmlld1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVGcm9tVmlldygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBBQk9SVF9JVEVNX0xPQUQ6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hYm9ydExvYWQoKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBBQk9SVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gdGVzdCBpZiBpcyBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnNlcnZlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaXRlbS5pZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFib3J0XG4gICAgICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hvdWxkUmVtb3ZlID0gc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtLmlkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgUkVRVUVTVF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBpbnN0YW50IHVwbG9hZGluZywgcmV2ZXJ0IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFVkVSVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgaW5zdGFudCB1cGxvYWRpbmcgdGhlIGZpbGUgd2lsbCBhbHNvIGJlIHJlbW92ZWQgaWYgd2UgcmV2ZXJ0LFxuICAgICAgICAgICAgICAgIC8vIHNvIGlmIGEgYmVmb3JlIHJlbW92ZSBmaWxlIGhvb2sgaXMgZGVmaW5lZCB3ZSBuZWVkIHRvIHJ1biBpdCBub3dcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlUmV2ZXJ0ID0gZnVuY3Rpb24gaGFuZGxlUmV2ZXJ0KHNob3VsZFJldmVydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldmVydCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXJ5KCdHRVRfQkVGT1JFX1JFTU9WRV9GSUxFJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0UmVtb3ZlUmVzdWx0ID0gZm4oY3JlYXRlSXRlbUFQSShpdGVtKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RSZW1vdmVSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdFJlbW92ZVJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZXZlcnQocmVxdWVzdFJlbW92ZVJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UmVtb3ZlUmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFJlbW92ZVJlc3VsdC50aGVuKGhhbmRsZVJldmVydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFJFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCwgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hvdWxkUmVtb3ZlID0gc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkIHx8IGlzTW9ja0l0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFNFVF9PUFRJT05TOiBmdW5jdGlvbiBTRVRfT1BUSU9OUyhfcmVmMTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF9yZWYxMS5vcHRpb25zO1xuICAgICAgICAgICAgICAgIC8vIGdldCBhbGwga2V5cyBwYXNzZWRcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHByaW9yaXRpemVkIGtleWVkIHRvIGluY2x1ZGUgKHJlbW92ZSBvbmNlIG5vdCBpbiBvcHRpb25zIG9iamVjdClcbiAgICAgICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWRPcHRpb25LZXlzID0gUHJpb3JpdGl6ZWRPcHRpb25zLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbktleXMuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIG9yZGVyIHRoZSBrZXlzLCBwcmlvcml0aXplZCBmaXJzdCwgdGhlbiByZXN0XG4gICAgICAgICAgICAgICAgdmFyIG9yZGVyZWRPcHRpb25LZXlzID0gW10uY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICBfdG9Db25zdW1hYmxlQXJyYXkocHJpb3JpdGl6ZWRPcHRpb25LZXlzKSxcbiAgICAgICAgICAgICAgICAgICAgX3RvQ29uc3VtYWJsZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhcHJpb3JpdGl6ZWRPcHRpb25LZXlzLmluY2x1ZGVzKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIGRpc3BhdGNoIHNldCBldmVudCBmb3IgZWFjaCBvcHRpb25cbiAgICAgICAgICAgICAgICBvcmRlcmVkT3B0aW9uS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnU0VUXycgKyBmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uc1trZXldLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBQcmlvcml0aXplZE9wdGlvbnMgPSBbJ3NlcnZlciddO1xuXG4gICAgdmFyIGZvcm1hdEZpbGVuYW1lID0gZnVuY3Rpb24gZm9ybWF0RmlsZW5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUVsZW1lbnQkMSA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9O1xuXG4gICAgdmFyIHRleHQgPSBmdW5jdGlvbiB0ZXh0KG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgaWYgKCF0ZXh0Tm9kZSkge1xuICAgICAgICAgICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdGV4dE5vZGUubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICB0ZXh0Tm9kZS5ub2RlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcG9sYXJUb0NhcnRlc2lhbiA9IGZ1bmN0aW9uIHBvbGFyVG9DYXJ0ZXNpYW4oY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCBhbmdsZUluRGVncmVlcykge1xuICAgICAgICB2YXIgYW5nbGVJblJhZGlhbnMgPSAoKChhbmdsZUluRGVncmVlcyAlIDM2MCkgLSA5MCkgKiBNYXRoLlBJKSAvIDE4MC4wO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY2VudGVyWCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKSxcbiAgICAgICAgICAgIHk6IGNlbnRlclkgKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZUluUmFkaWFucyksXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBkZXNjcmliZUFyYyA9IGZ1bmN0aW9uIGRlc2NyaWJlQXJjKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFyY1N3ZWVwKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHBvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBlbmRBbmdsZSk7XG4gICAgICAgIHZhciBlbmQgPSBwb2xhclRvQ2FydGVzaWFuKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSk7XG4gICAgICAgIHJldHVybiBbJ00nLCBzdGFydC54LCBzdGFydC55LCAnQScsIHJhZGl1cywgcmFkaXVzLCAwLCBhcmNTd2VlcCwgMCwgZW5kLngsIGVuZC55XS5qb2luKCcgJyk7XG4gICAgfTtcblxuICAgIHZhciBwZXJjZW50YWdlQXJjID0gZnVuY3Rpb24gcGVyY2VudGFnZUFyYyh4LCB5LCByYWRpdXMsIGZyb20sIHRvKSB7XG4gICAgICAgIHZhciBhcmNTd2VlcCA9IDE7XG4gICAgICAgIGlmICh0byA+IGZyb20gJiYgdG8gLSBmcm9tIDw9IDAuNSkge1xuICAgICAgICAgICAgYXJjU3dlZXAgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tID4gdG8gJiYgZnJvbSAtIHRvID49IDAuNSkge1xuICAgICAgICAgICAgYXJjU3dlZXAgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjcmliZUFyYyhcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgcmFkaXVzLFxuICAgICAgICAgICAgTWF0aC5taW4oMC45OTk5LCBmcm9tKSAqIDM2MCxcbiAgICAgICAgICAgIE1hdGgubWluKDAuOTk5OSwgdG8pICogMzYwLFxuICAgICAgICAgICAgYXJjU3dlZXBcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICAvLyBzdGFydCBhdCAwXG4gICAgICAgIHByb3BzLnNwaW4gPSBmYWxzZTtcbiAgICAgICAgcHJvcHMucHJvZ3Jlc3MgPSAwO1xuICAgICAgICBwcm9wcy5vcGFjaXR5ID0gMDtcblxuICAgICAgICAvLyBzdmdcbiAgICAgICAgdmFyIHN2ZyA9IGNyZWF0ZUVsZW1lbnQoJ3N2ZycpO1xuICAgICAgICByb290LnJlZi5wYXRoID0gY3JlYXRlRWxlbWVudCgncGF0aCcsIHtcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICAgICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKHJvb3QucmVmLnBhdGgpO1xuXG4gICAgICAgIHJvb3QucmVmLnN2ZyA9IHN2ZztcblxuICAgICAgICByb290LmFwcGVuZENoaWxkKHN2Zyk7XG4gICAgfTtcblxuICAgIHZhciB3cml0ZSA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5vcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMuYWxpZ24pIHtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmFsaWduID0gcHJvcHMuYWxpZ247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgd2lkdGggb2Ygc3Ryb2tlXG4gICAgICAgIHZhciByaW5nU3Ryb2tlV2lkdGggPSBwYXJzZUludChhdHRyKHJvb3QucmVmLnBhdGgsICdzdHJva2Utd2lkdGgnKSwgMTApO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBzaXplIG9mIHJpbmdcbiAgICAgICAgdmFyIHNpemUgPSByb290LnJlY3QuZWxlbWVudC53aWR0aCAqIDAuNTtcblxuICAgICAgICAvLyByaW5nIHN0YXRlXG4gICAgICAgIHZhciByaW5nRnJvbSA9IDA7XG4gICAgICAgIHZhciByaW5nVG8gPSAwO1xuXG4gICAgICAgIC8vIG5vdyBpbiBidXN5IG1vZGVcbiAgICAgICAgaWYgKHByb3BzLnNwaW4pIHtcbiAgICAgICAgICAgIHJpbmdGcm9tID0gMDtcbiAgICAgICAgICAgIHJpbmdUbyA9IDAuNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJpbmdGcm9tID0gMDtcbiAgICAgICAgICAgIHJpbmdUbyA9IHByb3BzLnByb2dyZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGFyYyBwYXRoXG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IHBlcmNlbnRhZ2VBcmMoc2l6ZSwgc2l6ZSwgc2l6ZSAtIHJpbmdTdHJva2VXaWR0aCwgcmluZ0Zyb20sIHJpbmdUbyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHByb2dyZXNzIGJhclxuICAgICAgICBhdHRyKHJvb3QucmVmLnBhdGgsICdkJywgY29vcmRpbmF0ZXMpO1xuXG4gICAgICAgIC8vIGhpZGUgd2hpbGUgY29udGFpbnMgMCB2YWx1ZVxuICAgICAgICBhdHRyKHJvb3QucmVmLnBhdGgsICdzdHJva2Utb3BhY2l0eScsIHByb3BzLnNwaW4gfHwgcHJvcHMucHJvZ3Jlc3MgPiAwID8gMSA6IDApO1xuICAgIH07XG5cbiAgICB2YXIgcHJvZ3Jlc3NJbmRpY2F0b3IgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgdGFnOiAnZGl2JyxcbiAgICAgICAgbmFtZTogJ3Byb2dyZXNzLWluZGljYXRvcicsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgICAgICB3cml0ZTogd3JpdGUsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgYXBpczogWydwcm9ncmVzcycsICdzcGluJywgJ2FsaWduJ10sXG4gICAgICAgICAgICBzdHlsZXM6IFsnb3BhY2l0eSddLFxuICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDUwMCB9LFxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICBzdGlmZm5lc3M6IDAuOTUsXG4gICAgICAgICAgICAgICAgICAgIGRhbXBpbmc6IDAuNjUsXG4gICAgICAgICAgICAgICAgICAgIG1hc3M6IDEwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIGNyZWF0ZSQxID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIHJvb3QuZWxlbWVudC5pbm5lckhUTUwgPSAocHJvcHMuaWNvbiB8fCAnJykgKyAoJzxzcGFuPicgKyBwcm9wcy5sYWJlbCArICc8L3NwYW4+Jyk7XG5cbiAgICAgICAgcHJvcHMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgd3JpdGUkMSA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG4gICAgICAgIHZhciBpc0Rpc2FibGVkID0gcHJvcHMuaXNEaXNhYmxlZDtcbiAgICAgICAgdmFyIHNob3VsZERpc2FibGUgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKSB8fCBwcm9wcy5vcGFjaXR5ID09PSAwO1xuXG4gICAgICAgIGlmIChzaG91bGREaXNhYmxlICYmICFpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBwcm9wcy5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGF0dHIocm9vdC5lbGVtZW50LCAnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgfSBlbHNlIGlmICghc2hvdWxkRGlzYWJsZSAmJiBpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBwcm9wcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBmaWxlQWN0aW9uQnV0dG9uID0gY3JlYXRlVmlldyh7XG4gICAgICAgIHRhZzogJ2J1dHRvbicsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdidXR0b24nLFxuICAgICAgICB9LFxuXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgICAgIG5hbWU6ICdmaWxlLWFjdGlvbi1idXR0b24nLFxuICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICAgIGFwaXM6IFsnbGFiZWwnXSxcbiAgICAgICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAnc2NhbGVYJywgJ3NjYWxlWScsICdvcGFjaXR5J10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgc2NhbGVYOiAnc3ByaW5nJyxcbiAgICAgICAgICAgICAgICBzY2FsZVk6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9LFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbGlzdGVuZXJzOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJDEsXG4gICAgICAgIHdyaXRlOiB3cml0ZSQxLFxuICAgIH0pO1xuXG4gICAgdmFyIHRvTmF0dXJhbEZpbGVTaXplID0gZnVuY3Rpb24gdG9OYXR1cmFsRmlsZVNpemUoYnl0ZXMpIHtcbiAgICAgICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPVxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLic7XG4gICAgICAgIHZhciBiYXNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMDAwO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICAgIHZhciBfb3B0aW9ucyRsYWJlbEJ5dGVzID0gb3B0aW9ucy5sYWJlbEJ5dGVzLFxuICAgICAgICAgICAgbGFiZWxCeXRlcyA9IF9vcHRpb25zJGxhYmVsQnl0ZXMgPT09IHZvaWQgMCA/ICdieXRlcycgOiBfb3B0aW9ucyRsYWJlbEJ5dGVzLFxuICAgICAgICAgICAgX29wdGlvbnMkbGFiZWxLaWxvYnl0ID0gb3B0aW9ucy5sYWJlbEtpbG9ieXRlcyxcbiAgICAgICAgICAgIGxhYmVsS2lsb2J5dGVzID0gX29wdGlvbnMkbGFiZWxLaWxvYnl0ID09PSB2b2lkIDAgPyAnS0InIDogX29wdGlvbnMkbGFiZWxLaWxvYnl0LFxuICAgICAgICAgICAgX29wdGlvbnMkbGFiZWxNZWdhYnl0ID0gb3B0aW9ucy5sYWJlbE1lZ2FieXRlcyxcbiAgICAgICAgICAgIGxhYmVsTWVnYWJ5dGVzID0gX29wdGlvbnMkbGFiZWxNZWdhYnl0ID09PSB2b2lkIDAgPyAnTUInIDogX29wdGlvbnMkbGFiZWxNZWdhYnl0LFxuICAgICAgICAgICAgX29wdGlvbnMkbGFiZWxHaWdhYnl0ID0gb3B0aW9ucy5sYWJlbEdpZ2FieXRlcyxcbiAgICAgICAgICAgIGxhYmVsR2lnYWJ5dGVzID0gX29wdGlvbnMkbGFiZWxHaWdhYnl0ID09PSB2b2lkIDAgPyAnR0InIDogX29wdGlvbnMkbGFiZWxHaWdhYnl0O1xuXG4gICAgICAgIC8vIG5vIG5lZ2F0aXZlIGJ5dGUgc2l6ZXNcbiAgICAgICAgYnl0ZXMgPSBNYXRoLnJvdW5kKE1hdGguYWJzKGJ5dGVzKSk7XG5cbiAgICAgICAgdmFyIEtCID0gYmFzZTtcbiAgICAgICAgdmFyIE1CID0gYmFzZSAqIGJhc2U7XG4gICAgICAgIHZhciBHQiA9IGJhc2UgKiBiYXNlICogYmFzZTtcblxuICAgICAgICAvLyBqdXN0IGJ5dGVzXG4gICAgICAgIGlmIChieXRlcyA8IEtCKSB7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXMgKyAnICcgKyBsYWJlbEJ5dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8ga2lsb2J5dGVzXG4gICAgICAgIGlmIChieXRlcyA8IE1CKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihieXRlcyAvIEtCKSArICcgJyArIGxhYmVsS2lsb2J5dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWVnYWJ5dGVzXG4gICAgICAgIGlmIChieXRlcyA8IEdCKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlRGVjaW1hbHNXaGVuWmVybyhieXRlcyAvIE1CLCAxLCBkZWNpbWFsU2VwYXJhdG9yKSArICcgJyArIGxhYmVsTWVnYWJ5dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2lnYWJ5dGVzXG4gICAgICAgIHJldHVybiByZW1vdmVEZWNpbWFsc1doZW5aZXJvKGJ5dGVzIC8gR0IsIDIsIGRlY2ltYWxTZXBhcmF0b3IpICsgJyAnICsgbGFiZWxHaWdhYnl0ZXM7XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVEZWNpbWFsc1doZW5aZXJvID0gZnVuY3Rpb24gcmVtb3ZlRGVjaW1hbHNXaGVuWmVybyh2YWx1ZSwgZGVjaW1hbENvdW50LCBzZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICAudG9GaXhlZChkZWNpbWFsQ291bnQpXG4gICAgICAgICAgICAuc3BsaXQoJy4nKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQgIT09ICcwJztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlJDIgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgLy8gZmlsZW5hbWVcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgICAgIGZpbGVOYW1lLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1pbmZvLW1haW4nO1xuICAgICAgICAvLyBoaWRlIGZvciBzY3JlZW5yZWFkZXJzXG4gICAgICAgIC8vIHRoZSBmaWxlIGlzIGNvbnRhaW5lZCBpbiBhIGZpZWxkc2V0IHdpdGggbGVnZW5kIHRoYXQgY29udGFpbnMgdGhlIGZpbGVuYW1lXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gcmVhZCBpdCB0d2ljZVxuICAgICAgICBhdHRyKGZpbGVOYW1lLCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKGZpbGVOYW1lKTtcbiAgICAgICAgcm9vdC5yZWYuZmlsZU5hbWUgPSBmaWxlTmFtZTtcblxuICAgICAgICAvLyBmaWxlc2l6ZVxuICAgICAgICB2YXIgZmlsZVNpemUgPSBjcmVhdGVFbGVtZW50JDEoJ3NwYW4nKTtcbiAgICAgICAgZmlsZVNpemUuY2xhc3NOYW1lID0gJ2ZpbGVwb25kLS1maWxlLWluZm8tc3ViJztcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChmaWxlU2l6ZSk7XG4gICAgICAgIHJvb3QucmVmLmZpbGVTaXplID0gZmlsZVNpemU7XG5cbiAgICAgICAgLy8gc2V0IGluaXRpYWwgdmFsdWVzXG4gICAgICAgIHRleHQoZmlsZVNpemUsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1dBSVRJTkdfRk9SX1NJWkUnKSk7XG4gICAgICAgIHRleHQoZmlsZU5hbWUsIGZvcm1hdEZpbGVuYW1lKHJvb3QucXVlcnkoJ0dFVF9JVEVNX05BTUUnLCBwcm9wcy5pZCkpKTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUZpbGUgPSBmdW5jdGlvbiB1cGRhdGVGaWxlKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG4gICAgICAgIHRleHQoXG4gICAgICAgICAgICByb290LnJlZi5maWxlU2l6ZSxcbiAgICAgICAgICAgIHRvTmF0dXJhbEZpbGVTaXplKFxuICAgICAgICAgICAgICAgIHJvb3QucXVlcnkoJ0dFVF9JVEVNX1NJWkUnLCBwcm9wcy5pZCksXG4gICAgICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgICAgIHJvb3QucXVlcnkoJ0dFVF9GSUxFX1NJWkVfQkFTRScpLFxuICAgICAgICAgICAgICAgIHJvb3QucXVlcnkoJ0dFVF9GSUxFX1NJWkVfTEFCRUxTJywgcm9vdC5xdWVyeSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICB0ZXh0KHJvb3QucmVmLmZpbGVOYW1lLCBmb3JtYXRGaWxlbmFtZShyb290LnF1ZXJ5KCdHRVRfSVRFTV9OQU1FJywgcHJvcHMuaWQpKSk7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVGaWxlU2l6ZU9uRXJyb3IgPSBmdW5jdGlvbiB1cGRhdGVGaWxlU2l6ZU9uRXJyb3IoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMy5wcm9wcztcbiAgICAgICAgLy8gaWYgc2l6ZSBpcyBhdmFpbGFibGUgZG9uJ3QgZmFsbGJhY2sgdG8gdW5rbm93biBzaXplIG1lc3NhZ2VcbiAgICAgICAgaWYgKGlzSW50KHJvb3QucXVlcnkoJ0dFVF9JVEVNX1NJWkUnLCBwcm9wcy5pZCkpKSB7XG4gICAgICAgICAgICB1cGRhdGVGaWxlKHsgcm9vdDogcm9vdCwgcHJvcHM6IHByb3BzIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dChyb290LnJlZi5maWxlU2l6ZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfU0laRV9OT1RfQVZBSUxBQkxFJykpO1xuICAgIH07XG5cbiAgICB2YXIgZmlsZUluZm8gPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgbmFtZTogJ2ZpbGUtaW5mbycsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICAgICAgICBESURfTE9BRF9JVEVNOiB1cGRhdGVGaWxlLFxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNX01FVEE6IHVwZGF0ZUZpbGUsXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiB1cGRhdGVGaWxlU2l6ZU9uRXJyb3IsXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiB1cGRhdGVGaWxlU2l6ZU9uRXJyb3IsXG4gICAgICAgIH0pLFxuXG4gICAgICAgIGRpZENyZWF0ZVZpZXc6IGZ1bmN0aW9uIGRpZENyZWF0ZVZpZXcocm9vdCkge1xuICAgICAgICAgICAgYXBwbHlGaWx0ZXJzKCdDUkVBVEVfVklFVycsIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgdmlldzogcm9vdCB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJDIsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWSddLFxuICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHZhciB0b1BlcmNlbnRhZ2UgPSBmdW5jdGlvbiB0b1BlcmNlbnRhZ2UodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlJDMgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcblxuICAgICAgICAvLyBtYWluIHN0YXR1c1xuICAgICAgICB2YXIgbWFpbiA9IGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicpO1xuICAgICAgICBtYWluLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1zdGF0dXMtbWFpbic7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQobWFpbik7XG4gICAgICAgIHJvb3QucmVmLm1haW4gPSBtYWluO1xuXG4gICAgICAgIC8vIHN1YiBzdGF0dXNcbiAgICAgICAgdmFyIHN1YiA9IGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicpO1xuICAgICAgICBzdWIuY2xhc3NOYW1lID0gJ2ZpbGVwb25kLS1maWxlLXN0YXR1cy1zdWInO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKHN1Yik7XG4gICAgICAgIHJvb3QucmVmLnN1YiA9IHN1YjtcblxuICAgICAgICBkaWRTZXRJdGVtTG9hZFByb2dyZXNzKHsgcm9vdDogcm9vdCwgYWN0aW9uOiB7IHByb2dyZXNzOiBudWxsIH0gfSk7XG4gICAgfTtcblxuICAgIHZhciBkaWRTZXRJdGVtTG9hZFByb2dyZXNzID0gZnVuY3Rpb24gZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyhfcmVmMikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgICAgIHZhciB0aXRsZSA9XG4gICAgICAgICAgICBhY3Rpb24ucHJvZ3Jlc3MgPT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0xPQURJTkcnKVxuICAgICAgICAgICAgICAgIDogcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfTE9BRElORycpICsgJyAnICsgdG9QZXJjZW50YWdlKGFjdGlvbi5wcm9ncmVzcykgKyAnJSc7XG5cbiAgICAgICAgdGV4dChyb290LnJlZi5tYWluLCB0aXRsZSk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX0NBTkNFTCcpKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZFNldEl0ZW1Qcm9jZXNzUHJvZ3Jlc3MgPSBmdW5jdGlvbiBkaWRTZXRJdGVtUHJvY2Vzc1Byb2dyZXNzKF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICAgICAgdmFyIHRpdGxlID1cbiAgICAgICAgICAgIGFjdGlvbi5wcm9ncmVzcyA9PT0gbnVsbFxuICAgICAgICAgICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lORycpXG4gICAgICAgICAgICAgICAgOiByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJykgK1xuICAgICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvUGVyY2VudGFnZShhY3Rpb24ucHJvZ3Jlc3MpICtcbiAgICAgICAgICAgICAgICAgICclJztcblxuICAgICAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHRpdGxlKTtcbiAgICAgICAgdGV4dChyb290LnJlZi5zdWIsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9UQVBfVE9fQ0FOQ0VMJykpO1xuICAgIH07XG5cbiAgICB2YXIgZGlkUmVxdWVzdEl0ZW1Qcm9jZXNzaW5nID0gZnVuY3Rpb24gZGlkUmVxdWVzdEl0ZW1Qcm9jZXNzaW5nKF9yZWY0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdDtcbiAgICAgICAgdGV4dChyb290LnJlZi5tYWluLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJykpO1xuICAgICAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG4gICAgfTtcblxuICAgIHZhciBkaWRBYm9ydEl0ZW1Qcm9jZXNzaW5nID0gZnVuY3Rpb24gZGlkQWJvcnRJdGVtUHJvY2Vzc2luZyhfcmVmNSkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3Q7XG4gICAgICAgIHRleHQocm9vdC5yZWYubWFpbiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lOR19BQk9SVEVEJykpO1xuICAgICAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19SRVRSWScpKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZENvbXBsZXRlSXRlbVByb2Nlc3NpbmcgPSBmdW5jdGlvbiBkaWRDb21wbGV0ZUl0ZW1Qcm9jZXNzaW5nKF9yZWY2KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdDtcbiAgICAgICAgdGV4dChyb290LnJlZi5tYWluLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0NPTVBMRVRFJykpO1xuICAgICAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19VTkRPJykpO1xuICAgIH07XG5cbiAgICB2YXIgY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihfcmVmNykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3Q7XG4gICAgICAgIHRleHQocm9vdC5yZWYubWFpbiwgJycpO1xuICAgICAgICB0ZXh0KHJvb3QucmVmLnN1YiwgJycpO1xuICAgIH07XG5cbiAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihfcmVmOCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY4LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmOC5hY3Rpb247XG4gICAgICAgIHRleHQocm9vdC5yZWYubWFpbiwgYWN0aW9uLnN0YXR1cy5tYWluKTtcbiAgICAgICAgdGV4dChyb290LnJlZi5zdWIsIGFjdGlvbi5zdGF0dXMuc3ViKTtcbiAgICB9O1xuXG4gICAgdmFyIGZpbGVTdGF0dXMgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgbmFtZTogJ2ZpbGUtc3RhdHVzJyxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgICAgIERJRF9MT0FEX0lURU06IGNsZWFyLFxuICAgICAgICAgICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGNsZWFyLFxuICAgICAgICAgICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBkaWRSZXF1ZXN0SXRlbVByb2Nlc3NpbmcsXG4gICAgICAgICAgICBESURfQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiBkaWRBYm9ydEl0ZW1Qcm9jZXNzaW5nLFxuICAgICAgICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogZGlkQ29tcGxldGVJdGVtUHJvY2Vzc2luZyxcbiAgICAgICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBkaWRTZXRJdGVtUHJvY2Vzc1Byb2dyZXNzLFxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6IGRpZFNldEl0ZW1Mb2FkUHJvZ3Jlc3MsXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiBlcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IGVycm9yLFxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogZXJyb3IsXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjogZXJyb3IsXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IGVycm9yLFxuICAgICAgICB9KSxcblxuICAgICAgICBkaWRDcmVhdGVWaWV3OiBmdW5jdGlvbiBkaWRDcmVhdGVWaWV3KHJvb3QpIHtcbiAgICAgICAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCBPYmplY3QuYXNzaWduKHt9LCByb290LCB7IHZpZXc6IHJvb3QgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGU6IGNyZWF0ZSQzLFxuICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAnb3BhY2l0eSddLFxuICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9LFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJ1dHRvbiBkZWZpbml0aW9ucyBmb3IgdGhlIGZpbGUgdmlld1xuICAgICAqL1xuXG4gICAgdmFyIEJ1dHRvbnMgPSB7XG4gICAgICAgIEFib3J0SXRlbUxvYWQ6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX0xPQUQnLFxuICAgICAgICAgICAgYWN0aW9uOiAnQUJPUlRfSVRFTV9MT0FEJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tYWJvcnQtaXRlbS1sb2FkJyxcbiAgICAgICAgICAgIGFsaWduOiAnTE9BRF9JTkRJQ0FUT1JfUE9TSVRJT04nLCAvLyByaWdodFxuICAgICAgICB9LFxuICAgICAgICBSZXRyeUl0ZW1Mb2FkOiB7XG4gICAgICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVUUllfSVRFTV9MT0FEJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ1JFVFJZX0lURU1fTE9BRCcsXG4gICAgICAgICAgICBpY29uOiAnR0VUX0lDT05fUkVUUlknLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXRyeS1pdGVtLWxvYWQnLFxuICAgICAgICAgICAgYWxpZ246ICdCVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJywgLy8gcmlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgUmVtb3ZlSXRlbToge1xuICAgICAgICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1JFTU9WRV9JVEVNJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ1JFUVVFU1RfUkVNT1ZFX0lURU0nLFxuICAgICAgICAgICAgaWNvbjogJ0dFVF9JQ09OX1JFTU9WRScsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJlbW92ZS1pdGVtJyxcbiAgICAgICAgICAgIGFsaWduOiAnQlVUVE9OX1JFTU9WRV9JVEVNX1BPU0lUSU9OJywgLy8gbGVmdFxuICAgICAgICB9LFxuICAgICAgICBQcm9jZXNzSXRlbToge1xuICAgICAgICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1BST0NFU1NfSVRFTScsXG4gICAgICAgICAgICBhY3Rpb246ICdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICAgICAgICBpY29uOiAnR0VUX0lDT05fUFJPQ0VTUycsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXByb2Nlc3MtaXRlbScsXG4gICAgICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgICAgICB9LFxuICAgICAgICBBYm9ydEl0ZW1Qcm9jZXNzaW5nOiB7XG4gICAgICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ0FCT1JUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLWFib3J0LWl0ZW0tcHJvY2Vzc2luZycsXG4gICAgICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgICAgICB9LFxuICAgICAgICBSZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7XG4gICAgICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVUUllfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ1JFVFJZX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICAgICAgICBpY29uOiAnR0VUX0lDT05fUkVUUlknLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXRyeS1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgICAgICAgYWxpZ246ICdCVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJywgLy8gcmlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9VTkRPX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICAgICAgICBhY3Rpb246ICdSRVFVRVNUX1JFVkVSVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgaWNvbjogJ0dFVF9JQ09OX1VORE8nLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXZlcnQtaXRlbS1wcm9jZXNzaW5nJyxcbiAgICAgICAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIC8vIG1ha2UgYSBsaXN0IG9mIGJ1dHRvbnMsIHdlIGNhbiB0aGVuIHJlbW92ZSBidXR0b25zIGZyb20gdGhpcyBsaXN0IGlmIHRoZXkncmUgZGlzYWJsZWRcbiAgICB2YXIgQnV0dG9uS2V5cyA9IFtdO1xuICAgIGZvcmluKEJ1dHRvbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBCdXR0b25LZXlzLnB1c2goa2V5KTtcbiAgICB9KTtcblxuICAgIHZhciBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0KHJvb3QpIHtcbiAgICAgICAgaWYgKGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50KHJvb3QpID09PSAncmlnaHQnKSByZXR1cm4gMDtcbiAgICAgICAgdmFyIGJ1dHRvblJlY3QgPSByb290LnJlZi5idXR0b25SZW1vdmVJdGVtLnJlY3QuZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIGJ1dHRvblJlY3QuaGlkZGVuID8gbnVsbCA6IGJ1dHRvblJlY3Qud2lkdGggKyBidXR0b25SZWN0LmxlZnQ7XG4gICAgfTtcblxuICAgIHZhciBjYWxjdWxhdGVCdXR0b25XaWR0aCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJ1dHRvbldpZHRoKHJvb3QpIHtcbiAgICAgICAgdmFyIGJ1dHRvblJlY3QgPSByb290LnJlZi5idXR0b25BYm9ydEl0ZW1Mb2FkLnJlY3QuZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIGJ1dHRvblJlY3Qud2lkdGg7XG4gICAgfTtcblxuICAgIC8vIEZvcmNlIG9uIGZ1bGwgcGl4ZWxzIHNvIHRleHQgc3RheXMgY3JpcHNcbiAgICB2YXIgY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0KHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iocm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQuaGVpZ2h0IC8gNCk7XG4gICAgfTtcbiAgICB2YXIgY2FsY3VsYXRlRmlsZUhvcml6b250YWxDZW50ZXJPZmZzZXQgPSBmdW5jdGlvbiBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldChyb290KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHJvb3QucmVmLmJ1dHRvblJlbW92ZUl0ZW0ucmVjdC5lbGVtZW50LmxlZnQgLyAyKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldExvYWRJbmRpY2F0b3JBbGlnbm1lbnQgPSBmdW5jdGlvbiBnZXRMb2FkSW5kaWNhdG9yQWxpZ25tZW50KHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9MT0FEX0lORElDQVRPUl9QT1NJVElPTicpO1xuICAgIH07XG4gICAgdmFyIGdldFByb2Nlc3NJbmRpY2F0b3JBbGlnbm1lbnQgPSBmdW5jdGlvbiBnZXRQcm9jZXNzSW5kaWNhdG9yQWxpZ25tZW50KHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9QUk9HUkVTU19JTkRJQ0FUT1JfUE9TSVRJT04nKTtcbiAgICB9O1xuICAgIHZhciBnZXRSZW1vdmVJbmRpY2F0b3JBbGlnbWVudCA9IGZ1bmN0aW9uIGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50KHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9CVVRUT05fUkVNT1ZFX0lURU1fUE9TSVRJT04nKTtcbiAgICB9O1xuXG4gICAgdmFyIERlZmF1bHRTdHlsZSA9IHtcbiAgICAgICAgYnV0dG9uQWJvcnRJdGVtTG9hZDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgIGJ1dHRvblJldHJ5SXRlbUxvYWQ6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgYnV0dG9uUHJvY2Vzc0l0ZW06IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBidXR0b25BYm9ydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgYnV0dG9uUmV0cnlJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgIGJ1dHRvblJldmVydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgbG9hZFByb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDAsIGFsaWduOiBnZXRMb2FkSW5kaWNhdG9yQWxpZ25tZW50IH0sXG4gICAgICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAwLCBhbGlnbjogZ2V0UHJvY2Vzc0luZGljYXRvckFsaWdubWVudCB9LFxuICAgICAgICBwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3I6IHsgb3BhY2l0eTogMCwgc2NhbGVYOiAwLjc1LCBzY2FsZVk6IDAuNzUgfSxcbiAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiAwLCB0cmFuc2xhdGVZOiAwLCBvcGFjaXR5OiAwIH0sXG4gICAgICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiAwLCB0cmFuc2xhdGVZOiAwLCBvcGFjaXR5OiAwIH0sXG4gICAgfTtcblxuICAgIHZhciBJZGxlU3R5bGUgPSB7XG4gICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBidXR0b25Qcm9jZXNzSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgfTtcblxuICAgIHZhciBQcm9jZXNzaW5nU3R5bGUgPSB7XG4gICAgICAgIGJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBwcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgIH07XG5cbiAgICB2YXIgU3R5bGVNYXAgPSB7XG4gICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IHtcbiAgICAgICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0LCBvcGFjaXR5OiAxIH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgRElEX1NUQVJUX0lURU1fTE9BRDoge1xuICAgICAgICAgICAgYnV0dG9uQWJvcnRJdGVtTG9hZDogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBsb2FkUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiB7XG4gICAgICAgICAgICBidXR0b25SZXRyeUl0ZW1Mb2FkOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfU1RBUlRfSVRFTV9SRU1PVkU6IHtcbiAgICAgICAgICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxLCBhbGlnbjogZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQgfSxcbiAgICAgICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SOiB7XG4gICAgICAgICAgICBwcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMCwgYWxpZ246IGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50IH0sXG4gICAgICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxLCB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9MT0FEX0lURU06IElkbGVTdHlsZSxcbiAgICAgICAgRElEX0xPQURfTE9DQUxfSVRFTToge1xuICAgICAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgICAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgICAgIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogUHJvY2Vzc2luZ1N0eWxlLFxuICAgICAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogUHJvY2Vzc2luZ1N0eWxlLFxuICAgICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiB7XG4gICAgICAgICAgICBidXR0b25SZXZlcnRJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBpbmZvOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjoge1xuICAgICAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBidXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6IHtcbiAgICAgICAgICAgIGJ1dHRvblJldmVydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBpbmZvOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiB7XG4gICAgICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IElkbGVTdHlsZSxcbiAgICB9O1xuXG4gICAgLy8gY29tcGxldGUgaW5kaWNhdG9yIHZpZXdcbiAgICB2YXIgcHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yVmlldyA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5pbm5lckhUTUwgPSByb290LnF1ZXJ5KCdHRVRfSUNPTl9ET05FJyk7XG4gICAgICAgIH0sXG4gICAgICAgIG5hbWU6ICdwcm9jZXNzaW5nLWNvbXBsZXRlLWluZGljYXRvcicsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eSddLFxuICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgIHNjYWxlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgc2NhbGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAyNTAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlJDQgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgLy8gY29weSBCdXR0b25zIG9iamVjdFxuICAgICAgICB2YXIgTG9jYWxCdXR0b25zID0gT2JqZWN0LmtleXMoQnV0dG9ucykucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cnIpIHtcbiAgICAgICAgICAgIHByZXZbY3Vycl0gPSBPYmplY3QuYXNzaWduKHt9LCBCdXR0b25zW2N1cnJdKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHZhciBpZCA9IHByb3BzLmlkO1xuXG4gICAgICAgIC8vIGFsbG93IHJldmVydGluZyB1cGxvYWRcbiAgICAgICAgdmFyIGFsbG93UmV2ZXJ0ID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFVkVSVCcpO1xuXG4gICAgICAgIC8vIGFsbG93IHJlbW92ZSBmaWxlXG4gICAgICAgIHZhciBhbGxvd1JlbW92ZSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19SRU1PVkUnKTtcblxuICAgICAgICAvLyBhbGxvdyBwcm9jZXNzaW5nIHVwbG9hZFxuICAgICAgICB2YXIgYWxsb3dQcm9jZXNzID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1BST0NFU1MnKTtcblxuICAgICAgICAvLyBpcyBpbnN0YW50IHVwbG9hZGluZywgbmVlZCB0aGlzIHRvIGRldGVybWluZSB0aGUgaWNvbiBvZiB0aGUgdW5kbyBidXR0b25cbiAgICAgICAgdmFyIGluc3RhbnRVcGxvYWQgPSByb290LnF1ZXJ5KCdHRVRfSU5TVEFOVF9VUExPQUQnKTtcblxuICAgICAgICAvLyBpcyBhc3luYyBzZXQgdXBcbiAgICAgICAgdmFyIGlzQXN5bmMgPSByb290LnF1ZXJ5KCdJU19BU1lOQycpO1xuXG4gICAgICAgIC8vIHNob3VsZCBhbGlnbiByZW1vdmUgaXRlbSBidXR0b25zXG4gICAgICAgIHZhciBhbGlnblJlbW92ZUl0ZW1CdXR0b24gPSByb290LnF1ZXJ5KCdHRVRfU1RZTEVfQlVUVE9OX1JFTU9WRV9JVEVNX0FMSUdOJyk7XG5cbiAgICAgICAgLy8gZW5hYmxlZCBidXR0b25zIGFycmF5XG4gICAgICAgIHZhciBidXR0b25GaWx0ZXI7XG4gICAgICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dQcm9jZXNzICYmICFhbGxvd1JldmVydCkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgcmVtb3ZlIHJldmVydCBidXR0b25cbiAgICAgICAgICAgICAgICBidXR0b25GaWx0ZXIgPSBmdW5jdGlvbiBidXR0b25GaWx0ZXIoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhL1JldmVydEl0ZW1Qcm9jZXNzaW5nLy50ZXN0KGtleSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWFsbG93UHJvY2VzcyAmJiBhbGxvd1JldmVydCkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgcmVtb3ZlIHByb2Nlc3MgYnV0dG9uXG4gICAgICAgICAgICAgICAgYnV0dG9uRmlsdGVyID0gZnVuY3Rpb24gYnV0dG9uRmlsdGVyKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIS9Qcm9jZXNzSXRlbXxSZXRyeUl0ZW1Qcm9jZXNzaW5nfEFib3J0SXRlbVByb2Nlc3NpbmcvLnRlc3Qoa2V5KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICghYWxsb3dQcm9jZXNzICYmICFhbGxvd1JldmVydCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgcHJvY2VzcyBidXR0b25zXG4gICAgICAgICAgICAgICAgYnV0dG9uRmlsdGVyID0gZnVuY3Rpb24gYnV0dG9uRmlsdGVyKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIS9Qcm9jZXNzLy50ZXN0KGtleSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIHByb2Nlc3MgY29udHJvbHMgYXZhaWxhYmxlXG4gICAgICAgICAgICBidXR0b25GaWx0ZXIgPSBmdW5jdGlvbiBidXR0b25GaWx0ZXIoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEvUHJvY2Vzcy8udGVzdChrZXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmFibGVkQnV0dG9ucyA9IGJ1dHRvbkZpbHRlciA/IEJ1dHRvbktleXMuZmlsdGVyKGJ1dHRvbkZpbHRlcikgOiBCdXR0b25LZXlzLmNvbmNhdCgpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBpY29uIGFuZCBsYWJlbCBmb3IgcmV2ZXJ0IGJ1dHRvbiB3aGVuIGluc3RhbnQgdXBsb2FkaW5nXG4gICAgICAgIGlmIChpbnN0YW50VXBsb2FkICYmIGFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICBMb2NhbEJ1dHRvbnNbJ1JldmVydEl0ZW1Qcm9jZXNzaW5nJ10ubGFiZWwgPSAnR0VUX0xBQkVMX0JVVFRPTl9SRU1PVkVfSVRFTSc7XG4gICAgICAgICAgICBMb2NhbEJ1dHRvbnNbJ1JldmVydEl0ZW1Qcm9jZXNzaW5nJ10uaWNvbiA9ICdHRVRfSUNPTl9SRU1PVkUnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgYnV0dG9uIChyZXZlcnQpIGlmIG5vdCBhbGxvd2VkXG4gICAgICAgIGlmIChpc0FzeW5jICYmICFhbGxvd1JldmVydCkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IFN0eWxlTWFwWydESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJ107XG4gICAgICAgICAgICBtYXAuaW5mby50cmFuc2xhdGVYID0gY2FsY3VsYXRlRmlsZUhvcml6b250YWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgICAgICBtYXAuaW5mby50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICAgICAgbWFwLnN0YXR1cy50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICAgICAgbWFwLnByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvciA9IHsgb3BhY2l0eTogMSwgc2NhbGVYOiAxLCBzY2FsZVk6IDEgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3VsZCBhbGlnbiBjZW50ZXJcbiAgICAgICAgaWYgKGlzQXN5bmMgJiYgIWFsbG93UHJvY2Vzcykge1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgICAgICAnRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgICAgICAnRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1MnLFxuICAgICAgICAgICAgICAgICdESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SJyxcbiAgICAgICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBTdHlsZU1hcFtrZXldLnN0YXR1cy50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBTdHlsZU1hcFsnRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUiddLnN0YXR1cy50cmFuc2xhdGVYID0gY2FsY3VsYXRlQnV0dG9uV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIHJlbW92ZSBidXR0b24gdG8gcmlnaHRcbiAgICAgICAgaWYgKGFsaWduUmVtb3ZlSXRlbUJ1dHRvbiAmJiBhbGxvd1JldmVydCkge1xuICAgICAgICAgICAgTG9jYWxCdXR0b25zWydSZXZlcnRJdGVtUHJvY2Vzc2luZyddLmFsaWduID0gJ0JVVFRPTl9SRU1PVkVfSVRFTV9QT1NJVElPTic7XG4gICAgICAgICAgICB2YXIgX21hcCA9IFN0eWxlTWFwWydESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJ107XG4gICAgICAgICAgICBfbWFwLmluZm8udHJhbnNsYXRlWCA9IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0O1xuICAgICAgICAgICAgX21hcC5zdGF0dXMudHJhbnNsYXRlWSA9IGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldDtcbiAgICAgICAgICAgIF9tYXAucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0geyBvcGFjaXR5OiAxLCBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdy9oaWRlIFJlbW92ZUl0ZW0gYnV0dG9uXG4gICAgICAgIGlmICghYWxsb3dSZW1vdmUpIHtcbiAgICAgICAgICAgIExvY2FsQnV0dG9uc1snUmVtb3ZlSXRlbSddLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgYnV0dG9uIHZpZXdzXG4gICAgICAgIGZvcmluKExvY2FsQnV0dG9ucywgZnVuY3Rpb24oa2V5LCBkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYnV0dG9uXG4gICAgICAgICAgICB2YXIgYnV0dG9uVmlldyA9IHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVBY3Rpb25CdXR0b24sIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogcm9vdC5xdWVyeShkZWZpbml0aW9uLmxhYmVsKSxcbiAgICAgICAgICAgICAgICBpY29uOiByb290LnF1ZXJ5KGRlZmluaXRpb24uaWNvbiksXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYXBwZW5kZWQ/XG4gICAgICAgICAgICBpZiAoZW5hYmxlZEJ1dHRvbnMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJvb3QuYXBwZW5kQ2hpbGRWaWV3KGJ1dHRvblZpZXcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0b2dnbGVcbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICBidXR0b25WaWV3LmVsZW1lbnQuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAnaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBwb3NpdGlvbiBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5kYXRhc2V0LmFsaWduID0gcm9vdC5xdWVyeSgnR0VUX1NUWUxFXycgKyBkZWZpbml0aW9uLmFsaWduKTtcblxuICAgICAgICAgICAgLy8gYWRkIGNsYXNzXG4gICAgICAgICAgICBidXR0b25WaWV3LmVsZW1lbnQuY2xhc3NMaXN0LmFkZChkZWZpbml0aW9uLmNsYXNzTmFtZSk7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgIGJ1dHRvblZpZXcub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKGRlZmluaXRpb24uYWN0aW9uLCB7IHF1ZXJ5OiBpZCB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzZXQgcmVmZXJlbmNlXG4gICAgICAgICAgICByb290LnJlZlsnYnV0dG9uJyArIGtleV0gPSBidXR0b25WaWV3O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjaGVja21hcmtcbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3JWaWV3KVxuICAgICAgICApO1xuXG4gICAgICAgIHJvb3QucmVmLnByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvci5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSByb290LnF1ZXJ5KFxuICAgICAgICAgICAgJ0dFVF9TVFlMRV9CVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJ1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBmaWxlIGluZm8gdmlld1xuICAgICAgICByb290LnJlZi5pbmZvID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZUluZm8sIHsgaWQ6IGlkIH0pKTtcblxuICAgICAgICAvLyBjcmVhdGUgZmlsZSBzdGF0dXMgdmlld1xuICAgICAgICByb290LnJlZi5zdGF0dXMgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlU3RhdHVzLCB7IGlkOiBpZCB9KSk7XG5cbiAgICAgICAgLy8gYWRkIHByb2dyZXNzIGluZGljYXRvcnNcbiAgICAgICAgdmFyIGxvYWRJbmRpY2F0b3JWaWV3ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwcm9ncmVzc0luZGljYXRvciwge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgYWxpZ246IHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9MT0FEX0lORElDQVRPUl9QT1NJVElPTicpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBsb2FkSW5kaWNhdG9yVmlldy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZpbGVwb25kLS1sb2FkLWluZGljYXRvcicpO1xuICAgICAgICByb290LnJlZi5sb2FkUHJvZ3Jlc3NJbmRpY2F0b3IgPSBsb2FkSW5kaWNhdG9yVmlldztcblxuICAgICAgICB2YXIgcHJvZ3Jlc3NJbmRpY2F0b3JWaWV3ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwcm9ncmVzc0luZGljYXRvciwge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgYWxpZ246IHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9QUk9HUkVTU19JTkRJQ0FUT1JfUE9TSVRJT04nKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgcHJvZ3Jlc3NJbmRpY2F0b3JWaWV3LmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLXByb2Nlc3MtaW5kaWNhdG9yJyk7XG4gICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvciA9IHByb2dyZXNzSW5kaWNhdG9yVmlldztcblxuICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSBzdHlsZXNcbiAgICAgICAgcm9vdC5yZWYuYWN0aXZlU3R5bGVzID0gW107XG4gICAgfTtcblxuICAgIHZhciB3cml0ZSQyID0gZnVuY3Rpb24gd3JpdGUoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgYWN0aW9ucyA9IF9yZWYzLmFjdGlvbnMsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgICAgIHJvdXRlKHsgcm9vdDogcm9vdCwgYWN0aW9uczogYWN0aW9ucywgcHJvcHM6IHByb3BzIH0pO1xuXG4gICAgICAgIC8vIHNlbGVjdCBsYXN0IHN0YXRlIGNoYW5nZSBhY3Rpb25cbiAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGlvbnNcbiAgICAgICAgICAgIC5jb25jYXQoKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gL15ESURfLy50ZXN0KGFjdGlvbi50eXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAuZmluZChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3R5bGVNYXBbYWN0aW9uLnR5cGVdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYSBuZXcgYWN0aW9uIGhhcHBlbmVkLCBsZXQncyBnZXQgdGhlIG1hdGNoaW5nIHN0eWxlc1xuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBkZWZpbmUgbmV3IGFjdGl2ZSBzdHlsZXNcbiAgICAgICAgICAgIHJvb3QucmVmLmFjdGl2ZVN0eWxlcyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgc3R5bGVzVG9BcHBseSA9IFN0eWxlTWFwW2FjdGlvbi50eXBlXTtcbiAgICAgICAgICAgIGZvcmluKERlZmF1bHRTdHlsZSwgZnVuY3Rpb24obmFtZSwgZGVmYXVsdFN0eWxlcykge1xuICAgICAgICAgICAgICAgIC8vIGdldCByZWZlcmVuY2UgdG8gY29udHJvbFxuICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0gcm9vdC5yZWZbbmFtZV07XG5cbiAgICAgICAgICAgICAgICAvLyBsb29wIG92ZXIgYWxsIHN0eWxlcyBmb3IgdGhpcyBjb250cm9sXG4gICAgICAgICAgICAgICAgZm9yaW4oZGVmYXVsdFN0eWxlcywgZnVuY3Rpb24oa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1RvQXBwbHlbbmFtZV0gJiYgdHlwZW9mIHN0eWxlc1RvQXBwbHlbbmFtZV1ba2V5XSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHN0eWxlc1RvQXBwbHlbbmFtZV1ba2V5XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByb290LnJlZi5hY3RpdmVTdHlsZXMucHVzaCh7IGNvbnRyb2w6IGNvbnRyb2wsIGtleToga2V5LCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGx5IGFjdGl2ZSBzdHlsZXMgdG8gZWxlbWVudFxuICAgICAgICByb290LnJlZi5hY3RpdmVTdHlsZXMuZm9yRWFjaChmdW5jdGlvbihfcmVmNCkge1xuICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBfcmVmNC5jb250cm9sLFxuICAgICAgICAgICAgICAgIGtleSA9IF9yZWY0LmtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWY0LnZhbHVlO1xuICAgICAgICAgICAgY29udHJvbFtrZXldID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUocm9vdCkgOiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciByb3V0ZSA9IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiBmdW5jdGlvbiBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1BST0NFU1NJTkcoXG4gICAgICAgICAgICBfcmVmNVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmNS5hY3Rpb247XG4gICAgICAgICAgICByb290LnJlZi5idXR0b25BYm9ydEl0ZW1Qcm9jZXNzaW5nLmxhYmVsID0gYWN0aW9uLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX0xPQUQ6IGZ1bmN0aW9uIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRChfcmVmNikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY2LmFjdGlvbjtcbiAgICAgICAgICAgIHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbUxvYWQubGFiZWwgPSBhY3Rpb24udmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUkVNT1ZBTDogZnVuY3Rpb24gRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9SRU1PVkFMKFxuICAgICAgICAgICAgX3JlZjdcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3QsXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gX3JlZjcuYWN0aW9uO1xuICAgICAgICAgICAgcm9vdC5yZWYuYnV0dG9uQWJvcnRJdGVtUmVtb3ZhbC5sYWJlbCA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBmdW5jdGlvbiBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcoX3JlZjgpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjgucm9vdDtcbiAgICAgICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5zcGluID0gdHJ1ZTtcbiAgICAgICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6IGZ1bmN0aW9uIERJRF9TVEFSVF9JVEVNX0xPQUQoX3JlZjkpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjkucm9vdDtcbiAgICAgICAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5zcGluID0gdHJ1ZTtcbiAgICAgICAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9TVEFSVF9JVEVNX1JFTU9WRTogZnVuY3Rpb24gRElEX1NUQVJUX0lURU1fUkVNT1ZFKF9yZWYxMCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTAucm9vdDtcbiAgICAgICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5zcGluID0gdHJ1ZTtcbiAgICAgICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTOiBmdW5jdGlvbiBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUyhfcmVmMTEpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjExLnJvb3QsXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gX3JlZjExLmFjdGlvbjtcbiAgICAgICAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5zcGluID0gZmFsc2U7XG4gICAgICAgICAgICByb290LnJlZi5sb2FkUHJvZ3Jlc3NJbmRpY2F0b3IucHJvZ3Jlc3MgPSBhY3Rpb24ucHJvZ3Jlc3M7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBmdW5jdGlvbiBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUyhfcmVmMTIpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjEyLnJvb3QsXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gX3JlZjEyLmFjdGlvbjtcbiAgICAgICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5zcGluID0gZmFsc2U7XG4gICAgICAgICAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3IucHJvZ3Jlc3MgPSBhY3Rpb24ucHJvZ3Jlc3M7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgZmlsZSA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZSQ0LFxuICAgICAgICB3cml0ZTogd3JpdGUkMixcbiAgICAgICAgZGlkQ3JlYXRlVmlldzogZnVuY3Rpb24gZGlkQ3JlYXRlVmlldyhyb290KSB7XG4gICAgICAgICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgT2JqZWN0LmFzc2lnbih7fSwgcm9vdCwgeyB2aWV3OiByb290IH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZTogJ2ZpbGUnLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gICAgICovXG4gICAgdmFyIGNyZWF0ZSQ1ID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG5cbiAgICAgICAgLy8gZmlsZW5hbWVcbiAgICAgICAgcm9vdC5yZWYuZmlsZU5hbWUgPSBjcmVhdGVFbGVtZW50JDEoJ2xlZ2VuZCcpO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKHJvb3QucmVmLmZpbGVOYW1lKTtcblxuICAgICAgICAvLyBmaWxlIGFwcGVuZGVkXG4gICAgICAgIHJvb3QucmVmLmZpbGUgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlLCB7IGlkOiBwcm9wcy5pZCB9KSk7XG5cbiAgICAgICAgLy8gZGF0YSBoYXMgbW92ZWQgdG8gZGF0YS5qc1xuICAgICAgICByb290LnJlZi5kYXRhID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERhdGEgc3RvcmFnZVxuICAgICAqL1xuICAgIHZhciBkaWRMb2FkSXRlbSA9IGZ1bmN0aW9uIGRpZExvYWRJdGVtKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG4gICAgICAgIC8vIHVwZGF0ZXMgdGhlIGxlZ2VuZCBvZiB0aGUgZmllbGRzZXQgc28gc2NyZWVucmVhZGVycyBjYW4gYmV0dGVyIGdyb3VwIGJ1dHRvbnNcbiAgICAgICAgdGV4dChyb290LnJlZi5maWxlTmFtZSwgZm9ybWF0RmlsZW5hbWUocm9vdC5xdWVyeSgnR0VUX0lURU1fTkFNRScsIHByb3BzLmlkKSkpO1xuICAgIH07XG5cbiAgICB2YXIgZmlsZVdyYXBwZXIgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkNSxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgICAgIERJRF9MT0FEX0lURU06IGRpZExvYWRJdGVtLFxuICAgICAgICB9KSxcblxuICAgICAgICBkaWRDcmVhdGVWaWV3OiBmdW5jdGlvbiBkaWRDcmVhdGVWaWV3KHJvb3QpIHtcbiAgICAgICAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCBPYmplY3QuYXNzaWduKHt9LCByb290LCB7IHZpZXc6IHJvb3QgfSkpO1xuICAgICAgICB9LFxuICAgICAgICB0YWc6ICdmaWVsZHNldCcsXG4gICAgICAgIG5hbWU6ICdmaWxlLXdyYXBwZXInLFxuICAgIH0pO1xuXG4gICAgdmFyIFBBTkVMX1NQUklOR19QUk9QUyA9IHsgdHlwZTogJ3NwcmluZycsIGRhbXBpbmc6IDAuNiwgbWFzczogNyB9O1xuXG4gICAgdmFyIGNyZWF0ZSQ2ID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAndG9wJyxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZVk6IG51bGwsXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVk6IFBBTkVMX1NQUklOR19QUk9QUyxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWScsICdzY2FsZVknXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGwsXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiBQQU5FTF9TUFJJTkdfUFJPUFMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVknXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIGNyZWF0ZVNlY3Rpb24ocm9vdCwgc2VjdGlvbiwgcHJvcHMubmFtZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJvb3QuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0tJyArIHByb3BzLm5hbWUpO1xuXG4gICAgICAgIHJvb3QucmVmLnNjYWxhYmxlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVNlY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVTZWN0aW9uKHJvb3QsIHNlY3Rpb24sIGNsYXNzTmFtZSkge1xuICAgICAgICB2YXIgdmlld0NvbnN0cnVjdG9yID0gY3JlYXRlVmlldyh7XG4gICAgICAgICAgICBuYW1lOiAncGFuZWwtJyArIHNlY3Rpb24ubmFtZSArICcgZmlsZXBvbmQtLScgKyBjbGFzc05hbWUsXG4gICAgICAgICAgICBtaXhpbnM6IHNlY3Rpb24ubWl4aW5zLFxuICAgICAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHZpZXcgPSByb290LmNyZWF0ZUNoaWxkVmlldyh2aWV3Q29uc3RydWN0b3IsIHNlY3Rpb24ucHJvcHMpO1xuXG4gICAgICAgIHJvb3QucmVmW3NlY3Rpb24ubmFtZV0gPSByb290LmFwcGVuZENoaWxkVmlldyh2aWV3KTtcbiAgICB9O1xuXG4gICAgdmFyIHdyaXRlJDMgPSBmdW5jdGlvbiB3cml0ZShfcmVmMikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYyLnByb3BzO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBzY2FsYWJsZSBzdGF0ZVxuICAgICAgICBpZiAocm9vdC5yZWYuc2NhbGFibGUgPT09IG51bGwgfHwgcHJvcHMuc2NhbGFibGUgIT09IHJvb3QucmVmLnNjYWxhYmxlKSB7XG4gICAgICAgICAgICByb290LnJlZi5zY2FsYWJsZSA9IGlzQm9vbGVhbihwcm9wcy5zY2FsYWJsZSkgPyBwcm9wcy5zY2FsYWJsZSA6IHRydWU7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5zY2FsYWJsZSA9IHJvb3QucmVmLnNjYWxhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gaGVpZ2h0LCBjYW4ndCBzZXRcbiAgICAgICAgaWYgKCFwcm9wcy5oZWlnaHQpIHJldHVybjtcblxuICAgICAgICAvLyBnZXQgY2hpbGQgcmVjdHNcbiAgICAgICAgdmFyIHRvcFJlY3QgPSByb290LnJlZi50b3AucmVjdC5lbGVtZW50O1xuICAgICAgICB2YXIgYm90dG9tUmVjdCA9IHJvb3QucmVmLmJvdHRvbS5yZWN0LmVsZW1lbnQ7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIGhlaWdodCBuZXZlciBpcyBzbWFsbGVyIHRoYW4gYm90dG9tIGFuZCB0b3Agc2VjaXRvbiBoZWlnaHRzIGNvbWJpbmVkICh3aWxsIHByb2JhYmx5IG5ldmVyIGhhcHBlbiwgYnV0IHdobyBrbm93cylcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KHRvcFJlY3QuaGVpZ2h0ICsgYm90dG9tUmVjdC5oZWlnaHQsIHByb3BzLmhlaWdodCk7XG5cbiAgICAgICAgLy8gb2Zmc2V0IGNlbnRlciBwYXJ0XG4gICAgICAgIHJvb3QucmVmLmNlbnRlci50cmFuc2xhdGVZID0gdG9wUmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgLy8gc2NhbGUgY2VudGVyIHBhcnRcbiAgICAgICAgLy8gdXNlIG1hdGggY2VpbCB0byBwcmV2ZW50IHRyYW5zcGFyZW50IGxpbmVzIGJlY2F1c2Ugb2Ygcm91bmRpbmcgZXJyb3JzXG4gICAgICAgIHJvb3QucmVmLmNlbnRlci5zY2FsZVkgPSAoaGVpZ2h0IC0gdG9wUmVjdC5oZWlnaHQgLSBib3R0b21SZWN0LmhlaWdodCkgLyAxMDA7XG5cbiAgICAgICAgLy8gb2Zmc2V0IGJvdHRvbSBwYXJ0XG4gICAgICAgIHJvb3QucmVmLmJvdHRvbS50cmFuc2xhdGVZID0gaGVpZ2h0IC0gYm90dG9tUmVjdC5oZWlnaHQ7XG4gICAgfTtcblxuICAgIHZhciBwYW5lbCA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBuYW1lOiAncGFuZWwnLFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKF9yZWYzKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBfcmVmMy5wcm9wcztcbiAgICAgICAgICAgIHJldHVybiAocHJvcHMuaGVpZ2h0Q3VycmVudCA9IHJvb3QucmVmLmJvdHRvbS50cmFuc2xhdGVZKTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IHdyaXRlJDMsXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJDYsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgYXBpczogWydoZWlnaHQnLCAnaGVpZ2h0Q3VycmVudCcsICdzY2FsYWJsZSddLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIGNyZWF0ZURyYWdIZWxwZXIgPSBmdW5jdGlvbiBjcmVhdGVEcmFnSGVscGVyKGl0ZW1zKSB7XG4gICAgICAgIHZhciBpdGVtSWRzID0gaXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmlkO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHByZXZJbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldEluZGV4OiBmdW5jdGlvbiBzZXRJbmRleChpbmRleCkge1xuICAgICAgICAgICAgICAgIHByZXZJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEluZGV4OiBmdW5jdGlvbiBnZXRJbmRleCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldkluZGV4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEl0ZW1JbmRleDogZnVuY3Rpb24gZ2V0SXRlbUluZGV4KGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbUlkcy5pbmRleE9mKGl0ZW0uaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIElURU1fVFJBTlNMQVRFX1NQUklORyA9IHtcbiAgICAgICAgdHlwZTogJ3NwcmluZycsXG4gICAgICAgIHN0aWZmbmVzczogMC43NSxcbiAgICAgICAgZGFtcGluZzogMC40NSxcbiAgICAgICAgbWFzczogMTAsXG4gICAgfTtcblxuICAgIHZhciBJVEVNX1NDQUxFX1NQUklORyA9ICdzcHJpbmcnO1xuXG4gICAgdmFyIFN0YXRlTWFwID0ge1xuICAgICAgICBESURfU1RBUlRfSVRFTV9MT0FEOiAnYnVzeScsXG4gICAgICAgIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTOiAnbG9hZGluZycsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6ICdsb2FkLWludmFsaWQnLFxuICAgICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiAnbG9hZC1lcnJvcicsXG4gICAgICAgIERJRF9MT0FEX0lURU06ICdpZGxlJyxcbiAgICAgICAgRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SOiAncmVtb3ZlLWVycm9yJyxcbiAgICAgICAgRElEX1NUQVJUX0lURU1fUkVNT1ZFOiAnYnVzeScsXG4gICAgICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6ICdidXN5IHByb2Nlc3NpbmcnLFxuICAgICAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6ICdidXN5IHByb2Nlc3NpbmcnLFxuICAgICAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogJ3Byb2Nlc3NpbmcnLFxuICAgICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiAncHJvY2Vzc2luZy1jb21wbGV0ZScsXG4gICAgICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1I6ICdwcm9jZXNzaW5nLWVycm9yJyxcbiAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6ICdwcm9jZXNzaW5nLXJldmVydC1lcnJvcicsXG4gICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6ICdjYW5jZWxsZWQnLFxuICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogJ2lkbGUnLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlJDcgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgLy8gc2VsZWN0XG4gICAgICAgIHJvb3QucmVmLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3QuZGlzcGF0Y2goJ0RJRF9BQ1RJVkFURV9JVEVNJywgeyBpZDogcHJvcHMuaWQgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2V0IGlkXG4gICAgICAgIHJvb3QuZWxlbWVudC5pZCA9ICdmaWxlcG9uZC0taXRlbS0nICsgcHJvcHMuaWQ7XG4gICAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcblxuICAgICAgICAvLyBmaWxlIHZpZXdcbiAgICAgICAgcm9vdC5yZWYuY29udGFpbmVyID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlV3JhcHBlciwgeyBpZDogcHJvcHMuaWQgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBmaWxlIHBhbmVsXG4gICAgICAgIHJvb3QucmVmLnBhbmVsID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcocGFuZWwsIHsgbmFtZTogJ2l0ZW0tcGFuZWwnIH0pKTtcblxuICAgICAgICAvLyBkZWZhdWx0IHN0YXJ0IGhlaWdodFxuICAgICAgICByb290LnJlZi5wYW5lbC5oZWlnaHQgPSBudWxsO1xuXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgbm90IG1hcmtlZCBmb3IgcmVtb3ZhbFxuICAgICAgICBwcm9wcy5tYXJrZWRGb3JSZW1vdmFsID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgbm90IGFsbG93ZWQgdG8gcmVvcmRlciBmaWxlIGl0ZW1zLCBleGl0IGhlcmVcbiAgICAgICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVPUkRFUicpKSByZXR1cm47XG5cbiAgICAgICAgLy8gc2V0IHRvIGlkbGUgc28gc2hvd3MgZ3JhYiBjdXJzb3JcbiAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2lkbGUnO1xuXG4gICAgICAgIHZhciBncmFiID0gZnVuY3Rpb24gZ3JhYihlKSB7XG4gICAgICAgICAgICBpZiAoIWUuaXNQcmltYXJ5KSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciByZW1vdmVkQWN0aXZhdGVMaXN0ZW5lciA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgb3JpZ2luID0ge1xuICAgICAgICAgICAgICAgIHg6IGUucGFnZVgsXG4gICAgICAgICAgICAgICAgeTogZS5wYWdlWSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSB7XG4gICAgICAgICAgICAgICAgeDogcm9vdC50cmFuc2xhdGVYLFxuICAgICAgICAgICAgICAgIHk6IHJvb3QudHJhbnNsYXRlWSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHByb3BzLmRyYWdDZW50ZXIgPSB7XG4gICAgICAgICAgICAgICAgeDogZS5vZmZzZXRYLFxuICAgICAgICAgICAgICAgIHk6IGUub2Zmc2V0WSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBkcmFnU3RhdGUgPSBjcmVhdGVEcmFnSGVscGVyKHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKSk7XG5cbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9HUkFCX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlOiBkcmFnU3RhdGUgfSk7XG5cbiAgICAgICAgICAgIHZhciBkcmFnID0gZnVuY3Rpb24gZHJhZyhlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlLmlzUHJpbWFyeSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBlLnBhZ2VYIC0gb3JpZ2luLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IGUucGFnZVkgLSBvcmlnaW4ueSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgZHJhZ2dlZCBzdG9wIGxpc3RlbmluZyB0byBjbGlja3MsIHdpbGwgcmUtYWRkIHdoZW4gZG9uZSBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIHZhciBkaXN0ID1cbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZHJhZ09mZnNldC54ICogcHJvcHMuZHJhZ09mZnNldC54ICtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZHJhZ09mZnNldC55ICogcHJvcHMuZHJhZ09mZnNldC55O1xuICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gMTYgJiYgIXJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUkFHX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlOiBkcmFnU3RhdGUgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3AoZSkge1xuICAgICAgICAgICAgICAgIGlmICghZS5pc1ByaW1hcnkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHByb3BzLmRyYWdPZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGUucGFnZVggLSBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogZS5wYWdlWSAtIG9yaWdpbi55LFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIGNhbmNlbCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBkcmFnKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBkcm9wKTtcblxuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUk9QX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlOiBkcmFnU3RhdGUgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdGFydCBsaXN0ZW5pbmcgdG8gY2xpY2tzIGFnYWluXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgY2FuY2VsKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgZHJhZyk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBkcm9wKTtcbiAgICAgICAgfTtcblxuICAgICAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBncmFiKTtcbiAgICB9O1xuXG4gICAgdmFyIHJvdXRlJDEgPSBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9VUERBVEVfUEFORUxfSEVJR0hUOiBmdW5jdGlvbiBESURfVVBEQVRFX1BBTkVMX0hFSUdIVChfcmVmMikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gYWN0aW9uLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHZhciB3cml0ZSQ0ID0gY3JlYXRlUm91dGUoXG4gICAgICAgIHtcbiAgICAgICAgICAgIERJRF9HUkFCX0lURU06IGZ1bmN0aW9uIERJRF9HUkFCX0lURU0oX3JlZjMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgICAgICAgICAgICAgcHJvcHMuZHJhZ09yaWdpbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogcm9vdC50cmFuc2xhdGVYLFxuICAgICAgICAgICAgICAgICAgICB5OiByb290LnRyYW5zbGF0ZVksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBESURfRFJBR19JVEVNOiBmdW5jdGlvbiBESURfRFJBR19JVEVNKF9yZWY0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290O1xuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9ICdkcmFnJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBESURfRFJPUF9JVEVNOiBmdW5jdGlvbiBESURfRFJPUF9JVEVNKF9yZWY1KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IF9yZWY1LnByb3BzO1xuICAgICAgICAgICAgICAgIHByb3BzLmRyYWdPZmZzZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9ICdkcm9wJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24oX3JlZjYpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gX3JlZjYuYWN0aW9ucyxcbiAgICAgICAgICAgICAgICBwcm9wcyA9IF9yZWY2LnByb3BzLFxuICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplID0gX3JlZjYuc2hvdWxkT3B0aW1pemU7XG4gICAgICAgICAgICBpZiAocm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID09PSAnZHJvcCcpIHtcbiAgICAgICAgICAgICAgICBpZiAocm9vdC5zY2FsZVggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnaWRsZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWxlY3QgbGFzdCBzdGF0ZSBjaGFuZ2UgYWN0aW9uXG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gYWN0aW9uc1xuICAgICAgICAgICAgICAgIC5jb25jYXQoKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvXkRJRF8vLnRlc3QoYWN0aW9uLnR5cGUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgIC5maW5kKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RhdGVNYXBbYWN0aW9uLnR5cGVdO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIHNldCBzYW1lIHN0YXRlIHR3aWNlXG4gICAgICAgICAgICBpZiAoYWN0aW9uICYmIGFjdGlvbi50eXBlICE9PSBwcm9wcy5jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgY3VycmVudCBzdGF0ZVxuICAgICAgICAgICAgICAgIHByb3BzLmN1cnJlbnRTdGF0ZSA9IGFjdGlvbi50eXBlO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IHN0YXRlXG4gICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZmlsZXBvbmRJdGVtU3RhdGUgPSBTdGF0ZU1hcFtwcm9wcy5jdXJyZW50U3RhdGVdIHx8ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPVxuICAgICAgICAgICAgICAgIHJvb3QucXVlcnkoJ0dFVF9JVEVNX1BBTkVMX0FTUEVDVF9SQVRJTycpIHx8IHJvb3QucXVlcnkoJ0dFVF9QQU5FTF9BU1BFQ1RfUkFUSU8nKTtcbiAgICAgICAgICAgIGlmICghYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgICAgICByb3V0ZSQxKHsgcm9vdDogcm9vdCwgYWN0aW9uczogYWN0aW9ucywgcHJvcHM6IHByb3BzIH0pO1xuICAgICAgICAgICAgICAgIGlmICghcm9vdC5oZWlnaHQgJiYgcm9vdC5yZWYuY29udGFpbmVyLnJlY3QuZWxlbWVudC5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gcm9vdC5yZWYuY29udGFpbmVyLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICAgICAgICByb290LmhlaWdodCA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN5bmMgcGFuZWwgaGVpZ2h0IHdpdGggaXRlbSBoZWlnaHRcbiAgICAgICAgICAgIGlmIChzaG91bGRPcHRpbWl6ZSkge1xuICAgICAgICAgICAgICAgIHJvb3QucmVmLnBhbmVsLmhlaWdodCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJvb3QucmVmLnBhbmVsLmhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIHZhciBpdGVtID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJDcsXG4gICAgICAgIHdyaXRlOiB3cml0ZSQ0LFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWY3KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3QsXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBfcmVmNy5wcm9wcztcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ1JFTEVBU0VfSVRFTScsIHsgcXVlcnk6IHByb3BzLmlkIH0pO1xuICAgICAgICB9LFxuICAgICAgICB0YWc6ICdsaScsXG4gICAgICAgIG5hbWU6ICdpdGVtJyxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBhcGlzOiBbXG4gICAgICAgICAgICAgICAgJ2lkJyxcbiAgICAgICAgICAgICAgICAnaW50ZXJhY3Rpb25NZXRob2QnLFxuICAgICAgICAgICAgICAgICdtYXJrZWRGb3JSZW1vdmFsJyxcbiAgICAgICAgICAgICAgICAnc3Bhd25EYXRlJyxcbiAgICAgICAgICAgICAgICAnZHJhZ0NlbnRlcicsXG4gICAgICAgICAgICAgICAgJ2RyYWdPcmlnaW4nLFxuICAgICAgICAgICAgICAgICdkcmFnT2Zmc2V0JyxcbiAgICAgICAgICAgIF0sXG5cbiAgICAgICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAnc2NhbGVYJywgJ3NjYWxlWScsICdvcGFjaXR5JywgJ2hlaWdodCddLFxuICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgIHNjYWxlWDogSVRFTV9TQ0FMRV9TUFJJTkcsXG4gICAgICAgICAgICAgICAgc2NhbGVZOiBJVEVNX1NDQUxFX1NQUklORyxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYOiBJVEVNX1RSQU5TTEFURV9TUFJJTkcsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogSVRFTV9UUkFOU0xBVEVfU1BSSU5HLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDE1MCB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHZhciBnZXRJdGVtc1BlclJvdyA9IGZ1bmN0aW9uKGhvcml6b250YWxTcGFjZSwgaXRlbVdpZHRoKSB7XG4gICAgICAgIC8vIGFkZCBvbmUgcGl4ZWwgbGVld2F5LCB3aGVuIHVzaW5nIHBlcmNlbnRhZ2VzIGZvciBpdGVtIHdpZHRoIHRvdGFsIGl0ZW1zIGNhbiBiZSAxLjk5IHBlciByb3dcblxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcigoaG9yaXpvbnRhbFNwYWNlICsgMSkgLyBpdGVtV2lkdGgpKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEl0ZW1JbmRleEJ5UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uKHZpZXcsIGNoaWxkcmVuLCBwb3NpdGlvbkluVmlldykge1xuICAgICAgICBpZiAoIXBvc2l0aW9uSW5WaWV3KSByZXR1cm47XG5cbiAgICAgICAgdmFyIGhvcml6b250YWxTcGFjZSA9IHZpZXcucmVjdC5lbGVtZW50LndpZHRoO1xuICAgICAgICAvLyBjb25zdCBjaGlsZHJlbiA9IHZpZXcuY2hpbGRWaWV3cztcbiAgICAgICAgdmFyIGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHZhciBsYXN0ID0gbnVsbDtcblxuICAgICAgICAvLyAtMSwgZG9uJ3QgbW92ZSBpdGVtcyB0byBhY2NvbW9kYXRlIChlaXRoZXIgYWRkIHRvIHRvcCBvciBib3R0b20pXG4gICAgICAgIGlmIChsID09PSAwIHx8IHBvc2l0aW9uSW5WaWV3LnRvcCA8IGNoaWxkcmVuWzBdLnJlY3QuZWxlbWVudC50b3ApIHJldHVybiAtMTtcblxuICAgICAgICAvLyBsZXQncyBnZXQgdGhlIGl0ZW0gd2lkdGhcbiAgICAgICAgdmFyIGl0ZW0gPSBjaGlsZHJlblswXTtcbiAgICAgICAgdmFyIGl0ZW1SZWN0ID0gaXRlbS5yZWN0LmVsZW1lbnQ7XG4gICAgICAgIHZhciBpdGVtSG9yaXpvbnRhbE1hcmdpbiA9IGl0ZW1SZWN0Lm1hcmdpbkxlZnQgKyBpdGVtUmVjdC5tYXJnaW5SaWdodDtcbiAgICAgICAgdmFyIGl0ZW1XaWR0aCA9IGl0ZW1SZWN0LndpZHRoICsgaXRlbUhvcml6b250YWxNYXJnaW47XG4gICAgICAgIHZhciBpdGVtc1BlclJvdyA9IGdldEl0ZW1zUGVyUm93KGhvcml6b250YWxTcGFjZSwgaXRlbVdpZHRoKTtcblxuICAgICAgICAvLyBzdGFja1xuICAgICAgICBpZiAoaXRlbXNQZXJSb3cgPT09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE1pZCA9IGNoaWxkLnJlY3Qub3V0ZXIudG9wICsgY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodCAqIDAuNTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25JblZpZXcudG9wIDwgY2hpbGRNaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ3JpZFxuICAgICAgICB2YXIgaXRlbVZlcnRpY2FsTWFyZ2luID0gaXRlbVJlY3QubWFyZ2luVG9wICsgaXRlbVJlY3QubWFyZ2luQm90dG9tO1xuICAgICAgICB2YXIgaXRlbUhlaWdodCA9IGl0ZW1SZWN0LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcbiAgICAgICAgZm9yICh2YXIgX2luZGV4ID0gMDsgX2luZGV4IDwgbDsgX2luZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBpbmRleFggPSBfaW5kZXggJSBpdGVtc1BlclJvdztcbiAgICAgICAgICAgIHZhciBpbmRleFkgPSBNYXRoLmZsb29yKF9pbmRleCAvIGl0ZW1zUGVyUm93KTtcblxuICAgICAgICAgICAgdmFyIG9mZnNldFggPSBpbmRleFggKiBpdGVtV2lkdGg7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0WSA9IGluZGV4WSAqIGl0ZW1IZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBpdGVtVG9wID0gb2Zmc2V0WSAtIGl0ZW1SZWN0Lm1hcmdpblRvcDtcbiAgICAgICAgICAgIHZhciBpdGVtUmlnaHQgPSBvZmZzZXRYICsgaXRlbVdpZHRoO1xuICAgICAgICAgICAgdmFyIGl0ZW1Cb3R0b20gPSBvZmZzZXRZICsgaXRlbUhlaWdodCArIGl0ZW1SZWN0Lm1hcmdpbkJvdHRvbTtcblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LnRvcCA8IGl0ZW1Cb3R0b20gJiYgcG9zaXRpb25JblZpZXcudG9wID4gaXRlbVRvcCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbkluVmlldy5sZWZ0IDwgaXRlbVJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaW5kZXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfaW5kZXggIT09IGwgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBfaW5kZXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfTtcblxuICAgIHZhciBkcm9wQXJlYURpbWVuc2lvbnMgPSB7XG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGdldCBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBzZXRIZWlnaHQodmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT09IDAgfHwgdmFsID09PSAwKSB0aGlzLmhlaWdodCA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGdldFdpZHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBzZXRXaWR0aCh2YWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoID09PSAwIHx8IHZhbCA9PT0gMCkgdGhpcy53aWR0aCA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RGltZW5zaW9uczogZnVuY3Rpb24gc2V0RGltZW5zaW9ucyhoZWlnaHQsIHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoID09PSAwIHx8IHdpZHRoID09PSAwKSB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkOCA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgICAgICAvLyBuZWVkIHRvIHNldCByb2xlIHRvIGxpc3QgYXMgb3RoZXJ3aXNlIGl0IHdvbid0IGJlIHJlYWQgYXMgYSBsaXN0IGJ5IFZvaWNlT3ZlclxuICAgICAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ3JvbGUnLCAnbGlzdCcpO1xuXG4gICAgICAgIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlID0gRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIG5ldyBpdGVtXG4gICAgICogQHBhcmFtIHJvb3RcbiAgICAgKiBAcGFyYW0gYWN0aW9uXG4gICAgICovXG4gICAgdmFyIGFkZEl0ZW1WaWV3ID0gZnVuY3Rpb24gYWRkSXRlbVZpZXcoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgICAgICB2YXIgaWQgPSBhY3Rpb24uaWQsXG4gICAgICAgICAgICBpbmRleCA9IGFjdGlvbi5pbmRleCxcbiAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kID0gYWN0aW9uLmludGVyYWN0aW9uTWV0aG9kO1xuXG4gICAgICAgIHJvb3QucmVmLmFkZEluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBzcGF3bkRhdGUgPSBub3c7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gMTtcblxuICAgICAgICBpZiAoaW50ZXJhY3Rpb25NZXRob2QgIT09IEludGVyYWN0aW9uTWV0aG9kLk5PTkUpIHtcbiAgICAgICAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgdmFyIGNvb2xkb3duID0gcm9vdC5xdWVyeSgnR0VUX0lURU1fSU5TRVJUX0lOVEVSVkFMJyk7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IG5vdyAtIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlO1xuICAgICAgICAgICAgc3Bhd25EYXRlID0gZGlzdCA8IGNvb2xkb3duID8gbm93ICsgKGNvb2xkb3duIC0gZGlzdCkgOiBub3c7XG4gICAgICAgIH1cblxuICAgICAgICByb290LnJlZi5sYXN0SXRlbVNwYW53RGF0ZSA9IHNwYXduRGF0ZTtcblxuICAgICAgICByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KFxuICAgICAgICAgICAgICAgIC8vIHZpZXcgdHlwZVxuICAgICAgICAgICAgICAgIGl0ZW0sXG5cbiAgICAgICAgICAgICAgICAvLyBwcm9wc1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3Bhd25EYXRlOiBzcGF3bkRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IGludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBtb3ZlSXRlbSA9IGZ1bmN0aW9uIG1vdmVJdGVtKGl0ZW0sIHgsIHkpIHtcbiAgICAgICAgdmFyIHZ4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgICB2YXIgdnkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDE7XG4gICAgICAgIC8vIHNldCB0byBudWxsIHRvIHJlbW92ZSBhbmltYXRpb24gd2hpbGUgZHJhZ2dpbmdcbiAgICAgICAgaWYgKGl0ZW0uZHJhZ09mZnNldCkge1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBpdGVtLmRyYWdPcmlnaW4ueCArIGl0ZW0uZHJhZ09mZnNldC54O1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVZID0gaXRlbS5kcmFnT3JpZ2luLnkgKyBpdGVtLmRyYWdPZmZzZXQueTtcbiAgICAgICAgICAgIGl0ZW0uc2NhbGVYID0gMS4wMjU7XG4gICAgICAgICAgICBpdGVtLnNjYWxlWSA9IDEuMDI1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVYID0geDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHk7XG5cbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpID4gaXRlbS5zcGF3bkRhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyByZXZlYWwgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChpdGVtLm9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW50cm9JdGVtVmlldyhpdGVtLCB4LCB5LCB2eCwgdnkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBpcyBkZWZhdWx0IHNjYWxlIGV2ZXJ5IGZyYW1lXG4gICAgICAgICAgICAgICAgaXRlbS5zY2FsZVggPSAxO1xuICAgICAgICAgICAgICAgIGl0ZW0uc2NhbGVZID0gMTtcbiAgICAgICAgICAgICAgICBpdGVtLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBpbnRyb0l0ZW1WaWV3ID0gZnVuY3Rpb24gaW50cm9JdGVtVmlldyhpdGVtLCB4LCB5LCB2eCwgdnkpIHtcbiAgICAgICAgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLk5PTkUpIHtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4O1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5pbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuRFJPUCkge1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHggLSB2eCAqIDIwO1xuXG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVZID0geSAtIHZ5ICogMTA7XG5cbiAgICAgICAgICAgIGl0ZW0uc2NhbGVYID0gMC44O1xuICAgICAgICAgICAgaXRlbS5zY2FsZVkgPSAwLjg7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5pbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuQlJPV1NFKSB7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVZID0geSAtIDMwO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkFQSSkge1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHggLSAzMDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBleGlzdGluZyBpdGVtXG4gICAgICogQHBhcmFtIHJvb3RcbiAgICAgKiBAcGFyYW0gYWN0aW9uXG4gICAgICovXG4gICAgdmFyIHJlbW92ZUl0ZW1WaWV3ID0gZnVuY3Rpb24gcmVtb3ZlSXRlbVZpZXcoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgICAgICB2YXIgaWQgPSBhY3Rpb24uaWQ7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB2aWV3IG1hdGNoaW5nIHRoZSBnaXZlbiBpZFxuICAgICAgICB2YXIgdmlldyA9IHJvb3QuY2hpbGRWaWV3cy5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGlkO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiBubyB2aWV3IGZvdW5kLCBleGl0XG4gICAgICAgIGlmICghdmlldykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYW5pbWF0ZSB2aWV3IG91dCBvZiB2aWV3XG4gICAgICAgIHZpZXcuc2NhbGVYID0gMC45O1xuICAgICAgICB2aWV3LnNjYWxlWSA9IDAuOTtcbiAgICAgICAgdmlldy5vcGFjaXR5ID0gMDtcblxuICAgICAgICAvLyBtYXJrIGZvciByZW1vdmFsXG4gICAgICAgIHZpZXcubWFya2VkRm9yUmVtb3ZhbCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBnZXRJdGVtSGVpZ2h0ID0gZnVuY3Rpb24gZ2V0SXRlbUhlaWdodChjaGlsZCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodCArXG4gICAgICAgICAgICBjaGlsZC5yZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tICogMC41ICtcbiAgICAgICAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgKiAwLjVcbiAgICAgICAgKTtcbiAgICB9O1xuICAgIHZhciBnZXRJdGVtV2lkdGggPSBmdW5jdGlvbiBnZXRJdGVtV2lkdGgoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC53aWR0aCArXG4gICAgICAgICAgICBjaGlsZC5yZWN0LmVsZW1lbnQubWFyZ2luTGVmdCAqIDAuNSArXG4gICAgICAgICAgICBjaGlsZC5yZWN0LmVsZW1lbnQubWFyZ2luUmlnaHQgKiAwLjVcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYWdJdGVtID0gZnVuY3Rpb24gZHJhZ0l0ZW0oX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjQuYWN0aW9uO1xuICAgICAgICB2YXIgaWQgPSBhY3Rpb24uaWQsXG4gICAgICAgICAgICBkcmFnU3RhdGUgPSBhY3Rpb24uZHJhZ1N0YXRlO1xuXG4gICAgICAgIC8vIHJlZmVyZW5jZSB0byBpdGVtXG4gICAgICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCB7IGlkOiBpZCB9KTtcblxuICAgICAgICAvLyBnZXQgdGhlIHZpZXcgbWF0Y2hpbmcgdGhlIGdpdmVuIGlkXG4gICAgICAgIHZhciB2aWV3ID0gcm9vdC5jaGlsZFZpZXdzLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBudW1JdGVtcyA9IHJvb3QuY2hpbGRWaWV3cy5sZW5ndGg7XG4gICAgICAgIHZhciBvbGRJbmRleCA9IGRyYWdTdGF0ZS5nZXRJdGVtSW5kZXgoaXRlbSk7XG5cbiAgICAgICAgLy8gaWYgbm8gdmlldyBmb3VuZCwgZXhpdFxuICAgICAgICBpZiAoIXZpZXcpIHJldHVybjtcblxuICAgICAgICB2YXIgZHJhZ1Bvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogdmlldy5kcmFnT3JpZ2luLnggKyB2aWV3LmRyYWdPZmZzZXQueCArIHZpZXcuZHJhZ0NlbnRlci54LFxuICAgICAgICAgICAgeTogdmlldy5kcmFnT3JpZ2luLnkgKyB2aWV3LmRyYWdPZmZzZXQueSArIHZpZXcuZHJhZ0NlbnRlci55LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdldCBkcmFnIGFyZWEgZGltZW5zaW9uc1xuICAgICAgICB2YXIgZHJhZ0hlaWdodCA9IGdldEl0ZW1IZWlnaHQodmlldyk7XG4gICAgICAgIHZhciBkcmFnV2lkdGggPSBnZXRJdGVtV2lkdGgodmlldyk7XG5cbiAgICAgICAgLy8gZ2V0IHJvd3MgYW5kIGNvbHVtbnMgKFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSByb3cgYW5kIG9uZSBjb2x1bW4gaWYgYSBmaWxlIGlzIHByZXNlbnQpXG4gICAgICAgIHZhciBjb2xzID0gTWF0aC5mbG9vcihyb290LnJlY3Qub3V0ZXIud2lkdGggLyBkcmFnV2lkdGgpO1xuICAgICAgICBpZiAoY29scyA+IG51bUl0ZW1zKSBjb2xzID0gbnVtSXRlbXM7XG5cbiAgICAgICAgLy8gcm93cyBhcmUgdXNlZCB0byBmaW5kIHdoZW4gd2UgaGF2ZSBsZWZ0IHRoZSBwcmV2aWV3IGFyZWEgYm91bmRpbmcgYm94XG4gICAgICAgIHZhciByb3dzID0gTWF0aC5mbG9vcihudW1JdGVtcyAvIGNvbHMgKyAxKTtcblxuICAgICAgICBkcm9wQXJlYURpbWVuc2lvbnMuc2V0SGVpZ2h0ID0gZHJhZ0hlaWdodCAqIHJvd3M7XG4gICAgICAgIGRyb3BBcmVhRGltZW5zaW9ucy5zZXRXaWR0aCA9IGRyYWdXaWR0aCAqIGNvbHM7XG5cbiAgICAgICAgLy8gZ2V0IG5ldyBpbmRleCBvZiBkcmFnZ2VkIGl0ZW1cbiAgICAgICAgdmFyIGxvY2F0aW9uID0ge1xuICAgICAgICAgICAgeTogTWF0aC5mbG9vcihkcmFnUG9zaXRpb24ueSAvIGRyYWdIZWlnaHQpLFxuICAgICAgICAgICAgeDogTWF0aC5mbG9vcihkcmFnUG9zaXRpb24ueCAvIGRyYWdXaWR0aCksXG4gICAgICAgICAgICBnZXRHcmlkSW5kZXg6IGZ1bmN0aW9uIGdldEdyaWRJbmRleCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGRyYWdQb3NpdGlvbi55ID4gZHJvcEFyZWFEaW1lbnNpb25zLmdldEhlaWdodCB8fFxuICAgICAgICAgICAgICAgICAgICBkcmFnUG9zaXRpb24ueSA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1Bvc2l0aW9uLnggPiBkcm9wQXJlYURpbWVuc2lvbnMuZ2V0V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1Bvc2l0aW9uLnggPCAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueSAqIGNvbHMgKyB0aGlzLng7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q29sSW5kZXg6IGZ1bmN0aW9uIGdldENvbEluZGV4KCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKTtcbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZUNoaWxkcmVuID0gcm9vdC5jaGlsZFZpZXdzLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBpdGVtcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaWJsZUNoaWxkcmVuLmZpbmQoZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRWaWV3LmlkID09PSBpdGVtLmlkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBjaGlsZHJlbi5maW5kSW5kZXgoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkID09PSB2aWV3O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBkcmFnSGVpZ2h0ID0gZ2V0SXRlbUhlaWdodCh2aWV3KTtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gbDtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZEJvdHRvbSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkVG9wID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEhlaWdodCA9IGdldEl0ZW1IZWlnaHQoY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFRvcCA9IGNoaWxkQm90dG9tO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEJvdHRvbSA9IGNoaWxkVG9wICsgY2hpbGRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnUG9zaXRpb24ueSA8IGNoaWxkQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkcmFnUG9zaXRpb24ueSA8IGNoaWxkVG9wICsgZHJhZ0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2V0IG5ldyBpbmRleFxuICAgICAgICB2YXIgaW5kZXggPSBjb2xzID4gMSA/IGxvY2F0aW9uLmdldEdyaWRJbmRleCgpIDogbG9jYXRpb24uZ2V0Q29sSW5kZXgoKTtcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnTU9WRV9JVEVNJywgeyBxdWVyeTogdmlldywgaW5kZXg6IGluZGV4IH0pO1xuXG4gICAgICAgIC8vIGlmIHRoZSBpbmRleCBvZiB0aGUgaXRlbSBjaGFuZ2VkLCBkaXNwYXRjaCByZW9yZGVyIGFjdGlvblxuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gZHJhZ1N0YXRlLmdldEluZGV4KCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgIGRyYWdTdGF0ZS5zZXRJbmRleChpbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfUkVPUkRFUl9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICBpdGVtczogcm9vdC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogb2xkSW5kZXgsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpbmRleCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHVwIGFjdGlvbiByb3V0ZXNcbiAgICAgKi9cbiAgICB2YXIgcm91dGUkMiA9IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX0FERF9JVEVNOiBhZGRJdGVtVmlldyxcbiAgICAgICAgRElEX1JFTU9WRV9JVEVNOiByZW1vdmVJdGVtVmlldyxcbiAgICAgICAgRElEX0RSQUdfSVRFTTogZHJhZ0l0ZW0sXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0byB2aWV3XG4gICAgICogQHBhcmFtIHJvb3RcbiAgICAgKiBAcGFyYW0gYWN0aW9uc1xuICAgICAqIEBwYXJhbSBwcm9wc1xuICAgICAqL1xuICAgIHZhciB3cml0ZSQ1ID0gZnVuY3Rpb24gd3JpdGUoX3JlZjUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcyxcbiAgICAgICAgICAgIGFjdGlvbnMgPSBfcmVmNS5hY3Rpb25zLFxuICAgICAgICAgICAgc2hvdWxkT3B0aW1pemUgPSBfcmVmNS5zaG91bGRPcHRpbWl6ZTtcbiAgICAgICAgLy8gcm91dGUgYWN0aW9uc1xuICAgICAgICByb3V0ZSQyKHsgcm9vdDogcm9vdCwgcHJvcHM6IHByb3BzLCBhY3Rpb25zOiBhY3Rpb25zIH0pO1xuICAgICAgICB2YXIgZHJhZ0Nvb3JkaW5hdGVzID0gcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzO1xuXG4gICAgICAgIC8vIGF2YWlsYWJsZSBzcGFjZSBvbiBob3Jpem9udGFsIGF4aXNcbiAgICAgICAgdmFyIGhvcml6b250YWxTcGFjZSA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoO1xuXG4gICAgICAgIC8vIG9ubHkgZHJhdyBjaGlsZHJlbiB0aGF0IGhhdmUgZGltZW5zaW9uc1xuICAgICAgICB2YXIgdmlzaWJsZUNoaWxkcmVuID0gcm9vdC5jaGlsZFZpZXdzLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNvcnQgYmFzZWQgb24gY3VycmVudCBhY3RpdmUgaXRlbXNcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcm9vdFxuICAgICAgICAgICAgLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpYmxlQ2hpbGRyZW4uZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGl0ZW0uaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBnZXQgaW5kZXhcbiAgICAgICAgdmFyIGRyYWdJbmRleCA9IGRyYWdDb29yZGluYXRlc1xuICAgICAgICAgICAgPyBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uKHJvb3QsIGNoaWxkcmVuLCBkcmFnQ29vcmRpbmF0ZXMpXG4gICAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgLy8gYWRkIGluZGV4IGlzIHVzZWQgdG8gcmVzZXJ2ZSB0aGUgZHJvcHBlZC9hZGRlZCBpdGVtIGluZGV4IHRpbGwgdGhlIGFjdHVhbCBpdGVtIGlzIHJlbmRlcmVkXG4gICAgICAgIHZhciBhZGRJbmRleCA9IHJvb3QucmVmLmFkZEluZGV4IHx8IG51bGw7XG5cbiAgICAgICAgLy8gYWRkIGluZGV4IG5vIGxvbmdlciBuZWVkZWQgdGlsbCBwb3NzaWJseSBuZXh0IGRyYXdcbiAgICAgICAgcm9vdC5yZWYuYWRkSW5kZXggPSBudWxsO1xuXG4gICAgICAgIHZhciBkcmFnSW5kZXhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgcmVtb3ZlSW5kZXhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYWRkSW5kZXhPZmZzZXQgPSAwO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50O1xuICAgICAgICB2YXIgaXRlbVZlcnRpY2FsTWFyZ2luID0gY2hpbGRSZWN0Lm1hcmdpblRvcCArIGNoaWxkUmVjdC5tYXJnaW5Cb3R0b207XG4gICAgICAgIHZhciBpdGVtSG9yaXpvbnRhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5MZWZ0ICsgY2hpbGRSZWN0Lm1hcmdpblJpZ2h0O1xuICAgICAgICB2YXIgaXRlbVdpZHRoID0gY2hpbGRSZWN0LndpZHRoICsgaXRlbUhvcml6b250YWxNYXJnaW47XG4gICAgICAgIHZhciBpdGVtSGVpZ2h0ID0gY2hpbGRSZWN0LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcbiAgICAgICAgdmFyIGl0ZW1zUGVyUm93ID0gZ2V0SXRlbXNQZXJSb3coaG9yaXpvbnRhbFNwYWNlLCBpdGVtV2lkdGgpO1xuXG4gICAgICAgIC8vIHN0YWNrXG4gICAgICAgIGlmIChpdGVtc1BlclJvdyA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldFkgPSAwO1xuICAgICAgICAgICAgdmFyIGRyYWdPZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChkcmFnSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBpbmRleCAtIGRyYWdJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gLWl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuMjU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXQgPSAtaXRlbVZlcnRpY2FsTWFyZ2luICogMC43NTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gaXRlbVZlcnRpY2FsTWFyZ2luICogMC43NTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gaXRlbVZlcnRpY2FsTWFyZ2luICogMC4yNTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLm1hcmtlZEZvclJlbW92YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZUl0ZW0oY2hpbGQsIDAsIG9mZnNldFkgKyBkcmFnT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaXRlbUhlaWdodCA9IGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG5cbiAgICAgICAgICAgICAgICB2YXIgdmlzdWFsSGVpZ2h0ID0gaXRlbUhlaWdodCAqIChjaGlsZC5tYXJrZWRGb3JSZW1vdmFsID8gY2hpbGQub3BhY2l0eSA6IDEpO1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSArPSB2aXN1YWxIZWlnaHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBncmlkXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZYID0gMDtcbiAgICAgICAgICAgIHZhciBwcmV2WSA9IDA7XG5cbiAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBkcmFnSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0luZGV4T2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGFkZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEluZGV4T2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm1hcmtlZEZvclJlbW92YWwgJiYgY2hpbGQub3BhY2l0eSA8IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVJbmRleE9mZnNldCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB2aXN1YWxJbmRleCA9IGluZGV4ICsgYWRkSW5kZXhPZmZzZXQgKyBkcmFnSW5kZXhPZmZzZXQgKyByZW1vdmVJbmRleE9mZnNldDtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRleFggPSB2aXN1YWxJbmRleCAlIGl0ZW1zUGVyUm93O1xuICAgICAgICAgICAgICAgIHZhciBpbmRleFkgPSBNYXRoLmZsb29yKHZpc3VhbEluZGV4IC8gaXRlbXNQZXJSb3cpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFggPSBpbmRleFggKiBpdGVtV2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFkgPSBpbmRleFkgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgdmFyIHZlY3RvclggPSBNYXRoLnNpZ24ob2Zmc2V0WCAtIHByZXZYKTtcbiAgICAgICAgICAgICAgICB2YXIgdmVjdG9yWSA9IE1hdGguc2lnbihvZmZzZXRZIC0gcHJldlkpO1xuXG4gICAgICAgICAgICAgICAgcHJldlggPSBvZmZzZXRYO1xuICAgICAgICAgICAgICAgIHByZXZZID0gb2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5tYXJrZWRGb3JSZW1vdmFsKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQudHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vdmVJdGVtKGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZLCB2ZWN0b3JYLCB2ZWN0b3JZKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgYWN0aW9ucyB0aGF0IGFyZSBtZWFudCBzcGVjaWZpY2FsbHkgZm9yIGEgY2VydGFpbiBjaGlsZCBvZiB0aGUgbGlzdFxuICAgICAqIEBwYXJhbSBjaGlsZFxuICAgICAqIEBwYXJhbSBhY3Rpb25zXG4gICAgICovXG4gICAgdmFyIGZpbHRlclNldEl0ZW1BY3Rpb25zID0gZnVuY3Rpb24gZmlsdGVyU2V0SXRlbUFjdGlvbnMoY2hpbGQsIGFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgLy8gaWYgYWN0aW9uIGhhcyBhbiBpZCwgZmlsdGVyIG91dCBhY3Rpb25zIHRoYXQgZG9uJ3QgaGF2ZSB0aGlzIGNoaWxkIGlkXG4gICAgICAgICAgICBpZiAoYWN0aW9uLmRhdGEgJiYgYWN0aW9uLmRhdGEuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGFjdGlvbi5kYXRhLmlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhbGxvdyBhbGwgb3RoZXIgYWN0aW9uc1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgbGlzdCA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZSQ4LFxuICAgICAgICB3cml0ZTogd3JpdGUkNSxcbiAgICAgICAgdGFnOiAndWwnLFxuICAgICAgICBuYW1lOiAnbGlzdCcsXG4gICAgICAgIGRpZFdyaXRlVmlldzogZnVuY3Rpb24gZGlkV3JpdGVWaWV3KF9yZWY2KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3Q7XG4gICAgICAgICAgICByb290LmNoaWxkVmlld3NcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXcubWFya2VkRm9yUmVtb3ZhbCAmJiB2aWV3Lm9wYWNpdHkgPT09IDAgJiYgdmlldy5yZXN0aW5nO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24odmlldykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3Ll9kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHZpZXcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZDogZmlsdGVyU2V0SXRlbUFjdGlvbnMsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgYXBpczogWydkcmFnQ29vcmRpbmF0ZXMnXSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHZhciBjcmVhdGUkOSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICByb290LnJlZi5saXN0ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcobGlzdCkpO1xuICAgICAgICBwcm9wcy5kcmFnQ29vcmRpbmF0ZXMgPSBudWxsO1xuICAgICAgICBwcm9wcy5vdmVyZmxvd2luZyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgc3RvcmVEcmFnQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzdG9yZURyYWdDb29yZGluYXRlcyhfcmVmMikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYyLnByb3BzLFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgICAgICBpZiAoIXJvb3QucXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTl9GUkVFRE9NJykpIHJldHVybjtcbiAgICAgICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0ge1xuICAgICAgICAgICAgbGVmdDogYWN0aW9uLnBvc2l0aW9uLnNjb3BlTGVmdCAtIHJvb3QucmVmLmxpc3QucmVjdC5lbGVtZW50LmxlZnQsXG4gICAgICAgICAgICB0b3A6XG4gICAgICAgICAgICAgICAgYWN0aW9uLnBvc2l0aW9uLnNjb3BlVG9wIC1cbiAgICAgICAgICAgICAgICAocm9vdC5yZWN0Lm91dGVyLnRvcCArIHJvb3QucmVjdC5lbGVtZW50Lm1hcmdpblRvcCArIHJvb3QucmVjdC5lbGVtZW50LnNjcm9sbFRvcCksXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjbGVhckRyYWdDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGNsZWFyRHJhZ0Nvb3JkaW5hdGVzKF9yZWYzKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgICBwcm9wcy5kcmFnQ29vcmRpbmF0ZXMgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgcm91dGUkMyA9IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX0RSQUc6IHN0b3JlRHJhZ0Nvb3JkaW5hdGVzLFxuICAgICAgICBESURfRU5EX0RSQUc6IGNsZWFyRHJhZ0Nvb3JkaW5hdGVzLFxuICAgIH0pO1xuXG4gICAgdmFyIHdyaXRlJDYgPSBmdW5jdGlvbiB3cml0ZShfcmVmNCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWY0LnByb3BzLFxuICAgICAgICAgICAgYWN0aW9ucyA9IF9yZWY0LmFjdGlvbnM7XG5cbiAgICAgICAgLy8gcm91dGUgYWN0aW9uc1xuICAgICAgICByb3V0ZSQzKHsgcm9vdDogcm9vdCwgcHJvcHM6IHByb3BzLCBhY3Rpb25zOiBhY3Rpb25zIH0pO1xuXG4gICAgICAgIC8vIGN1cnJlbnQgZHJhZyBwb3NpdGlvblxuICAgICAgICByb290LnJlZi5saXN0LmRyYWdDb29yZGluYXRlcyA9IHByb3BzLmRyYWdDb29yZGluYXRlcztcblxuICAgICAgICAvLyBpZiBjdXJyZW50bHkgb3ZlcmZsb3dpbmcgYnV0IG5vIGxvbmdlciByZWNlaXZlZCBvdmVyZmxvd1xuICAgICAgICBpZiAocHJvcHMub3ZlcmZsb3dpbmcgJiYgIXByb3BzLm92ZXJmbG93KSB7XG4gICAgICAgICAgICBwcm9wcy5vdmVyZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyByZXNldCBvdmVyZmxvdyBzdGF0ZVxuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuc3RhdGUgPSAnJztcbiAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGlzIG5vdCBvdmVyZmxvd2luZyBjdXJyZW50bHkgYnV0IGRvZXMgcmVjZWl2ZSBvdmVyZmxvdyB2YWx1ZVxuICAgICAgICBpZiAocHJvcHMub3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSBNYXRoLnJvdW5kKHByb3BzLm92ZXJmbG93KTtcbiAgICAgICAgICAgIGlmIChuZXdIZWlnaHQgIT09IHJvb3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcHJvcHMub3ZlcmZsb3dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnN0YXRlID0gJ292ZXJmbG93JztcbiAgICAgICAgICAgICAgICByb290LmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGlzdFNjcm9sbGVyID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJDksXG4gICAgICAgIHdyaXRlOiB3cml0ZSQ2LFxuICAgICAgICBuYW1lOiAnbGlzdC1zY3JvbGxlcicsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgYXBpczogWydvdmVyZmxvdycsICdkcmFnQ29vcmRpbmF0ZXMnXSxcbiAgICAgICAgICAgIHN0eWxlczogWydoZWlnaHQnLCAndHJhbnNsYXRlWSddLFxuICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHZhciBhdHRyVG9nZ2xlID0gZnVuY3Rpb24gYXR0clRvZ2dsZShlbGVtZW50LCBuYW1lLCBzdGF0ZSkge1xuICAgICAgICB2YXIgZW5hYmxlZFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnJztcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBhdHRyKGVsZW1lbnQsIG5hbWUsIGVuYWJsZWRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzZXRGaWxlSW5wdXQgPSBmdW5jdGlvbiByZXNldEZpbGVJbnB1dChpbnB1dCkge1xuICAgICAgICAvLyBubyB2YWx1ZSwgbm8gbmVlZCB0byByZXNldFxuICAgICAgICBpZiAoIWlucHV0IHx8IGlucHV0LnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGZvciBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gJyc7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgICAgICAvLyBmb3IgSUUxMFxuICAgICAgICBpZiAoaW5wdXQudmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHF1aWNrbHkgYXBwZW5kIGlucHV0IHRvIHRlbXAgZm9ybSBhbmQgcmVzZXQgZm9ybVxuICAgICAgICAgICAgdmFyIGZvcm0gPSBjcmVhdGVFbGVtZW50JDEoJ2Zvcm0nKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gaW5wdXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHZhciByZWYgPSBpbnB1dC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgZm9ybS5yZXNldCgpO1xuXG4gICAgICAgICAgICAvLyByZS1pbmplY3QgaW5wdXQgd2hlcmUgaXQgb3JpZ2luYWxseSB3YXNcbiAgICAgICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShpbnB1dCwgcmVmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZSRhID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG5cbiAgICAgICAgLy8gc2V0IGlkIHNvIGNhbiBiZSByZWZlcmVuY2VkIGZyb20gb3V0c2lkZSBsYWJlbHNcbiAgICAgICAgcm9vdC5lbGVtZW50LmlkID0gJ2ZpbGVwb25kLS1icm93c2VyLScgKyBwcm9wcy5pZDtcblxuICAgICAgICAvLyBzZXQgbmFtZSBvZiBlbGVtZW50IChpcyByZW1vdmVkIHdoZW4gYSB2YWx1ZSBpcyBzZXQpXG4gICAgICAgIGF0dHIocm9vdC5lbGVtZW50LCAnbmFtZScsIHJvb3QucXVlcnkoJ0dFVF9OQU1FJykpO1xuXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gbGluayB0aGlzIGVsZW1lbnQgdG8gdGhlIHN0YXR1cyBlbGVtZW50XG4gICAgICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1jb250cm9scycsICdmaWxlcG9uZC0tYXNzaXN0YW50LScgKyBwcm9wcy5pZCk7XG5cbiAgICAgICAgLy8gc2V0IGxhYmVsLCB3ZSB1c2UgbGFiZWxsZWQgYnkgYXMgb3RoZXJ3aXNlIHRoZSBzY3JlZW5yZWFkZXIgZG9lcyBub3QgcmVhZCB0aGUgXCJicm93c2VcIiB0ZXh0IGluIHRoZSBsYWJlbCAoYXMgaXQgaGFzIHRhYmluZGV4OiAwKVxuICAgICAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtbGFiZWxsZWRieScsICdmaWxlcG9uZC0tZHJvcC1sYWJlbC0nICsgcHJvcHMuaWQpO1xuXG4gICAgICAgIC8vIHNldCBjb25maWd1cmFibGUgcHJvcHNcbiAgICAgICAgc2V0QWNjZXB0ZWRGaWxlVHlwZXMoe1xuICAgICAgICAgICAgcm9vdDogcm9vdCxcbiAgICAgICAgICAgIGFjdGlvbjogeyB2YWx1ZTogcm9vdC5xdWVyeSgnR0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVMnKSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdG9nZ2xlQWxsb3dNdWx0aXBsZSh7IHJvb3Q6IHJvb3QsIGFjdGlvbjogeyB2YWx1ZTogcm9vdC5xdWVyeSgnR0VUX0FMTE9XX01VTFRJUExFJykgfSB9KTtcbiAgICAgICAgdG9nZ2xlRGlyZWN0b3J5RmlsdGVyKHtcbiAgICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgICBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9BTExPV19ESVJFQ1RPUklFU19PTkxZJykgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRvZ2dsZURpc2FibGVkKHsgcm9vdDogcm9vdCB9KTtcbiAgICAgICAgdG9nZ2xlUmVxdWlyZWQoeyByb290OiByb290LCBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9SRVFVSVJFRCcpIH0gfSk7XG4gICAgICAgIHNldENhcHR1cmVNZXRob2QoeyByb290OiByb290LCBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9DQVBUVVJFX01FVEhPRCcpIH0gfSk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGNoYW5nZXMgdG8gdGhlIGlucHV0IGZpZWxkXG4gICAgICAgIHJvb3QucmVmLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICghcm9vdC5lbGVtZW50LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBleHRyYWN0IGZpbGVzIGFuZCBtb3ZlIHZhbHVlIG9mIHdlYmtpdFJlbGF0aXZlUGF0aCBwYXRoIHRvIF9yZWxhdGl2ZVBhdGhcbiAgICAgICAgICAgIHZhciBmaWxlcyA9IEFycmF5LmZyb20ocm9vdC5lbGVtZW50LmZpbGVzKS5tYXAoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgIGZpbGUuX3JlbGF0aXZlUGF0aCA9IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHdlIGFkZCBhIGxpdHRsZSBkZWxheSBzbyB0aGUgT1MgZmlsZSBzZWxlY3Qgd2luZG93IGNhbiBtb3ZlIG91dCBvZiB0aGUgd2F5IGJlZm9yZSB3ZSBhZGQgb3VyIGZpbGVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9hZCBmaWxlc1xuICAgICAgICAgICAgICAgIHByb3BzLm9ubG9hZChmaWxlcyk7XG5cbiAgICAgICAgICAgICAgICAvLyByZXNldCBpbnB1dCwgaXQncyBqdXN0IGZvciBleHBvc2luZyBhIG1ldGhvZCB0byBkcm9wIGZpbGVzLCBzaG91bGQgbm90IHJldGFpbiBhbnkgc3RhdGVcbiAgICAgICAgICAgICAgICByZXNldEZpbGVJbnB1dChyb290LmVsZW1lbnQpO1xuICAgICAgICAgICAgfSwgMjUwKTtcbiAgICAgICAgfTtcblxuICAgICAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcm9vdC5yZWYuaGFuZGxlQ2hhbmdlKTtcbiAgICB9O1xuXG4gICAgdmFyIHNldEFjY2VwdGVkRmlsZVR5cGVzID0gZnVuY3Rpb24gc2V0QWNjZXB0ZWRGaWxlVHlwZXMoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgICAgICBpZiAoIXJvb3QucXVlcnkoJ0dFVF9BTExPV19TWU5DX0FDQ0VQVF9BVFRSSUJVVEUnKSkgcmV0dXJuO1xuICAgICAgICBhdHRyVG9nZ2xlKFxuICAgICAgICAgICAgcm9vdC5lbGVtZW50LFxuICAgICAgICAgICAgJ2FjY2VwdCcsXG4gICAgICAgICAgICAhIWFjdGlvbi52YWx1ZSxcbiAgICAgICAgICAgIGFjdGlvbi52YWx1ZSA/IGFjdGlvbi52YWx1ZS5qb2luKCcsJykgOiAnJ1xuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgdG9nZ2xlQWxsb3dNdWx0aXBsZSA9IGZ1bmN0aW9uIHRvZ2dsZUFsbG93TXVsdGlwbGUoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgICAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ211bHRpcGxlJywgYWN0aW9uLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgdmFyIHRvZ2dsZURpcmVjdG9yeUZpbHRlciA9IGZ1bmN0aW9uIHRvZ2dsZURpcmVjdG9yeUZpbHRlcihfcmVmNCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAnd2Via2l0ZGlyZWN0b3J5JywgYWN0aW9uLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgdmFyIHRvZ2dsZURpc2FibGVkID0gZnVuY3Rpb24gdG9nZ2xlRGlzYWJsZWQoX3JlZjUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290O1xuICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgICAgICB2YXIgZG9lc0FsbG93QnJvd3NlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0JST1dTRScpO1xuICAgICAgICB2YXIgZGlzYWJsZUZpZWxkID0gaXNEaXNhYmxlZCB8fCAhZG9lc0FsbG93QnJvd3NlO1xuICAgICAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ2Rpc2FibGVkJywgZGlzYWJsZUZpZWxkKTtcbiAgICB9O1xuXG4gICAgdmFyIHRvZ2dsZVJlcXVpcmVkID0gZnVuY3Rpb24gdG9nZ2xlUmVxdWlyZWQoX3JlZjYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjYuYWN0aW9uO1xuICAgICAgICAvLyB3YW50IHRvIHJlbW92ZSByZXF1aXJlZCwgYWx3YXlzIHBvc3NpYmxlXG4gICAgICAgIGlmICghYWN0aW9uLnZhbHVlKSB7XG4gICAgICAgICAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ3JlcXVpcmVkJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdhbnQgdG8gbWFrZSByZXF1aXJlZCwgb25seSBwb3NzaWJsZSB3aGVuIHplcm8gaXRlbXNcbiAgICAgICAgZWxzZSBpZiAocm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJykgPT09IDApIHtcbiAgICAgICAgICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAncmVxdWlyZWQnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2V0Q2FwdHVyZU1ldGhvZCA9IGZ1bmN0aW9uIHNldENhcHR1cmVNZXRob2QoX3JlZjcpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNy5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjcuYWN0aW9uO1xuICAgICAgICBhdHRyVG9nZ2xlKFxuICAgICAgICAgICAgcm9vdC5lbGVtZW50LFxuICAgICAgICAgICAgJ2NhcHR1cmUnLFxuICAgICAgICAgICAgISFhY3Rpb24udmFsdWUsXG4gICAgICAgICAgICBhY3Rpb24udmFsdWUgPT09IHRydWUgPyAnJyA6IGFjdGlvbi52YWx1ZVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlUmVxdWlyZWRTdGF0dXMgPSBmdW5jdGlvbiB1cGRhdGVSZXF1aXJlZFN0YXR1cyhfcmVmOCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY4LnJvb3Q7XG4gICAgICAgIHZhciBlbGVtZW50ID0gcm9vdC5lbGVtZW50O1xuICAgICAgICAvLyBhbHdheXMgcmVtb3ZlIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUgd2hlbiBtb3JlIHRoYW4gemVybyBpdGVtc1xuICAgICAgICBpZiAocm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJykgPiAwKSB7XG4gICAgICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICdyZXF1aXJlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ25hbWUnLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBhZGQgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ25hbWUnLCB0cnVlLCByb290LnF1ZXJ5KCdHRVRfTkFNRScpKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGFueSB2YWxpZGF0aW9uIG1lc3NhZ2VzXG4gICAgICAgICAgICB2YXIgc2hvdWxkQ2hlY2tWYWxpZGl0eSA9IHJvb3QucXVlcnkoJ0dFVF9DSEVDS19WQUxJRElUWScpO1xuICAgICAgICAgICAgaWYgKHNob3VsZENoZWNrVmFsaWRpdHkpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEN1c3RvbVZhbGlkaXR5KCcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2Ugb25seSBhZGQgcmVxdWlyZWQgaWYgdGhlIGZpZWxkIGhhcyBiZWVuIGRlZW1lZCByZXF1aXJlZFxuICAgICAgICAgICAgaWYgKHJvb3QucXVlcnkoJ0dFVF9SRVFVSVJFRCcpKSB7XG4gICAgICAgICAgICAgICAgYXR0clRvZ2dsZShlbGVtZW50LCAncmVxdWlyZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlRmllbGRWYWxpZGl0eVN0YXR1cyA9IGZ1bmN0aW9uIHVwZGF0ZUZpZWxkVmFsaWRpdHlTdGF0dXMoX3JlZjkpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmOS5yb290O1xuICAgICAgICB2YXIgc2hvdWxkQ2hlY2tWYWxpZGl0eSA9IHJvb3QucXVlcnkoJ0dFVF9DSEVDS19WQUxJRElUWScpO1xuICAgICAgICBpZiAoIXNob3VsZENoZWNrVmFsaWRpdHkpIHJldHVybjtcbiAgICAgICAgcm9vdC5lbGVtZW50LnNldEN1c3RvbVZhbGlkaXR5KHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9JTlZBTElEX0ZJRUxEJykpO1xuICAgIH07XG5cbiAgICB2YXIgYnJvd3NlciA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICB0YWc6ICdpbnB1dCcsXG4gICAgICAgIG5hbWU6ICdicm93c2VyJyxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgdHlwZTogJ2ZpbGUnLFxuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJGEsXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koX3JlZjEwKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWYxMC5yb290O1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJvb3QucmVmLmhhbmRsZUNoYW5nZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICAgICAgICBESURfTE9BRF9JVEVNOiB1cGRhdGVSZXF1aXJlZFN0YXR1cyxcbiAgICAgICAgICAgIERJRF9SRU1PVkVfSVRFTTogdXBkYXRlUmVxdWlyZWRTdGF0dXMsXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiB1cGRhdGVGaWVsZFZhbGlkaXR5U3RhdHVzLFxuXG4gICAgICAgICAgICBESURfU0VUX0RJU0FCTEVEOiB0b2dnbGVEaXNhYmxlZCxcbiAgICAgICAgICAgIERJRF9TRVRfQUxMT1dfQlJPV1NFOiB0b2dnbGVEaXNhYmxlZCxcbiAgICAgICAgICAgIERJRF9TRVRfQUxMT1dfRElSRUNUT1JJRVNfT05MWTogdG9nZ2xlRGlyZWN0b3J5RmlsdGVyLFxuICAgICAgICAgICAgRElEX1NFVF9BTExPV19NVUxUSVBMRTogdG9nZ2xlQWxsb3dNdWx0aXBsZSxcbiAgICAgICAgICAgIERJRF9TRVRfQUNDRVBURURfRklMRV9UWVBFUzogc2V0QWNjZXB0ZWRGaWxlVHlwZXMsXG4gICAgICAgICAgICBESURfU0VUX0NBUFRVUkVfTUVUSE9EOiBzZXRDYXB0dXJlTWV0aG9kLFxuICAgICAgICAgICAgRElEX1NFVF9SRVFVSVJFRDogdG9nZ2xlUmVxdWlyZWQsXG4gICAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgdmFyIEtleSA9IHtcbiAgICAgICAgRU5URVI6IDEzLFxuICAgICAgICBTUEFDRTogMzIsXG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkYiA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgbGFiZWwgYW5kIGxpbmsgaXQgdG8gdGhlIGZpbGUgYnJvd3NlclxuICAgICAgICB2YXIgbGFiZWwgPSBjcmVhdGVFbGVtZW50JDEoJ2xhYmVsJyk7XG4gICAgICAgIGF0dHIobGFiZWwsICdmb3InLCAnZmlsZXBvbmQtLWJyb3dzZXItJyArIHByb3BzLmlkKTtcblxuICAgICAgICAvLyB1c2UgZm9yIGxhYmVsaW5nIGZpbGUgaW5wdXQgKGFyaWEtbGFiZWxsZWRieSBvbiBmaWxlIGlucHV0KVxuICAgICAgICBhdHRyKGxhYmVsLCAnaWQnLCAnZmlsZXBvbmQtLWRyb3AtbGFiZWwtJyArIHByb3BzLmlkKTtcblxuICAgICAgICAvLyBoaWRlIHRoZSBsYWJlbCBmb3Igc2NyZWVucmVhZGVycywgdGhlIGlucHV0IGVsZW1lbnQgd2lsbCByZWFkIHRoZSBjb250ZW50cyBvZiB0aGUgbGFiZWwgd2hlbiBpdCdzIGZvY3Vzc2VkLiBJZiB3ZSBkb24ndCBzZXQgYXJpYS1oaWRkZW4gdGhlIHNjcmVlbnJlYWRlciB3aWxsIGFsc28gbmF2aWdhdGUgdGhlIGNvbnRlbnRzIG9mIHRoZSBsYWJlbCBzZXBhcmF0ZWx5IGZyb20gdGhlIGlucHV0LlxuICAgICAgICBhdHRyKGxhYmVsLCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIC8vIGhhbmRsZSBrZXlzXG4gICAgICAgIHJvb3QucmVmLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgaXNBY3RpdmF0aW9uS2V5ID0gZS5rZXlDb2RlID09PSBLZXkuRU5URVIgfHwgZS5rZXlDb2RlID09PSBLZXkuU1BBQ0U7XG4gICAgICAgICAgICBpZiAoIWlzQWN0aXZhdGlvbktleSkgcmV0dXJuO1xuICAgICAgICAgICAgLy8gc3RvcHMgZnJvbSB0cmlnZ2VyaW5nIHRoZSBlbGVtZW50IGEgc2Vjb25kIHRpbWVcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgLy8gY2xpY2sgbGluayAod2lsbCB0aGVuIGluIHR1cm4gYWN0aXZhdGUgZmlsZSBpbnB1dClcbiAgICAgICAgICAgIHJvb3QucmVmLmxhYmVsLmNsaWNrKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcm9vdC5yZWYuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgaXNMYWJlbENsaWNrID0gZS50YXJnZXQgPT09IGxhYmVsIHx8IGxhYmVsLmNvbnRhaW5zKGUudGFyZ2V0KTtcblxuICAgICAgICAgICAgLy8gZG9uJ3Qgd2FudCB0byBjbGljayB0d2ljZVxuICAgICAgICAgICAgaWYgKGlzTGFiZWxDbGljaykgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBjbGljayBsaW5rICh3aWxsIHRoZW4gaW4gdHVybiBhY3RpdmF0ZSBmaWxlIGlucHV0KVxuICAgICAgICAgICAgcm9vdC5yZWYubGFiZWwuY2xpY2soKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhdHRhY2ggZXZlbnRzXG4gICAgICAgIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCByb290LnJlZi5oYW5kbGVLZXlEb3duKTtcbiAgICAgICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuXG4gICAgICAgIC8vIHVwZGF0ZVxuICAgICAgICB1cGRhdGVMYWJlbFZhbHVlKGxhYmVsLCBwcm9wcy5jYXB0aW9uKTtcblxuICAgICAgICAvLyBhZGQhXG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICByb290LnJlZi5sYWJlbCA9IGxhYmVsO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlTGFiZWxWYWx1ZSA9IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsVmFsdWUobGFiZWwsIHZhbHVlKSB7XG4gICAgICAgIGxhYmVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICB2YXIgY2xpY2thYmxlID0gbGFiZWwucXVlcnlTZWxlY3RvcignLmZpbGVwb25kLS1sYWJlbC1hY3Rpb24nKTtcbiAgICAgICAgaWYgKGNsaWNrYWJsZSkge1xuICAgICAgICAgICAgYXR0cihjbGlja2FibGUsICd0YWJpbmRleCcsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICB2YXIgZHJvcExhYmVsID0gY3JlYXRlVmlldyh7XG4gICAgICAgIG5hbWU6ICdkcm9wLWxhYmVsJyxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkYixcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShfcmVmMikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290O1xuICAgICAgICAgICAgcm9vdC5yZWYubGFiZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHJvb3QucmVmLmhhbmRsZUtleURvd24pO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICAgICAgRElEX1NFVF9MQUJFTF9JRExFOiBmdW5jdGlvbiBESURfU0VUX0xBQkVMX0lETEUoX3JlZjMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICAgICAgICAgICAgICB1cGRhdGVMYWJlbFZhbHVlKHJvb3QucmVmLmxhYmVsLCBhY3Rpb24udmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksXG5cbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBzdHlsZXM6IFsnb3BhY2l0eScsICd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAxNTAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYOiAnc3ByaW5nJyxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgYmxvYiA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBuYW1lOiAnZHJpcC1ibG9iJyxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eSddLFxuICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgIHNjYWxlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgc2NhbGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYOiAnc3ByaW5nJyxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAyNTAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgYWRkQmxvYiA9IGZ1bmN0aW9uIGFkZEJsb2IoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcbiAgICAgICAgdmFyIGNlbnRlclggPSByb290LnJlY3QuZWxlbWVudC53aWR0aCAqIDAuNTtcbiAgICAgICAgdmFyIGNlbnRlclkgPSByb290LnJlY3QuZWxlbWVudC5oZWlnaHQgKiAwLjU7XG5cbiAgICAgICAgcm9vdC5yZWYuYmxvYiA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoYmxvYiwge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgc2NhbGVYOiAyLjUsXG4gICAgICAgICAgICAgICAgc2NhbGVZOiAyLjUsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiBjZW50ZXJZLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIG1vdmVCbG9iID0gZnVuY3Rpb24gbW92ZUJsb2IoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgICAgICBpZiAoIXJvb3QucmVmLmJsb2IpIHtcbiAgICAgICAgICAgIGFkZEJsb2IoeyByb290OiByb290IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdC5yZWYuYmxvYi50cmFuc2xhdGVYID0gYWN0aW9uLnBvc2l0aW9uLnNjb3BlTGVmdDtcbiAgICAgICAgcm9vdC5yZWYuYmxvYi50cmFuc2xhdGVZID0gYWN0aW9uLnBvc2l0aW9uLnNjb3BlVG9wO1xuICAgICAgICByb290LnJlZi5ibG9iLnNjYWxlWCA9IDE7XG4gICAgICAgIHJvb3QucmVmLmJsb2Iuc2NhbGVZID0gMTtcbiAgICAgICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMTtcbiAgICB9O1xuXG4gICAgdmFyIGhpZGVCbG9iID0gZnVuY3Rpb24gaGlkZUJsb2IoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290O1xuICAgICAgICBpZiAoIXJvb3QucmVmLmJsb2IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByb290LnJlZi5ibG9iLm9wYWNpdHkgPSAwO1xuICAgIH07XG5cbiAgICB2YXIgZXhwbG9kZUJsb2IgPSBmdW5jdGlvbiBleHBsb2RlQmxvYihfcmVmNCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3Q7XG4gICAgICAgIGlmICghcm9vdC5yZWYuYmxvYikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QucmVmLmJsb2Iuc2NhbGVYID0gMi41O1xuICAgICAgICByb290LnJlZi5ibG9iLnNjYWxlWSA9IDIuNTtcbiAgICAgICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMDtcbiAgICB9O1xuXG4gICAgdmFyIHdyaXRlJDcgPSBmdW5jdGlvbiB3cml0ZShfcmVmNSkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWY1LnByb3BzLFxuICAgICAgICAgICAgYWN0aW9ucyA9IF9yZWY1LmFjdGlvbnM7XG4gICAgICAgIHJvdXRlJDQoeyByb290OiByb290LCBwcm9wczogcHJvcHMsIGFjdGlvbnM6IGFjdGlvbnMgfSk7XG4gICAgICAgIHZhciBibG9iID0gcm9vdC5yZWYuYmxvYjtcblxuICAgICAgICBpZiAoYWN0aW9ucy5sZW5ndGggPT09IDAgJiYgYmxvYiAmJiBibG9iLm9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KGJsb2IpO1xuICAgICAgICAgICAgcm9vdC5yZWYuYmxvYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJvdXRlJDQgPSBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9EUkFHOiBtb3ZlQmxvYixcbiAgICAgICAgRElEX0RST1A6IGV4cGxvZGVCbG9iLFxuICAgICAgICBESURfRU5EX0RSQUc6IGhpZGVCbG9iLFxuICAgIH0pO1xuXG4gICAgdmFyIGRyaXAgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgbmFtZTogJ2RyaXAnLFxuICAgICAgICB3cml0ZTogd3JpdGUkNyxcbiAgICB9KTtcblxuICAgIHZhciBzZXRJbnB1dEZpbGVzID0gZnVuY3Rpb24gc2V0SW5wdXRGaWxlcyhlbGVtZW50LCBmaWxlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgRGF0YVRyYW5zZmVyIGluc3RhbmNlIGFuZCBhZGQgYSBuZXdseSBjcmVhdGVkIGZpbGVcbiAgICAgICAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBuZXcgRGF0YVRyYW5zZmVyKCk7XG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRyYW5zZmVyLml0ZW1zLmFkZChmaWxlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhVHJhbnNmZXIuaXRlbXMuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEZpbGUoW2ZpbGVdLCBmaWxlLm5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBc3NpZ24gdGhlIERhdGFUcmFuc2ZlciBmaWxlcyBsaXN0IHRvIHRoZSBmaWxlIGlucHV0XG4gICAgICAgICAgICBlbGVtZW50LmZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZSRjID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3Q7XG4gICAgICAgIHJldHVybiAocm9vdC5yZWYuZmllbGRzID0ge30pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RmllbGQgPSBmdW5jdGlvbiBnZXRGaWVsZChyb290LCBpZCkge1xuICAgICAgICByZXR1cm4gcm9vdC5yZWYuZmllbGRzW2lkXTtcbiAgICB9O1xuXG4gICAgdmFyIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyA9IGZ1bmN0aW9uIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyhyb290KSB7XG4gICAgICAgIHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICghcm9vdC5yZWYuZmllbGRzW2l0ZW0uaWRdKSByZXR1cm47XG4gICAgICAgICAgICByb290LmVsZW1lbnQuYXBwZW5kQ2hpbGQocm9vdC5yZWYuZmllbGRzW2l0ZW0uaWRdKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBkaWRSZW9yZGVySXRlbXMgPSBmdW5jdGlvbiBkaWRSZW9yZGVySXRlbXMoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290O1xuICAgICAgICByZXR1cm4gc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpO1xuICAgIH07XG5cbiAgICB2YXIgZGlkQWRkSXRlbSA9IGZ1bmN0aW9uIGRpZEFkZEl0ZW0oX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgICAgICB2YXIgZmlsZUl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgICAgIHZhciBpc0xvY2FsRmlsZSA9IGZpbGVJdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTDtcbiAgICAgICAgdmFyIHNob3VsZFVzZUZpbGVJbnB1dCA9ICFpc0xvY2FsRmlsZSAmJiByb290LnF1ZXJ5KCdTSE9VTERfVVBEQVRFX0ZJTEVfSU5QVVQnKTtcbiAgICAgICAgdmFyIGRhdGFDb250YWluZXIgPSBjcmVhdGVFbGVtZW50JDEoJ2lucHV0Jyk7XG4gICAgICAgIGRhdGFDb250YWluZXIudHlwZSA9IHNob3VsZFVzZUZpbGVJbnB1dCA/ICdmaWxlJyA6ICdoaWRkZW4nO1xuICAgICAgICBkYXRhQ29udGFpbmVyLm5hbWUgPSByb290LnF1ZXJ5KCdHRVRfTkFNRScpO1xuICAgICAgICBkYXRhQ29udGFpbmVyLmRpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgICAgIHJvb3QucmVmLmZpZWxkc1thY3Rpb24uaWRdID0gZGF0YUNvbnRhaW5lcjtcbiAgICAgICAgc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpO1xuICAgIH07XG5cbiAgICB2YXIgZGlkTG9hZEl0ZW0kMSA9IGZ1bmN0aW9uIGRpZExvYWRJdGVtKF9yZWY0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY0LmFjdGlvbjtcbiAgICAgICAgdmFyIGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICAgICAgaWYgKCFmaWVsZCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHN0b3JlIHNlcnZlciByZWYgaW4gaGlkZGVuIGlucHV0XG4gICAgICAgIGlmIChhY3Rpb24uc2VydmVyRmlsZVJlZmVyZW5jZSAhPT0gbnVsbCkgZmllbGQudmFsdWUgPSBhY3Rpb24uc2VydmVyRmlsZVJlZmVyZW5jZTtcblxuICAgICAgICAvLyBzdG9yZSBmaWxlIGl0ZW0gaW4gZmlsZSBpbnB1dFxuICAgICAgICBpZiAoIXJvb3QucXVlcnkoJ1NIT1VMRF9VUERBVEVfRklMRV9JTlBVVCcpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGZpbGVJdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgICAgICBzZXRJbnB1dEZpbGVzKGZpZWxkLCBbZmlsZUl0ZW0uZmlsZV0pO1xuICAgIH07XG5cbiAgICB2YXIgZGlkUHJlcGFyZU91dHB1dCA9IGZ1bmN0aW9uIGRpZFByZXBhcmVPdXRwdXQoX3JlZjUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjUuYWN0aW9uO1xuICAgICAgICAvLyB0aGlzIHRpbWVvdXQgcHVzaGVzIHRoZSBoYW5kbGVyIGFmdGVyICdsb2FkJ1xuICAgICAgICBpZiAoIXJvb3QucXVlcnkoJ1NIT1VMRF9VUERBVEVfRklMRV9JTlBVVCcpKSByZXR1cm47XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBnZXRGaWVsZChyb290LCBhY3Rpb24uaWQpO1xuICAgICAgICAgICAgaWYgKCFmaWVsZCkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0SW5wdXRGaWxlcyhmaWVsZCwgW2FjdGlvbi5maWxlXSk7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG5cbiAgICB2YXIgZGlkU2V0RGlzYWJsZWQgPSBmdW5jdGlvbiBkaWRTZXREaXNhYmxlZChfcmVmNikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3Q7XG4gICAgICAgIHJvb3QuZWxlbWVudC5kaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgIH07XG5cbiAgICB2YXIgZGlkUmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIGRpZFJlbW92ZUl0ZW0oX3JlZjcpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNy5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjcuYWN0aW9uO1xuICAgICAgICB2YXIgZmllbGQgPSBnZXRGaWVsZChyb290LCBhY3Rpb24uaWQpO1xuICAgICAgICBpZiAoIWZpZWxkKSByZXR1cm47XG4gICAgICAgIGlmIChmaWVsZC5wYXJlbnROb2RlKSBmaWVsZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZpZWxkKTtcbiAgICAgICAgZGVsZXRlIHJvb3QucmVmLmZpZWxkc1thY3Rpb24uaWRdO1xuICAgIH07XG5cbiAgICAvLyBvbmx5IHJ1bnMgZm9yIHNlcnZlciBmaWxlcy4gd2lsbCByZWZ1c2UgdG8gdXBkYXRlIHRoZSB2YWx1ZSBpZiB0aGUgZmllbGRcbiAgICAvLyBpcyBhIGZpbGUgZmllbGRcbiAgICB2YXIgZGlkRGVmaW5lVmFsdWUgPSBmdW5jdGlvbiBkaWREZWZpbmVWYWx1ZShfcmVmOCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY4LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmOC5hY3Rpb247XG4gICAgICAgIHZhciBmaWVsZCA9IGdldEZpZWxkKHJvb3QsIGFjdGlvbi5pZCk7XG4gICAgICAgIGlmICghZmllbGQpIHJldHVybjtcbiAgICAgICAgaWYgKGFjdGlvbi52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY2xlYXIgZmllbGQgdmFsdWVcbiAgICAgICAgICAgIGZpZWxkLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNldCBmaWVsZCB2YWx1ZVxuICAgICAgICAgICAgaWYgKGZpZWxkLnR5cGUgIT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICAgICAgZmllbGQudmFsdWUgPSBhY3Rpb24udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpO1xuICAgIH07XG5cbiAgICB2YXIgd3JpdGUkOCA9IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX1NFVF9ESVNBQkxFRDogZGlkU2V0RGlzYWJsZWQsXG4gICAgICAgIERJRF9BRERfSVRFTTogZGlkQWRkSXRlbSxcbiAgICAgICAgRElEX0xPQURfSVRFTTogZGlkTG9hZEl0ZW0kMSxcbiAgICAgICAgRElEX1JFTU9WRV9JVEVNOiBkaWRSZW1vdmVJdGVtLFxuICAgICAgICBESURfREVGSU5FX1ZBTFVFOiBkaWREZWZpbmVWYWx1ZSxcbiAgICAgICAgRElEX1BSRVBBUkVfT1VUUFVUOiBkaWRQcmVwYXJlT3V0cHV0LFxuICAgICAgICBESURfUkVPUkRFUl9JVEVNUzogZGlkUmVvcmRlckl0ZW1zLFxuICAgICAgICBESURfU09SVF9JVEVNUzogZGlkUmVvcmRlckl0ZW1zLFxuICAgIH0pO1xuXG4gICAgdmFyIGRhdGEgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgdGFnOiAnZmllbGRzZXQnLFxuICAgICAgICBuYW1lOiAnZGF0YScsXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJGMsXG4gICAgICAgIHdyaXRlOiB3cml0ZSQ4LFxuICAgICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIH0pO1xuXG4gICAgdmFyIGdldFJvb3ROb2RlID0gZnVuY3Rpb24gZ2V0Um9vdE5vZGUoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gJ2dldFJvb3ROb2RlJyBpbiBlbGVtZW50ID8gZWxlbWVudC5nZXRSb290Tm9kZSgpIDogZG9jdW1lbnQ7XG4gICAgfTtcblxuICAgIHZhciBpbWFnZXMgPSBbJ2pwZycsICdqcGVnJywgJ3BuZycsICdnaWYnLCAnYm1wJywgJ3dlYnAnLCAnc3ZnJywgJ3RpZmYnXTtcbiAgICB2YXIgdGV4dCQxID0gWydjc3MnLCAnY3N2JywgJ2h0bWwnLCAndHh0J107XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgICAgemlwOiAnemlwfGNvbXByZXNzZWQnLFxuICAgICAgICBlcHViOiAnYXBwbGljYXRpb24vZXB1Yit6aXAnLFxuICAgIH07XG5cbiAgICB2YXIgZ3Vlc3N0aW1hdGVNaW1lVHlwZSA9IGZ1bmN0aW9uIGd1ZXNzdGltYXRlTWltZVR5cGUoKSB7XG4gICAgICAgIHZhciBleHRlbnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGltYWdlcy5pbmNsdWRlcyhleHRlbnNpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICdpbWFnZS8nICtcbiAgICAgICAgICAgICAgICAoZXh0ZW5zaW9uID09PSAnanBnJyA/ICdqcGVnJyA6IGV4dGVuc2lvbiA9PT0gJ3N2ZycgPyAnc3ZnK3htbCcgOiBleHRlbnNpb24pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0JDEuaW5jbHVkZXMoZXh0ZW5zaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuICd0ZXh0LycgKyBleHRlbnNpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwW2V4dGVuc2lvbl0gfHwgJyc7XG4gICAgfTtcblxuICAgIHZhciByZXF1ZXN0RGF0YVRyYW5zZmVySXRlbXMgPSBmdW5jdGlvbiByZXF1ZXN0RGF0YVRyYW5zZmVySXRlbXMoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIHRyeSB0byBnZXQgbGlua3MgZnJvbSB0cmFuc2ZlciwgaWYgZm91bmQgd2UnbGwgZXhpdCBpbW1lZGlhdGVseSAodW5sZXNzIGEgZmlsZSBpcyBpbiB0aGUgZGF0YVRyYW5zZmVyIGFzIHdlbGwsIHRoaXMgaXMgYmVjYXVzZSBGaXJlZm94IGNvdWxkIHJlcHJlc2VudCB0aGUgZmlsZSBhcyBhIFVSTCBhbmQgYSBmaWxlIG9iamVjdCBhdCB0aGUgc2FtZSB0aW1lKVxuICAgICAgICAgICAgdmFyIGxpbmtzID0gZ2V0TGlua3MoZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGggJiYgIWhhc0ZpbGVzKGRhdGFUcmFuc2ZlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShsaW5rcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cnkgdG8gZ2V0IGZpbGVzIGZyb20gdGhlIHRyYW5zZmVyXG4gICAgICAgICAgICBnZXRGaWxlcyhkYXRhVHJhbnNmZXIpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGRhdGF0cmFuc2ZlciBoYXMgZmlsZXNcbiAgICAgKi9cbiAgICB2YXIgaGFzRmlsZXMgPSBmdW5jdGlvbiBoYXNGaWxlcyhkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgaWYgKGRhdGFUcmFuc2Zlci5maWxlcykgcmV0dXJuIGRhdGFUcmFuc2Zlci5maWxlcy5sZW5ndGggPiAwO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGZpbGVzIGZyb20gYSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gICAgICovXG4gICAgdmFyIGdldEZpbGVzID0gZnVuY3Rpb24gZ2V0RmlsZXMoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgdHJhbnNmZXIgaXRlbXMgYXMgcHJvbWlzZXNcbiAgICAgICAgICAgIHZhciBwcm9taXNlZEZpbGVzID0gKGRhdGFUcmFuc2Zlci5pdGVtcyA/IEFycmF5LmZyb20oZGF0YVRyYW5zZmVyLml0ZW1zKSA6IFtdKVxuICAgICAgICAgICAgICAgIC8vIG9ubHkga2VlcCBmaWxlIHN5c3RlbSBpdGVtcyAoZmlsZXMgYW5kIGRpcmVjdG9yaWVzKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaWxlU3lzdGVtSXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgLy8gbWFwIGVhY2ggaXRlbSB0byBwcm9taXNlXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRGaWxlc0Zyb21JdGVtKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBpZiBpcyBlbXB0eSwgc2VlIGlmIHdlIGNhbiBleHRyYWN0IHNvbWUgaW5mbyBmcm9tIHRoZSBmaWxlcyBwcm9wZXJ0eSBhcyBhIGZhbGxiYWNrXG4gICAgICAgICAgICBpZiAoIXByb21pc2VkRmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGVzdCBmb3IgZGlyZWN0b3JpZXMgKHNob3VsZCBub3QgYmUgYWxsb3dlZClcbiAgICAgICAgICAgICAgICAvLyBVc2UgRmlsZVJlYWRlciwgcHJvYmxlbSBpcyB0aGF0IHRoZSBmaWxlcyBwcm9wZXJ0eSBnZXRzIGxvc3QgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGFUcmFuc2Zlci5maWxlcyA/IEFycmF5LmZyb20oZGF0YVRyYW5zZmVyLmZpbGVzKSA6IFtdKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvbmUhXG4gICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlZEZpbGVzKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJldHVybmVkRmlsZUdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBmbGF0dGVuIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWRGaWxlR3JvdXBzLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2guYXBwbHkoZmlsZXMsIGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uZSAoZmlsdGVyIG91dCBlbXB0eSBmaWxlcykhXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGUuX3JlbGF0aXZlUGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuX3JlbGF0aXZlUGF0aCA9IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRmlsZVN5c3RlbUl0ZW0gPSBmdW5jdGlvbiBpc0ZpbGVTeXN0ZW1JdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYgKGlzRW50cnkoaXRlbSkpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGdldEFzRW50cnkoaXRlbSk7XG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuaXNGaWxlIHx8IGVudHJ5LmlzRGlyZWN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLmtpbmQgPT09ICdmaWxlJztcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVzRnJvbUl0ZW0gPSBmdW5jdGlvbiBnZXRGaWxlc0Zyb21JdGVtKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKGlzRGlyZWN0b3J5RW50cnkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBnZXRGaWxlc0luRGlyZWN0b3J5KGdldEFzRW50cnkoaXRlbSkpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShbaXRlbS5nZXRBc0ZpbGUoKV0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVzSW5EaXJlY3RvcnkgPSBmdW5jdGlvbiBnZXRGaWxlc0luRGlyZWN0b3J5KGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBmaWxlcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyB0aGUgdG90YWwgZW50cmllcyB0byByZWFkXG4gICAgICAgICAgICB2YXIgZGlyQ291bnRlciA9IDA7XG4gICAgICAgICAgICB2YXIgZmlsZUNvdW50ZXIgPSAwO1xuXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZUlmRG9uZSA9IGZ1bmN0aW9uIHJlc29sdmVJZkRvbmUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVDb3VudGVyID09PSAwICYmIGRpckNvdW50ZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmaWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gdGhlIHJlY3Vyc2l2ZSBmdW5jdGlvblxuICAgICAgICAgICAgdmFyIHJlYWRFbnRyaWVzID0gZnVuY3Rpb24gcmVhZEVudHJpZXMoZGlyRW50cnkpIHtcbiAgICAgICAgICAgICAgICBkaXJDb3VudGVyKys7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0b3J5UmVhZGVyID0gZGlyRW50cnkuY3JlYXRlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBkaXJlY3RvcmllcyBhcmUgcmV0dXJuZWQgaW4gYmF0Y2hlcywgd2UgbmVlZCB0byBwcm9jZXNzIGFsbCBiYXRjaGVzIGJlZm9yZSB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgdmFyIHJlYWRCYXRjaCA9IGZ1bmN0aW9uIHJlYWRCYXRjaCgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5UmVhZGVyLnJlYWRFbnRyaWVzKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpckNvdW50ZXItLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWZEb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSByZWFkIG1vcmUgZGlyZWN0b3JpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgYXMgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlQ291bnRlcisrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmZpbGUoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvcnJlY3RlZEZpbGUgPSBjb3JyZWN0TWlzc2luZ0ZpbGVUeXBlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmZ1bGxQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlY3RlZEZpbGUuX3JlbGF0aXZlUGF0aCA9IGVudHJ5LmZ1bGxQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaChjb3JyZWN0ZWRGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVDb3VudGVyLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWZEb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gZ2V0IG5leHQgYmF0Y2ggb2YgZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRCYXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyByZWFkIGZpcnN0IGJhdGNoIG9mIGZpbGVzXG4gICAgICAgICAgICAgICAgcmVhZEJhdGNoKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBnbyFcbiAgICAgICAgICAgIHJlYWRFbnRyaWVzKGVudHJ5KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjb3JyZWN0TWlzc2luZ0ZpbGVUeXBlID0gZnVuY3Rpb24gY29ycmVjdE1pc3NpbmdGaWxlVHlwZShmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLnR5cGUubGVuZ3RoKSByZXR1cm4gZmlsZTtcbiAgICAgICAgdmFyIGRhdGUgPSBmaWxlLmxhc3RNb2RpZmllZERhdGU7XG4gICAgICAgIHZhciBuYW1lID0gZmlsZS5uYW1lO1xuICAgICAgICB2YXIgdHlwZSA9IGd1ZXNzdGltYXRlTWltZVR5cGUoZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGUubmFtZSkpO1xuICAgICAgICBpZiAoIXR5cGUubGVuZ3RoKSByZXR1cm4gZmlsZTtcbiAgICAgICAgZmlsZSA9IGZpbGUuc2xpY2UoMCwgZmlsZS5zaXplLCB0eXBlKTtcbiAgICAgICAgZmlsZS5uYW1lID0gbmFtZTtcbiAgICAgICAgZmlsZS5sYXN0TW9kaWZpZWREYXRlID0gZGF0ZTtcbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfTtcblxuICAgIHZhciBpc0RpcmVjdG9yeUVudHJ5ID0gZnVuY3Rpb24gaXNEaXJlY3RvcnlFbnRyeShpdGVtKSB7XG4gICAgICAgIHJldHVybiBpc0VudHJ5KGl0ZW0pICYmIChnZXRBc0VudHJ5KGl0ZW0pIHx8IHt9KS5pc0RpcmVjdG9yeTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRW50cnkgPSBmdW5jdGlvbiBpc0VudHJ5KGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICd3ZWJraXRHZXRBc0VudHJ5JyBpbiBpdGVtO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QXNFbnRyeSA9IGZ1bmN0aW9uIGdldEFzRW50cnkoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS53ZWJraXRHZXRBc0VudHJ5KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGxpbmtzIGZyb20gYSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gICAgICovXG4gICAgdmFyIGdldExpbmtzID0gZnVuY3Rpb24gZ2V0TGlua3MoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIHZhciBsaW5rcyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gbG9vayBpbiBtZXRhIGRhdGEgcHJvcGVydHlcbiAgICAgICAgICAgIGxpbmtzID0gZ2V0TGlua3NGcm9tVHJhbnNmZXJNZXRhRGF0YShkYXRhVHJhbnNmZXIpO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5rcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmtzID0gZ2V0TGlua3NGcm9tVHJhbnNmZXJVUkxEYXRhKGRhdGFUcmFuc2Zlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG5vcGUgbm9wZSBub3BlIChwcm9iYWJseSBJRSB0cm91YmxlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5rcztcbiAgICB9O1xuXG4gICAgdmFyIGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YSA9IGZ1bmN0aW9uIGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YShkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndXJsJyk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbZGF0YV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TGlua3NGcm9tVHJhbnNmZXJNZXRhRGF0YSA9IGZ1bmN0aW9uIGdldExpbmtzRnJvbVRyYW5zZmVyTWV0YURhdGEoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIHZhciBkYXRhID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGRhdGEubWF0Y2goL3NyY1xccyo9XFxzKlwiKC4rPylcIi8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW21hdGNoZXNbMV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYWdORHJvcE9ic2VydmVycyA9IFtdO1xuXG4gICAgdmFyIGV2ZW50UG9zaXRpb24gPSBmdW5jdGlvbiBldmVudFBvc2l0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhZ2VMZWZ0OiBlLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVRvcDogZS5wYWdlWSxcbiAgICAgICAgICAgIHNjb3BlTGVmdDogZS5vZmZzZXRYIHx8IGUubGF5ZXJYLFxuICAgICAgICAgICAgc2NvcGVUb3A6IGUub2Zmc2V0WSB8fCBlLmxheWVyWSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZURyYWdORHJvcENsaWVudCA9IGZ1bmN0aW9uIGNyZWF0ZURyYWdORHJvcENsaWVudChcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgc2NvcGVUb09ic2VydmUsXG4gICAgICAgIGZpbHRlckVsZW1lbnRcbiAgICApIHtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gZ2V0RHJhZ05Ecm9wT2JzZXJ2ZXIoc2NvcGVUb09ic2VydmUpO1xuXG4gICAgICAgIHZhciBjbGllbnQgPSB7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgZmlsdGVyRWxlbWVudDogZmlsdGVyRWxlbWVudCxcbiAgICAgICAgICAgIHN0YXRlOiBudWxsLFxuICAgICAgICAgICAgb25kcm9wOiBmdW5jdGlvbiBvbmRyb3AoKSB7fSxcbiAgICAgICAgICAgIG9uZW50ZXI6IGZ1bmN0aW9uIG9uZW50ZXIoKSB7fSxcbiAgICAgICAgICAgIG9uZHJhZzogZnVuY3Rpb24gb25kcmFnKCkge30sXG4gICAgICAgICAgICBvbmV4aXQ6IGZ1bmN0aW9uIG9uZXhpdCgpIHt9LFxuICAgICAgICAgICAgb25sb2FkOiBmdW5jdGlvbiBvbmxvYWQoKSB7fSxcbiAgICAgICAgICAgIGFsbG93ZHJvcDogZnVuY3Rpb24gYWxsb3dkcm9wKCkge30sXG4gICAgICAgIH07XG5cbiAgICAgICAgY2xpZW50LmRlc3Ryb3kgPSBvYnNlcnZlci5hZGRMaXN0ZW5lcihjbGllbnQpO1xuXG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfTtcblxuICAgIHZhciBnZXREcmFnTkRyb3BPYnNlcnZlciA9IGZ1bmN0aW9uIGdldERyYWdORHJvcE9ic2VydmVyKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gc2VlIGlmIGFscmVhZHkgZXhpc3RzLCBpZiBzbywgcmV0dXJuXG4gICAgICAgIHZhciBvYnNlcnZlciA9IGRyYWdORHJvcE9ic2VydmVycy5maW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgb2JzZXJ2ZXIsIGRvZXMgbm90IHlldCBleGlzdCBmb3IgdGhpcyBlbGVtZW50XG4gICAgICAgIHZhciBuZXdPYnNlcnZlciA9IGNyZWF0ZURyYWdORHJvcE9ic2VydmVyKGVsZW1lbnQpO1xuICAgICAgICBkcmFnTkRyb3BPYnNlcnZlcnMucHVzaChuZXdPYnNlcnZlcik7XG4gICAgICAgIHJldHVybiBuZXdPYnNlcnZlcjtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZURyYWdORHJvcE9ic2VydmVyID0gZnVuY3Rpb24gY3JlYXRlRHJhZ05Ecm9wT2JzZXJ2ZXIoZWxlbWVudCkge1xuICAgICAgICB2YXIgY2xpZW50cyA9IFtdO1xuXG4gICAgICAgIHZhciByb3V0ZXMgPSB7XG4gICAgICAgICAgICBkcmFnZW50ZXI6IGRyYWdlbnRlcixcbiAgICAgICAgICAgIGRyYWdvdmVyOiBkcmFnb3ZlcixcbiAgICAgICAgICAgIGRyYWdsZWF2ZTogZHJhZ2xlYXZlLFxuICAgICAgICAgICAgZHJvcDogZHJvcCxcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB7fTtcblxuICAgICAgICBmb3Jpbihyb3V0ZXMsIGZ1bmN0aW9uKGV2ZW50LCBjcmVhdGVIYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBjcmVhdGVIYW5kbGVyKGVsZW1lbnQsIGNsaWVudHMpO1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyc1tldmVudF0sIGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgIGFkZExpc3RlbmVyOiBmdW5jdGlvbiBhZGRMaXN0ZW5lcihjbGllbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgYXMgY2xpZW50XG4gICAgICAgICAgICAgICAgY2xpZW50cy5wdXNoKGNsaWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcmVtb3ZlTGlzdGVuZXIgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50cy5zcGxpY2UoY2xpZW50cy5pbmRleE9mKGNsaWVudCksIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vIG1vcmUgY2xpZW50cywgY2xlYW4gdXAgb2JzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnTkRyb3BPYnNlcnZlcnMuc3BsaWNlKGRyYWdORHJvcE9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKSwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmluKHJvdXRlcywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXJzW2V2ZW50XSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfTtcblxuICAgIHZhciBlbGVtZW50RnJvbVBvaW50ID0gZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludChyb290LCBwb2ludCkge1xuICAgICAgICBpZiAoISgnZWxlbWVudEZyb21Qb2ludCcgaW4gcm9vdCkpIHtcbiAgICAgICAgICAgIHJvb3QgPSBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdC5lbGVtZW50RnJvbVBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgIH07XG5cbiAgICB2YXIgaXNFdmVudFRhcmdldCA9IGZ1bmN0aW9uIGlzRXZlbnRUYXJnZXQoZSwgdGFyZ2V0KSB7XG4gICAgICAgIC8vIGdldCByb290XG4gICAgICAgIHZhciByb290ID0gZ2V0Um9vdE5vZGUodGFyZ2V0KTtcblxuICAgICAgICAvLyBnZXQgZWxlbWVudCBhdCBwb3NpdGlvblxuICAgICAgICAvLyBpZiByb290IGlzIG5vdCBhY3R1YWwgc2hhZG93IERPTSBhbmQgZG9lcyBub3QgaGF2ZSBlbGVtZW50RnJvbVBvaW50IG1ldGhvZCwgdXNlIHRoZSBvbmUgb24gZG9jdW1lbnRcbiAgICAgICAgdmFyIGVsZW1lbnRBdFBvc2l0aW9uID0gZWxlbWVudEZyb21Qb2ludChyb290LCB7XG4gICAgICAgICAgICB4OiBlLnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgeTogZS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGVzdCBpZiB0YXJnZXQgaXMgdGhlIGVsZW1lbnQgb3IgaWYgb25lIG9mIGl0cyBjaGlsZHJlbiBpc1xuICAgICAgICByZXR1cm4gZWxlbWVudEF0UG9zaXRpb24gPT09IHRhcmdldCB8fCB0YXJnZXQuY29udGFpbnMoZWxlbWVudEF0UG9zaXRpb24pO1xuICAgIH07XG5cbiAgICB2YXIgaW5pdGlhbFRhcmdldCA9IG51bGw7XG5cbiAgICB2YXIgc2V0RHJvcEVmZmVjdCA9IGZ1bmN0aW9uIHNldERyb3BFZmZlY3QoZGF0YVRyYW5zZmVyLCBlZmZlY3QpIHtcbiAgICAgICAgLy8gaXMgaW4gdHJ5IGNhdGNoIGFzIElFMTEgd2lsbCB0aHJvdyBlcnJvciBpZiBub3RcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gZWZmZWN0O1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH07XG5cbiAgICB2YXIgZHJhZ2VudGVyID0gZnVuY3Rpb24gZHJhZ2VudGVyKHJvb3QsIGNsaWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaW5pdGlhbFRhcmdldCA9IGUudGFyZ2V0O1xuXG4gICAgICAgICAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBjbGllbnQuZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgb25lbnRlciA9IGNsaWVudC5vbmVudGVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRXZlbnRUYXJnZXQoZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gJ2VudGVyJztcblxuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlIGVudGVyIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIG9uZW50ZXIoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBkcmFnb3ZlciA9IGZ1bmN0aW9uIGRyYWdvdmVyKHJvb3QsIGNsaWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuXG4gICAgICAgICAgICByZXF1ZXN0RGF0YVRyYW5zZmVySXRlbXMoZGF0YVRyYW5zZmVyKS50aGVuKGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJEcm9wVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBjbGllbnRzLnNvbWUoZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJFbGVtZW50ID0gY2xpZW50LmZpbHRlckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gY2xpZW50LmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVudGVyID0gY2xpZW50Lm9uZW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmV4aXQgPSBjbGllbnQub25leGl0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25kcmFnID0gY2xpZW50Lm9uZHJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZHJvcCA9IGNsaWVudC5hbGxvd2Ryb3A7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCB3ZSBjYW4gZHJvcFxuICAgICAgICAgICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ2NvcHknKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyB0cmFuc2ZlciBvZiB0aGVzZSBpdGVtc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxsb3dzVHJhbnNmZXIgPSBhbGxvd2Ryb3AoaXRlbXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgdXNlZCB3aGVuIGNhbiBiZSBkcm9wcGVkIG9uIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd3NUcmFuc2Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdub25lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXR0aW5nIHRoaXMgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0V2ZW50VGFyZ2V0KGUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyRHJvcFRhcmdldCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhZCBubyBwcmV2aW91cyBzdGF0ZSwgbWVhbnMgd2UgYXJlIGVudGVyaW5nIHRoaXMgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50LnN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gJ2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVudGVyKGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IG92ZXIgZWxlbWVudCAobm8gbWF0dGVyIGlmIGl0IGFsbG93cyB0aGUgZHJvcCBvciBub3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQuc3RhdGUgPSAnb3Zlcic7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRvIGFsbG93IHRyYW5zZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCAmJiAhYWxsb3dzVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmRyYWcoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgb3ZlciBhbiBlbGVtZW50IHRvIGRyb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJFbGVtZW50ICYmICFvdmVyRHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldERyb3BFZmZlY3QoZGF0YVRyYW5zZmVyLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtaWdodCBoYXZlIGp1c3QgbGVmdCB0aGlzIGNsaWVudD9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQuc3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXhpdChldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBkcm9wID0gZnVuY3Rpb24gZHJvcChyb290LCBjbGllbnRzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcblxuICAgICAgICAgICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2ZlcikudGhlbihmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgIGNsaWVudHMuZm9yRWFjaChmdW5jdGlvbihjbGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlckVsZW1lbnQgPSBjbGllbnQuZmlsdGVyRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBjbGllbnQuZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZHJvcCA9IGNsaWVudC5vbmRyb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmV4aXQgPSBjbGllbnQub25leGl0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dkcm9wID0gY2xpZW50LmFsbG93ZHJvcDtcblxuICAgICAgICAgICAgICAgICAgICBjbGllbnQuc3RhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZpbHRlcmluZyBvbiBlbGVtZW50IHdlIG5lZWQgdG8gYmUgb3ZlciB0aGUgZWxlbWVudCB0byBkcm9wXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJFbGVtZW50ICYmICFpc0V2ZW50VGFyZ2V0KGUsIGVsZW1lbnQpKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gdHJhbnNmZXIgZm9yIHRoaXMgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dkcm9wKGl0ZW1zKSkgcmV0dXJuIG9uZXhpdChldmVudFBvc2l0aW9uKGUpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gZHJvcCB0aGVzZSBpdGVtcyBvbiB0aGlzIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICBvbmRyb3AoZXZlbnRQb3NpdGlvbihlKSwgaXRlbXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBkcmFnbGVhdmUgPSBmdW5jdGlvbiBkcmFnbGVhdmUocm9vdCwgY2xpZW50cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGluaXRpYWxUYXJnZXQgIT09IGUudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uZXhpdCA9IGNsaWVudC5vbmV4aXQ7XG5cbiAgICAgICAgICAgICAgICBjbGllbnQuc3RhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgb25leGl0KGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVIb3BwZXIgPSBmdW5jdGlvbiBjcmVhdGVIb3BwZXIoc2NvcGUsIHZhbGlkYXRlSXRlbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gaXMgbm93IGhvcHBlciBzY29wZVxuICAgICAgICBzY29wZS5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0taG9wcGVyJyk7XG5cbiAgICAgICAgLy8gc2hvcnRjdXRzXG4gICAgICAgIHZhciBjYXRjaGVzRHJvcHNPblBhZ2UgPSBvcHRpb25zLmNhdGNoZXNEcm9wc09uUGFnZSxcbiAgICAgICAgICAgIHJlcXVpcmVzRHJvcE9uRWxlbWVudCA9IG9wdGlvbnMucmVxdWlyZXNEcm9wT25FbGVtZW50LFxuICAgICAgICAgICAgX29wdGlvbnMkZmlsdGVySXRlbXMgPSBvcHRpb25zLmZpbHRlckl0ZW1zLFxuICAgICAgICAgICAgZmlsdGVySXRlbXMgPVxuICAgICAgICAgICAgICAgIF9vcHRpb25zJGZpbHRlckl0ZW1zID09PSB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IF9vcHRpb25zJGZpbHRlckl0ZW1zO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIGRuZCBjbGllbnRcbiAgICAgICAgdmFyIGNsaWVudCA9IGNyZWF0ZURyYWdORHJvcENsaWVudChcbiAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgY2F0Y2hlc0Ryb3BzT25QYWdlID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogc2NvcGUsXG4gICAgICAgICAgICByZXF1aXJlc0Ryb3BPbkVsZW1lbnRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBjdXJyZW50IGNsaWVudCBzdGF0ZVxuICAgICAgICB2YXIgbGFzdFN0YXRlID0gJyc7XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSAnJztcblxuICAgICAgICAvLyBkZXRlcm1pbmVzIGlmIGEgZmlsZSBtYXkgYmUgZHJvcHBlZFxuICAgICAgICBjbGllbnQuYWxsb3dkcm9wID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGlmIHdlIGNhbiwgdGhyb3cgZXJyb3IgdG8gaW5kaWNhdGUgdGhlIGl0ZW1zIGNhbm5vdCBieSBkcm9wcGVkXG5cbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUl0ZW1zKGZpbHRlckl0ZW1zKGl0ZW1zKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xpZW50Lm9uZHJvcCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBpdGVtcykge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkSXRlbXMgPSBmaWx0ZXJJdGVtcyhpdGVtcyk7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVJdGVtcyhmaWx0ZXJlZEl0ZW1zKSkge1xuICAgICAgICAgICAgICAgIGFwaS5vbmRyYWdlbmQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gJ2RyYWctZHJvcCc7XG5cbiAgICAgICAgICAgIGFwaS5vbmxvYWQoZmlsdGVyZWRJdGVtcywgcG9zaXRpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsaWVudC5vbmRyYWcgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgYXBpLm9uZHJhZyhwb3NpdGlvbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xpZW50Lm9uZW50ZXIgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gJ2RyYWctb3Zlcic7XG5cbiAgICAgICAgICAgIGFwaS5vbmRyYWdzdGFydChwb3NpdGlvbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xpZW50Lm9uZXhpdCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1leGl0JztcblxuICAgICAgICAgICAgYXBpLm9uZHJhZ2VuZChwb3NpdGlvbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFwaSA9IHtcbiAgICAgICAgICAgIHVwZGF0ZUhvcHBlclN0YXRlOiBmdW5jdGlvbiB1cGRhdGVIb3BwZXJTdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFN0YXRlICE9PSBjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuZGF0YXNldC5ob3BwZXJTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZCgpIHt9LFxuICAgICAgICAgICAgb25kcmFnc3RhcnQ6IGZ1bmN0aW9uIG9uZHJhZ3N0YXJ0KCkge30sXG4gICAgICAgICAgICBvbmRyYWc6IGZ1bmN0aW9uIG9uZHJhZygpIHt9LFxuICAgICAgICAgICAgb25kcmFnZW5kOiBmdW5jdGlvbiBvbmRyYWdlbmQoKSB7fSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVzdHJveSBjbGllbnRcbiAgICAgICAgICAgICAgICBjbGllbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgbGlzdGVuaW5nID0gZmFsc2U7XG4gICAgdmFyIGxpc3RlbmVycyQxID0gW107XG5cbiAgICB2YXIgaGFuZGxlUGFzdGUgPSBmdW5jdGlvbiBoYW5kbGVQYXN0ZShlKSB7XG4gICAgICAgIC8vIGlmIGlzIHBhc3RpbmcgaW4gaW5wdXQgb3IgdGV4dGFyZWEgYW5kIHRoZSB0YXJnZXQgaXMgb3V0c2lkZSBvZiBhIGZpbGVwb25kIHNjb3BlLCBpZ25vcmVcbiAgICAgICAgdmFyIGFjdGl2ZUVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKGFjdGl2ZUVsICYmIC90ZXh0YXJlYXxpbnB1dC9pLnRlc3QoYWN0aXZlRWwubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICAvLyB0ZXN0IHRleHRhcmVhIG9yIGlucHV0IGlzIGNvbnRhaW5lZCBpbiBmaWxlcG9uZCByb290XG4gICAgICAgICAgICB2YXIgaW5TY29wZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBhY3RpdmVFbDtcbiAgICAgICAgICAgIHdoaWxlIChlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmaWxlcG9uZC0tcm9vdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluU2NvcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpblNjb3BlKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0RGF0YVRyYW5zZmVySXRlbXMoZS5jbGlwYm9hcmREYXRhKS50aGVuKGZ1bmN0aW9uKGZpbGVzKSB7XG4gICAgICAgICAgICAvLyBubyBmaWxlcyByZWNlaXZlZFxuICAgICAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vdGlmeSBsaXN0ZW5lcnMgb2YgcmVjZWl2ZWQgZmlsZXNcbiAgICAgICAgICAgIGxpc3RlbmVycyQxLmZvckVhY2goZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoZmlsZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGNiKSB7XG4gICAgICAgIC8vIGNhbid0IGFkZCB0d2ljZVxuICAgICAgICBpZiAobGlzdGVuZXJzJDEuaW5jbHVkZXMoY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgaW5pdGlhbCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lcnMkMS5wdXNoKGNiKTtcblxuICAgICAgICAvLyBzZXR1cCBwYXN0ZSBsaXN0ZW5lciBmb3IgZW50aXJlIHBhZ2VcbiAgICAgICAgaWYgKGxpc3RlbmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBoYW5kbGVQYXN0ZSk7XG4gICAgfTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGZ1bmN0aW9uIHVubGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICAgIGFycmF5UmVtb3ZlKGxpc3RlbmVycyQxLCBsaXN0ZW5lcnMkMS5pbmRleE9mKGxpc3RlbmVyKSk7XG5cbiAgICAgICAgLy8gY2xlYW4gdXBcbiAgICAgICAgaWYgKGxpc3RlbmVycyQxLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBoYW5kbGVQYXN0ZSk7XG4gICAgICAgICAgICBsaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUGFzdGVyID0gZnVuY3Rpb24gY3JlYXRlUGFzdGVyKCkge1xuICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiBjYihmaWxlcykge1xuICAgICAgICAgICAgYXBpLm9ubG9hZChmaWxlcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFwaSA9IHtcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgdW5saXN0ZW4oY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKCkge30sXG4gICAgICAgIH07XG5cbiAgICAgICAgbGlzdGVuKGNiKTtcblxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlJGQgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgcm9vdC5lbGVtZW50LmlkID0gJ2ZpbGVwb25kLS1hc3Npc3RhbnQtJyArIHByb3BzLmlkO1xuICAgICAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ3JvbGUnLCAnc3RhdHVzJyk7XG4gICAgICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgICAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtcmVsZXZhbnQnLCAnYWRkaXRpb25zJyk7XG4gICAgfTtcblxuICAgIHZhciBhZGRGaWxlc05vdGlmaWNhdGlvblRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBub3RpZmljYXRpb25DbGVhclRpbWVvdXQgPSBudWxsO1xuXG4gICAgdmFyIGZpbGVuYW1lcyA9IFtdO1xuXG4gICAgdmFyIGFzc2lzdCA9IGZ1bmN0aW9uIGFzc2lzdChyb290LCBtZXNzYWdlKSB7XG4gICAgICAgIHJvb3QuZWxlbWVudC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIHZhciBjbGVhciQxID0gZnVuY3Rpb24gY2xlYXIocm9vdCkge1xuICAgICAgICByb290LmVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RNb2RpZmllZCA9IGZ1bmN0aW9uIGxpc3RNb2RpZmllZChyb290LCBmaWxlbmFtZSwgbGFiZWwpIHtcbiAgICAgICAgdmFyIHRvdGFsID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgICAgIGFzc2lzdChcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBsYWJlbCArXG4gICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSArXG4gICAgICAgICAgICAgICAgJywgJyArXG4gICAgICAgICAgICAgICAgdG90YWwgK1xuICAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICAgKHRvdGFsID09PSAxXG4gICAgICAgICAgICAgICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQ09VTlRfU0lOR1VMQVInKVxuICAgICAgICAgICAgICAgICAgICA6IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0NPVU5UX1BMVVJBTCcpKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGNsZWFyIGdyb3VwIGFmdGVyIHNldCBhbW91bnQgb2YgdGltZSBzbyB0aGUgc3RhdHVzIGlzIG5vdCByZWFkIHR3aWNlXG4gICAgICAgIGNsZWFyVGltZW91dChub3RpZmljYXRpb25DbGVhclRpbWVvdXQpO1xuICAgICAgICBub3RpZmljYXRpb25DbGVhclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xlYXIkMShyb290KTtcbiAgICAgICAgfSwgMTUwMCk7XG4gICAgfTtcblxuICAgIHZhciBpc1VzaW5nRmlsZVBvbmQgPSBmdW5jdGlvbiBpc1VzaW5nRmlsZVBvbmQocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdC5lbGVtZW50LnBhcmVudE5vZGUuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgfTtcblxuICAgIHZhciBpdGVtQWRkZWQgPSBmdW5jdGlvbiBpdGVtQWRkZWQoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgICAgICBpZiAoIWlzVXNpbmdGaWxlUG9uZChyb290KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdC5lbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgICAgICBmaWxlbmFtZXMucHVzaChpdGVtLmZpbGVuYW1lKTtcblxuICAgICAgICBjbGVhclRpbWVvdXQoYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxpc3RNb2RpZmllZChyb290LCBmaWxlbmFtZXMuam9pbignLCAnKSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQURERUQnKSk7XG5cbiAgICAgICAgICAgIGZpbGVuYW1lcy5sZW5ndGggPSAwO1xuICAgICAgICB9LCA3NTApO1xuICAgIH07XG5cbiAgICB2YXIgaXRlbVJlbW92ZWQgPSBmdW5jdGlvbiBpdGVtUmVtb3ZlZChfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb247XG4gICAgICAgIGlmICghaXNVc2luZ0ZpbGVQb25kKHJvb3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbSA9IGFjdGlvbi5pdGVtO1xuICAgICAgICBsaXN0TW9kaWZpZWQocm9vdCwgaXRlbS5maWxlbmFtZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUkVNT1ZFRCcpKTtcbiAgICB9O1xuXG4gICAgdmFyIGl0ZW1Qcm9jZXNzZWQgPSBmdW5jdGlvbiBpdGVtUHJvY2Vzc2VkKF9yZWY0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY0LmFjdGlvbjtcbiAgICAgICAgLy8gd2lsbCBhbHNvIG5vdGlmeSB0aGUgdXNlciB3aGVuIEZpbGVQb25kIGlzIG5vdCBiZWluZyB1c2VkLCBhcyB0aGUgdXNlciBtaWdodCBiZSBvY2N1cGllZCB3aXRoIG90aGVyIGFjdGl2aXRpZXMgd2hpbGUgdXBsb2FkaW5nIGEgZmlsZVxuXG4gICAgICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBpdGVtLmZpbGVuYW1lO1xuICAgICAgICB2YXIgbGFiZWwgPSByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0NPTVBMRVRFJyk7XG5cbiAgICAgICAgYXNzaXN0KHJvb3QsIGZpbGVuYW1lICsgJyAnICsgbGFiZWwpO1xuICAgIH07XG5cbiAgICB2YXIgaXRlbVByb2Nlc3NlZFVuZG8gPSBmdW5jdGlvbiBpdGVtUHJvY2Vzc2VkVW5kbyhfcmVmNSkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmNS5hY3Rpb247XG4gICAgICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBpdGVtLmZpbGVuYW1lO1xuICAgICAgICB2YXIgbGFiZWwgPSByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0FCT1JURUQnKTtcblxuICAgICAgICBhc3Npc3Qocm9vdCwgZmlsZW5hbWUgKyAnICcgKyBsYWJlbCk7XG4gICAgfTtcblxuICAgIHZhciBpdGVtRXJyb3IgPSBmdW5jdGlvbiBpdGVtRXJyb3IoX3JlZjYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjYuYWN0aW9uO1xuICAgICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gaXRlbS5maWxlbmFtZTtcblxuICAgICAgICAvLyB3aWxsIGFsc28gbm90aWZ5IHRoZSB1c2VyIHdoZW4gRmlsZVBvbmQgaXMgbm90IGJlaW5nIHVzZWQsIGFzIHRoZSB1c2VyIG1pZ2h0IGJlIG9jY3VwaWVkIHdpdGggb3RoZXIgYWN0aXZpdGllcyB3aGlsZSB1cGxvYWRpbmcgYSBmaWxlXG5cbiAgICAgICAgYXNzaXN0KHJvb3QsIGFjdGlvbi5zdGF0dXMubWFpbiArICcgJyArIGZpbGVuYW1lICsgJyAnICsgYWN0aW9uLnN0YXR1cy5zdWIpO1xuICAgIH07XG5cbiAgICB2YXIgYXNzaXN0YW50ID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJGQsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICAgICAgICBESURfTE9BRF9JVEVNOiBpdGVtQWRkZWQsXG4gICAgICAgICAgICBESURfUkVNT1ZFX0lURU06IGl0ZW1SZW1vdmVkLFxuICAgICAgICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZCxcblxuICAgICAgICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZFVuZG8sXG4gICAgICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZFVuZG8sXG5cbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogaXRlbUVycm9yLFxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogaXRlbUVycm9yLFxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogaXRlbUVycm9yLFxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogaXRlbUVycm9yLFxuICAgICAgICB9KSxcblxuICAgICAgICB0YWc6ICdzcGFuJyxcbiAgICAgICAgbmFtZTogJ2Fzc2lzdGFudCcsXG4gICAgfSk7XG5cbiAgICB2YXIgdG9DYW1lbHMgPSBmdW5jdGlvbiB0b0NhbWVscyhzdHJpbmcpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJy0nO1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChzZXBhcmF0b3IgKyAnLicsICdnJyksIGZ1bmN0aW9uKHN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHN1Yi5jaGFyQXQoMSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBkZWJvdW5jZSA9IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMpIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxNjtcbiAgICAgICAgdmFyIGltbWlkaWF0ZU9ubHkgPVxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgICAgICB2YXIgbGFzdCA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgICAgICB2YXIgZGlzdCA9IERhdGUubm93KCkgLSBsYXN0O1xuXG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZGlzdCA8IGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxheSBieSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGludGVydmFsIGFuZCBkaXN0XG4gICAgICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGU6IGlmIGRpc3RhbmNlIGlzIDEwIG1zIGFuZCBpbnRlcnZhbCBpcyAxNiBtcyxcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgYW4gYWRkaXRpb25hbCA2bXMgYmVmb3JlIGNhbGxpbmcgdGhlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgIGlmICghaW1taWRpYXRlT25seSkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgaW50ZXJ2YWwgLSBkaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdvIVxuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBNQVhfRklMRVNfTElNSVQgPSAxMDAwMDAwO1xuXG4gICAgdmFyIHByZXZlbnQgPSBmdW5jdGlvbiBwcmV2ZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZSRlID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIC8vIEFkZCBpZFxuICAgICAgICB2YXIgaWQgPSByb290LnF1ZXJ5KCdHRVRfSUQnKTtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuaWQgPSBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBjbGFzc05hbWVcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHJvb3QucXVlcnkoJ0dFVF9DTEFTU19OQU1FJyk7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIC5zcGxpdCgnICcpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWVsZCBsYWJlbFxuICAgICAgICByb290LnJlZi5sYWJlbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoXG4gICAgICAgICAgICAgICAgZHJvcExhYmVsLFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNhcHRpb246IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9JRExFJyksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBMaXN0IG9mIGl0ZW1zXG4gICAgICAgIHJvb3QucmVmLmxpc3QgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGxpc3RTY3JvbGxlciwgeyB0cmFuc2xhdGVZOiBudWxsIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQmFja2dyb3VuZCBwYW5lbFxuICAgICAgICByb290LnJlZi5wYW5lbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHBhbmVsLCB7IG5hbWU6ICdwYW5lbC1yb290JyB9KSk7XG5cbiAgICAgICAgLy8gQXNzaXN0YW50IG5vdGlmaWVzIGFzc2lzdGl2ZSB0ZWNoIHdoZW4gY29udGVudCBjaGFuZ2VzXG4gICAgICAgIHJvb3QucmVmLmFzc2lzdGFudCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoYXNzaXN0YW50LCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRGF0YVxuICAgICAgICByb290LnJlZi5kYXRhID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcoZGF0YSwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKSk7XG5cbiAgICAgICAgLy8gTWVhc3VyZSAodGVzdHMgaWYgZml4ZWQgaGVpZ2h0IHdhcyBzZXQpXG4gICAgICAgIC8vIERPQ1RZUEUgbmVlZHMgdG8gYmUgc2V0IGZvciB0aGlzIHRvIHdvcmtcbiAgICAgICAgcm9vdC5yZWYubWVhc3VyZSA9IGNyZWF0ZUVsZW1lbnQkMSgnZGl2Jyk7XG4gICAgICAgIHJvb3QucmVmLm1lYXN1cmUuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICByb290LmVsZW1lbnQuYXBwZW5kQ2hpbGQocm9vdC5yZWYubWVhc3VyZSk7XG5cbiAgICAgICAgLy8gaW5mb3JtYXRpb24gb24gdGhlIHJvb3QgaGVpZ2h0IG9yIGZpeGVkIGhlaWdodCBzdGF0dXNcbiAgICAgICAgcm9vdC5yZWYuYm91bmRzID0gbnVsbDtcblxuICAgICAgICAvLyBhcHBseSBpbml0aWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgcm9vdC5xdWVyeSgnR0VUX1NUWUxFUycpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFpc0VtcHR5KHN0eWxlLnZhbHVlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgd2lkdGggY2hhbmdlZFxuICAgICAgICByb290LnJlZi53aWR0aFByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZWYud2lkdGhVcGRhdGVkID0gZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfUkVTSVpFX1JPT1QnKTtcbiAgICAgICAgfSwgMjUwKTtcblxuICAgICAgICAvLyBoaXN0b3J5IG9mIHVwZGF0ZXNcbiAgICAgICAgcm9vdC5yZWYucHJldmlvdXNBc3BlY3RSYXRpbyA9IG51bGw7XG4gICAgICAgIHJvb3QucmVmLnVwZGF0ZUhpc3RvcnkgPSBbXTtcblxuICAgICAgICAvLyBwcmV2ZW50IHNjcm9sbGluZyBhbmQgem9vbWluZyBvbiBpT1MgKG9ubHkgaWYgc3VwcG9ydHMgcG9pbnRlciBldmVudHMsIGZvciB0aGVuIHdlIGNhbiBlbmFibGUgcmVvcmRlcilcbiAgICAgICAgdmFyIGNhbkhvdmVyID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwb2ludGVyOiBmaW5lKSBhbmQgKGhvdmVyOiBob3ZlciknKS5tYXRjaGVzO1xuICAgICAgICB2YXIgaGFzUG9pbnRlckV2ZW50cyA9ICdQb2ludGVyRXZlbnQnIGluIHdpbmRvdztcbiAgICAgICAgaWYgKHJvb3QucXVlcnkoJ0dFVF9BTExPV19SRU9SREVSJykgJiYgaGFzUG9pbnRlckV2ZW50cyAmJiAhY2FuSG92ZXIpIHtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVzdGFydCcsIHByZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGNyZWRpdHNcbiAgICAgICAgdmFyIGNyZWRpdHMgPSByb290LnF1ZXJ5KCdHRVRfQ1JFRElUUycpO1xuICAgICAgICB2YXIgaGFzQ3JlZGl0cyA9IGNyZWRpdHMubGVuZ3RoID09PSAyO1xuICAgICAgICBpZiAoaGFzQ3JlZGl0cykge1xuICAgICAgICAgICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICBmcmFnLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tY3JlZGl0cyc7XG4gICAgICAgICAgICBmcmFnLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICAgICAgZnJhZy5ocmVmID0gY3JlZGl0c1swXTtcbiAgICAgICAgICAgIGZyYWcudGFiaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGZyYWcudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgICAgICBmcmFnLnJlbCA9ICdub29wZW5lciBub3JlZmVycmVyJztcbiAgICAgICAgICAgIGZyYWcudGV4dENvbnRlbnQgPSBjcmVkaXRzWzFdO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgICAgICAgcm9vdC5yZWYuY3JlZGl0cyA9IGZyYWc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHdyaXRlJDkgPSBmdW5jdGlvbiB3cml0ZShfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzLFxuICAgICAgICAgICAgYWN0aW9ucyA9IF9yZWYzLmFjdGlvbnM7XG4gICAgICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICAgICAgcm91dGUkNSh7IHJvb3Q6IHJvb3QsIHByb3BzOiBwcm9wcywgYWN0aW9uczogYWN0aW9ucyB9KTtcblxuICAgICAgICAvLyBhcHBseSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIGFjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC9eRElEX1NFVF9TVFlMRV8vLnRlc3QoYWN0aW9uLnR5cGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFpc0VtcHR5KGFjdGlvbi5kYXRhLnZhbHVlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKF9yZWY0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfcmVmNC50eXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gX3JlZjQuZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRvQ2FtZWxzKHR5cGUuc3Vic3RyaW5nKDgpLnRvTG93ZXJDYXNlKCksICdfJyk7XG4gICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXRbbmFtZV0gPSBkYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJvb3QuaW52YWxpZGF0ZUxheW91dCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJvb3QucmVjdC5lbGVtZW50LmhpZGRlbikgcmV0dXJuO1xuXG4gICAgICAgIGlmIChyb290LnJlY3QuZWxlbWVudC53aWR0aCAhPT0gcm9vdC5yZWYud2lkdGhQcmV2aW91cykge1xuICAgICAgICAgICAgcm9vdC5yZWYud2lkdGhQcmV2aW91cyA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgICAgICAgICAgcm9vdC5yZWYud2lkdGhVcGRhdGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgYm94IGJvdW5kcywgd2UgZG8gdGhpcyBvbmx5IG9uY2VcbiAgICAgICAgdmFyIGJvdW5kcyA9IHJvb3QucmVmLmJvdW5kcztcbiAgICAgICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgICAgIGJvdW5kcyA9IHJvb3QucmVmLmJvdW5kcyA9IGNhbGN1bGF0ZVJvb3RCb3VuZGluZ0JveEhlaWdodChyb290KTtcblxuICAgICAgICAgICAgLy8gZGVzdHJveSBtZWFzdXJlIGVsZW1lbnRcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVDaGlsZChyb290LnJlZi5tZWFzdXJlKTtcbiAgICAgICAgICAgIHJvb3QucmVmLm1lYXN1cmUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHF1aWNrIHJlZmVyZW5jZXMgdG8gdmFyaW91cyBoaWdoIGxldmVsIHBhcnRzIG9mIHRoZSB1cGxvYWQgdG9vbFxuICAgICAgICB2YXIgX3Jvb3QkcmVmID0gcm9vdC5yZWYsXG4gICAgICAgICAgICBob3BwZXIgPSBfcm9vdCRyZWYuaG9wcGVyLFxuICAgICAgICAgICAgbGFiZWwgPSBfcm9vdCRyZWYubGFiZWwsXG4gICAgICAgICAgICBsaXN0ID0gX3Jvb3QkcmVmLmxpc3QsXG4gICAgICAgICAgICBwYW5lbCA9IF9yb290JHJlZi5wYW5lbDtcblxuICAgICAgICAvLyBzZXRzIGNvcnJlY3Qgc3RhdGUgdG8gaG9wcGVyIHNjb3BlXG4gICAgICAgIGlmIChob3BwZXIpIHtcbiAgICAgICAgICAgIGhvcHBlci51cGRhdGVIb3BwZXJTdGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYm9vbCB0byBpbmRpY2F0ZSBpZiB3ZSdyZSBmdWxsIG9yIG5vdFxuICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSByb290LnF1ZXJ5KCdHRVRfUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgICAgIHZhciBpc011bHRpSXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpO1xuICAgICAgICB2YXIgdG90YWxJdGVtcyA9IHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpO1xuICAgICAgICB2YXIgbWF4SXRlbXMgPSBpc011bHRpSXRlbSA/IHJvb3QucXVlcnkoJ0dFVF9NQVhfRklMRVMnKSB8fCBNQVhfRklMRVNfTElNSVQgOiAxO1xuICAgICAgICB2YXIgYXRNYXhDYXBhY2l0eSA9IHRvdGFsSXRlbXMgPT09IG1heEl0ZW1zO1xuXG4gICAgICAgIC8vIGFjdGlvbiB1c2VkIHRvIGFkZCBpdGVtXG4gICAgICAgIHZhciBhZGRBY3Rpb24gPSBhY3Rpb25zLmZpbmQoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLnR5cGUgPT09ICdESURfQUREX0lURU0nO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiByZWFjaGVkIG1heCBjYXBhY2l0eSBhbmQgd2UndmUganVzdCByZWFjaGVkIGl0XG4gICAgICAgIGlmIChhdE1heENhcGFjaXR5ICYmIGFkZEFjdGlvbikge1xuICAgICAgICAgICAgLy8gZ2V0IGludGVyYWN0aW9uIHR5cGVcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbk1ldGhvZCA9IGFkZEFjdGlvbi5kYXRhLmludGVyYWN0aW9uTWV0aG9kO1xuXG4gICAgICAgICAgICAvLyBoaWRlIGxhYmVsXG4gICAgICAgICAgICBsYWJlbC5vcGFjaXR5ID0gMDtcblxuICAgICAgICAgICAgaWYgKGlzTXVsdGlJdGVtKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwudHJhbnNsYXRlWSA9IC00MDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5BUEkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwudHJhbnNsYXRlWCA9IDQwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkJST1dTRSkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC50cmFuc2xhdGVZID0gNDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwudHJhbnNsYXRlWSA9IDMwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghYXRNYXhDYXBhY2l0eSkge1xuICAgICAgICAgICAgbGFiZWwub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICBsYWJlbC50cmFuc2xhdGVYID0gMDtcbiAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpc3RJdGVtTWFyZ2luID0gY2FsY3VsYXRlTGlzdEl0ZW1NYXJnaW4ocm9vdCk7XG5cbiAgICAgICAgdmFyIGxpc3RIZWlnaHQgPSBjYWxjdWxhdGVMaXN0SGVpZ2h0KHJvb3QpO1xuXG4gICAgICAgIHZhciBsYWJlbEhlaWdodCA9IGxhYmVsLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgIHZhciBjdXJyZW50TGFiZWxIZWlnaHQgPSAhaXNNdWx0aUl0ZW0gfHwgYXRNYXhDYXBhY2l0eSA/IDAgOiBsYWJlbEhlaWdodDtcblxuICAgICAgICB2YXIgbGlzdE1hcmdpblRvcCA9IGF0TWF4Q2FwYWNpdHkgPyBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgOiAwO1xuICAgICAgICB2YXIgbGlzdE1hcmdpbkJvdHRvbSA9IHRvdGFsSXRlbXMgPT09IDAgPyAwIDogbGlzdC5yZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tO1xuXG4gICAgICAgIHZhciB2aXN1YWxIZWlnaHQgPVxuICAgICAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0ICsgbGlzdE1hcmdpblRvcCArIGxpc3RIZWlnaHQudmlzdWFsICsgbGlzdE1hcmdpbkJvdHRvbTtcbiAgICAgICAgdmFyIGJvdW5kc0hlaWdodCA9XG4gICAgICAgICAgICBjdXJyZW50TGFiZWxIZWlnaHQgKyBsaXN0TWFyZ2luVG9wICsgbGlzdEhlaWdodC5ib3VuZHMgKyBsaXN0TWFyZ2luQm90dG9tO1xuXG4gICAgICAgIC8vIGxpbmsgbGlzdCB0byBsYWJlbCBib3R0b20gcG9zaXRpb25cbiAgICAgICAgbGlzdC50cmFuc2xhdGVZID1cbiAgICAgICAgICAgIE1hdGgubWF4KDAsIGN1cnJlbnRMYWJlbEhlaWdodCAtIGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpblRvcCkgLSBsaXN0SXRlbU1hcmdpbi50b3A7XG5cbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAvLyBmaXhlZCBhc3BlY3QgcmF0aW9cblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGhlaWdodCBiYXNlZCBvbiB3aWR0aFxuICAgICAgICAgICAgdmFyIHdpZHRoID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gd2lkdGggKiBhc3BlY3RSYXRpbztcblxuICAgICAgICAgICAgLy8gY2xlYXIgaGlzdG9yeSBpZiBhc3BlY3QgcmF0aW8gaGFzIGNoYW5nZWRcbiAgICAgICAgICAgIGlmIChhc3BlY3RSYXRpbyAhPT0gcm9vdC5yZWYucHJldmlvdXNBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIHJvb3QucmVmLnByZXZpb3VzQXNwZWN0UmF0aW8gPSBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoaXMgd2lkdGhcbiAgICAgICAgICAgIHZhciBoaXN0b3J5ID0gcm9vdC5yZWYudXBkYXRlSGlzdG9yeTtcbiAgICAgICAgICAgIGhpc3RvcnkucHVzaCh3aWR0aCk7XG5cbiAgICAgICAgICAgIHZhciBNQVhfQk9VTkNFUyA9IDI7XG4gICAgICAgICAgICBpZiAoaGlzdG9yeS5sZW5ndGggPiBNQVhfQk9VTkNFUyAqIDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGhpc3RvcnkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBsIC0gMTA7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5jZXMgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBsOyBpID49IGJvdHRvbTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXN0b3J5W2ldID09PSBoaXN0b3J5W2kgLSAyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmNlcysrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdW5jZXMgPj0gTUFYX0JPVU5DRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbnQgYWRqdXN0IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaXggaGVpZ2h0IG9mIHBhbmVsIHNvIGl0IGFkaGVyZXMgdG8gYXNwZWN0IHJhdGlvXG4gICAgICAgICAgICBwYW5lbC5zY2FsYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgcGFuZWwuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBhdmFpbGFibGUgaGVpZ2h0IGZvciBsaXN0XG4gICAgICAgICAgICB2YXIgbGlzdEF2YWlsYWJsZUhlaWdodCA9XG4gICAgICAgICAgICAgICAgLy8gdGhlIGhlaWdodCBvZiB0aGUgcGFuZWwgbWludXMgdGhlIGxhYmVsIGhlaWdodFxuICAgICAgICAgICAgICAgIGhlaWdodCAtXG4gICAgICAgICAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAvLyB0aGUgcm9vbSB3ZSBsZWF2ZSBvcGVuIGJldHdlZW4gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdGhlIHBhbmVsIGJvdHRvbVxuICAgICAgICAgICAgICAgIChsaXN0TWFyZ2luQm90dG9tIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tKSAtXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgZnVsbCB3ZSBuZWVkIHRvIGxlYXZlIHNvbWUgcm9vbSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhlIHBhbmVsIGFuZCB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIChhdE1heENhcGFjaXR5ID8gbGlzdE1hcmdpblRvcCA6IDApO1xuXG4gICAgICAgICAgICBpZiAobGlzdEhlaWdodC52aXN1YWwgPiBsaXN0QXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IGxpc3RBdmFpbGFibGVIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGJvdW5kcy5maXhlZEhlaWdodCkge1xuICAgICAgICAgICAgLy8gZml4ZWQgaGVpZ2h0XG5cbiAgICAgICAgICAgIC8vIGZpeCBoZWlnaHQgb2YgcGFuZWxcbiAgICAgICAgICAgIHBhbmVsLnNjYWxhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGF2YWlsYWJsZSBoZWlnaHQgZm9yIGxpc3RcbiAgICAgICAgICAgIHZhciBfbGlzdEF2YWlsYWJsZUhlaWdodCA9XG4gICAgICAgICAgICAgICAgLy8gdGhlIGhlaWdodCBvZiB0aGUgcGFuZWwgbWludXMgdGhlIGxhYmVsIGhlaWdodFxuICAgICAgICAgICAgICAgIGJvdW5kcy5maXhlZEhlaWdodCAtXG4gICAgICAgICAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAvLyB0aGUgcm9vbSB3ZSBsZWF2ZSBvcGVuIGJldHdlZW4gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdGhlIHBhbmVsIGJvdHRvbVxuICAgICAgICAgICAgICAgIChsaXN0TWFyZ2luQm90dG9tIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tKSAtXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgZnVsbCB3ZSBuZWVkIHRvIGxlYXZlIHNvbWUgcm9vbSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhlIHBhbmVsIGFuZCB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIChhdE1heENhcGFjaXR5ID8gbGlzdE1hcmdpblRvcCA6IDApO1xuXG4gICAgICAgICAgICAvLyBzZXQgbGlzdCBoZWlnaHRcbiAgICAgICAgICAgIGlmIChsaXN0SGVpZ2h0LnZpc3VhbCA+IF9saXN0QXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IF9saXN0QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBzZXQgY29udGFpbmVyIGJvdW5kcyBhcyB0aGVzZSBhcmUgaGFuZGxlcyBieSBDU1MgZml4ZWQgaGVpZ2h0XG4gICAgICAgIH0gZWxzZSBpZiAoYm91bmRzLmNhcHBlZEhlaWdodCkge1xuICAgICAgICAgICAgLy8gbWF4LWhlaWdodFxuXG4gICAgICAgICAgICAvLyBub3QgYSBmaXhlZCBoZWlnaHQgcGFuZWxcbiAgICAgICAgICAgIHZhciBpc0NhcHBlZEhlaWdodCA9IHZpc3VhbEhlaWdodCA+PSBib3VuZHMuY2FwcGVkSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHBhbmVsSGVpZ2h0ID0gTWF0aC5taW4oYm91bmRzLmNhcHBlZEhlaWdodCwgdmlzdWFsSGVpZ2h0KTtcbiAgICAgICAgICAgIHBhbmVsLnNjYWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhbmVsLmhlaWdodCA9IGlzQ2FwcGVkSGVpZ2h0XG4gICAgICAgICAgICAgICAgPyBwYW5lbEhlaWdodFxuICAgICAgICAgICAgICAgIDogcGFuZWxIZWlnaHQgLSBsaXN0SXRlbU1hcmdpbi50b3AgLSBsaXN0SXRlbU1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgICAgIC8vIGF2YWlsYWJsZSBoZWlnaHQgZm9yIGxpc3RcbiAgICAgICAgICAgIHZhciBfbGlzdEF2YWlsYWJsZUhlaWdodDIgPVxuICAgICAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlIHBhbmVsIG1pbnVzIHRoZSBsYWJlbCBoZWlnaHRcbiAgICAgICAgICAgICAgICBwYW5lbEhlaWdodCAtXG4gICAgICAgICAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAvLyB0aGUgcm9vbSB3ZSBsZWF2ZSBvcGVuIGJldHdlZW4gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdGhlIHBhbmVsIGJvdHRvbVxuICAgICAgICAgICAgICAgIChsaXN0TWFyZ2luQm90dG9tIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tKSAtXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgZnVsbCB3ZSBuZWVkIHRvIGxlYXZlIHNvbWUgcm9vbSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhlIHBhbmVsIGFuZCB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIChhdE1heENhcGFjaXR5ID8gbGlzdE1hcmdpblRvcCA6IDApO1xuXG4gICAgICAgICAgICAvLyBzZXQgbGlzdCBoZWlnaHQgKGlmIGlzIG92ZXJmbG93aW5nKVxuICAgICAgICAgICAgaWYgKHZpc3VhbEhlaWdodCA+IGJvdW5kcy5jYXBwZWRIZWlnaHQgJiYgbGlzdEhlaWdodC52aXN1YWwgPiBfbGlzdEF2YWlsYWJsZUhlaWdodDIpIHtcbiAgICAgICAgICAgICAgICBsaXN0Lm92ZXJmbG93ID0gX2xpc3RBdmFpbGFibGVIZWlnaHQyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IGNvbnRhaW5lciBib3VuZHMgKHNvIHB1c2hlcyBzaWJsaW5ncyBkb3dud2FyZHMpXG4gICAgICAgICAgICByb290LmhlaWdodCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIGJvdW5kcy5jYXBwZWRIZWlnaHQsXG4gICAgICAgICAgICAgICAgYm91bmRzSGVpZ2h0IC0gbGlzdEl0ZW1NYXJnaW4udG9wIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmxleGlibGUgaGVpZ2h0XG5cbiAgICAgICAgICAgIC8vIG5vdCBhIGZpeGVkIGhlaWdodCBwYW5lbFxuICAgICAgICAgICAgdmFyIGl0ZW1NYXJnaW4gPSB0b3RhbEl0ZW1zID4gMCA/IGxpc3RJdGVtTWFyZ2luLnRvcCArIGxpc3RJdGVtTWFyZ2luLmJvdHRvbSA6IDA7XG4gICAgICAgICAgICBwYW5lbC5zY2FsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBwYW5lbC5oZWlnaHQgPSBNYXRoLm1heChsYWJlbEhlaWdodCwgdmlzdWFsSGVpZ2h0IC0gaXRlbU1hcmdpbik7XG5cbiAgICAgICAgICAgIC8vIHNldCBjb250YWluZXIgYm91bmRzIChzbyBwdXNoZXMgc2libGluZ3MgZG93bndhcmRzKVxuICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSBNYXRoLm1heChsYWJlbEhlaWdodCwgYm91bmRzSGVpZ2h0IC0gaXRlbU1hcmdpbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIGNyZWRpdHMgdG8gYm90dG9tXG4gICAgICAgIGlmIChyb290LnJlZi5jcmVkaXRzICYmIHBhbmVsLmhlaWdodEN1cnJlbnQpXG4gICAgICAgICAgICByb290LnJlZi5jcmVkaXRzLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKCcgKyBwYW5lbC5oZWlnaHRDdXJyZW50ICsgJ3B4KSc7XG4gICAgfTtcblxuICAgIHZhciBjYWxjdWxhdGVMaXN0SXRlbU1hcmdpbiA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUxpc3RJdGVtTWFyZ2luKHJvb3QpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSByb290LnJlZi5saXN0LmNoaWxkVmlld3NbMF0uY2hpbGRWaWV3c1swXTtcbiAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgdG9wOiBpdGVtLnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgICAgICBib3R0b206IGl0ZW0ucmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjYWxjdWxhdGVMaXN0SGVpZ2h0ID0gZnVuY3Rpb24gY2FsY3VsYXRlTGlzdEhlaWdodChyb290KSB7XG4gICAgICAgIHZhciB2aXN1YWwgPSAwO1xuICAgICAgICB2YXIgYm91bmRzID0gMDtcblxuICAgICAgICAvLyBnZXQgZmlsZSBsaXN0IHJlZmVyZW5jZVxuICAgICAgICB2YXIgc2Nyb2xsTGlzdCA9IHJvb3QucmVmLmxpc3Q7XG4gICAgICAgIHZhciBpdGVtTGlzdCA9IHNjcm9sbExpc3QuY2hpbGRWaWV3c1swXTtcbiAgICAgICAgdmFyIHZpc2libGVDaGlsZHJlbiA9IGl0ZW1MaXN0LmNoaWxkVmlld3MuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHJvb3RcbiAgICAgICAgICAgIC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaWJsZUNoaWxkcmVuLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBpdGVtLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbm8gY2hpbGRyZW4sIGRvbmUhXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHJldHVybiB7IHZpc3VhbDogdmlzdWFsLCBib3VuZHM6IGJvdW5kcyB9O1xuXG4gICAgICAgIHZhciBob3Jpem9udGFsU3BhY2UgPSBpdGVtTGlzdC5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgICAgIHZhciBkcmFnSW5kZXggPSBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uKGl0ZW1MaXN0LCBjaGlsZHJlbiwgc2Nyb2xsTGlzdC5kcmFnQ29vcmRpbmF0ZXMpO1xuXG4gICAgICAgIHZhciBjaGlsZFJlY3QgPSBjaGlsZHJlblswXS5yZWN0LmVsZW1lbnQ7XG5cbiAgICAgICAgdmFyIGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5Ub3AgKyBjaGlsZFJlY3QubWFyZ2luQm90dG9tO1xuICAgICAgICB2YXIgaXRlbUhvcml6b250YWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luTGVmdCArIGNoaWxkUmVjdC5tYXJnaW5SaWdodDtcblxuICAgICAgICB2YXIgaXRlbVdpZHRoID0gY2hpbGRSZWN0LndpZHRoICsgaXRlbUhvcml6b250YWxNYXJnaW47XG4gICAgICAgIHZhciBpdGVtSGVpZ2h0ID0gY2hpbGRSZWN0LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcblxuICAgICAgICB2YXIgbmV3SXRlbSA9IHR5cGVvZiBkcmFnSW5kZXggIT09ICd1bmRlZmluZWQnICYmIGRyYWdJbmRleCA+PSAwID8gMSA6IDA7XG4gICAgICAgIHZhciByZW1vdmVkSXRlbSA9IGNoaWxkcmVuLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5tYXJrZWRGb3JSZW1vdmFsICYmIGNoaWxkLm9wYWNpdHkgPCAwLjQ1O1xuICAgICAgICB9KVxuICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgOiAwO1xuICAgICAgICB2YXIgdmVydGljYWxJdGVtQ291bnQgPSBjaGlsZHJlbi5sZW5ndGggKyBuZXdJdGVtICsgcmVtb3ZlZEl0ZW07XG4gICAgICAgIHZhciBpdGVtc1BlclJvdyA9IGdldEl0ZW1zUGVyUm93KGhvcml6b250YWxTcGFjZSwgaXRlbVdpZHRoKTtcblxuICAgICAgICAvLyBzdGFja1xuICAgICAgICBpZiAoaXRlbXNQZXJSb3cgPT09IDEpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBpdGVtLnJlY3QuZWxlbWVudC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG4gICAgICAgICAgICAgICAgYm91bmRzICs9IGhlaWdodDtcbiAgICAgICAgICAgICAgICB2aXN1YWwgKz0gaGVpZ2h0ICogaXRlbS5vcGFjaXR5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ3JpZFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvdW5kcyA9IE1hdGguY2VpbCh2ZXJ0aWNhbEl0ZW1Db3VudCAvIGl0ZW1zUGVyUm93KSAqIGl0ZW1IZWlnaHQ7XG4gICAgICAgICAgICB2aXN1YWwgPSBib3VuZHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2aXN1YWw6IHZpc3VhbCwgYm91bmRzOiBib3VuZHMgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNhbGN1bGF0ZVJvb3RCb3VuZGluZ0JveEhlaWdodCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVJvb3RCb3VuZGluZ0JveEhlaWdodChyb290KSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSByb290LnJlZi5tZWFzdXJlSGVpZ2h0IHx8IG51bGw7XG4gICAgICAgIHZhciBjYXBwZWRIZWlnaHQgPSBwYXJzZUludChyb290LnN0eWxlLm1heEhlaWdodCwgMTApIHx8IG51bGw7XG4gICAgICAgIHZhciBmaXhlZEhlaWdodCA9IGhlaWdodCA9PT0gMCA/IG51bGwgOiBoZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhcHBlZEhlaWdodDogY2FwcGVkSGVpZ2h0LFxuICAgICAgICAgICAgZml4ZWRIZWlnaHQ6IGZpeGVkSGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZXhjZWVkc01heEZpbGVzID0gZnVuY3Rpb24gZXhjZWVkc01heEZpbGVzKHJvb3QsIGl0ZW1zKSB7XG4gICAgICAgIHZhciBhbGxvd1JlcGxhY2UgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVQTEFDRScpO1xuICAgICAgICB2YXIgYWxsb3dNdWx0aXBsZSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpO1xuICAgICAgICB2YXIgdG90YWxJdGVtcyA9IHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpO1xuICAgICAgICB2YXIgbWF4SXRlbXMgPSByb290LnF1ZXJ5KCdHRVRfTUFYX0ZJTEVTJyk7XG5cbiAgICAgICAgLy8gdG90YWwgYW1vdW50IG9mIGl0ZW1zIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgdmFyIHRvdGFsQnJvd3NlSXRlbXMgPSBpdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gaWYgZG9lcyBub3QgYWxsb3cgbXVsdGlwbGUgaXRlbXMgYW5kIGRyYWdnaW5nIG1vcmUgdGhhbiBvbmUgaXRlbVxuICAgICAgICBpZiAoIWFsbG93TXVsdGlwbGUgJiYgdG90YWxCcm93c2VJdGVtcyA+IDEpIHtcbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9USFJPV19NQVhfRklMRVMnLCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ3dhcm5pbmcnLCAwLCAnTWF4IGZpbGVzJyksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW1pdCBtYXggaXRlbXMgdG8gb25lIGlmIG5vdCBhbGxvd2VkIHRvIGRyb3AgbXVsdGlwbGUgaXRlbXNcbiAgICAgICAgbWF4SXRlbXMgPSBhbGxvd011bHRpcGxlID8gbWF4SXRlbXMgOiAxO1xuXG4gICAgICAgIGlmICghYWxsb3dNdWx0aXBsZSAmJiBhbGxvd1JlcGxhY2UpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG9ubHkgb25lIGl0ZW0sIHNvIHRoZXJlIGlzIHJvb20gdG8gcmVwbGFjZSBvciBhZGQgYW4gaXRlbVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gbW9yZSByb29tP1xuICAgICAgICB2YXIgaGFzTWF4SXRlbXMgPSBpc0ludChtYXhJdGVtcyk7XG4gICAgICAgIGlmIChoYXNNYXhJdGVtcyAmJiB0b3RhbEl0ZW1zICsgdG90YWxCcm93c2VJdGVtcyA+IG1heEl0ZW1zKSB7XG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfVEhST1dfTUFYX0ZJTEVTJywge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogaXRlbXMsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCd3YXJuaW5nJywgMCwgJ01heCBmaWxlcycpLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RHJhZ0luZGV4ID0gZnVuY3Rpb24gZ2V0RHJhZ0luZGV4KGxpc3QsIGNoaWxkcmVuLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgaXRlbUxpc3QgPSBsaXN0LmNoaWxkVmlld3NbMF07XG4gICAgICAgIHJldHVybiBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uKGl0ZW1MaXN0LCBjaGlsZHJlbiwge1xuICAgICAgICAgICAgbGVmdDogcG9zaXRpb24uc2NvcGVMZWZ0IC0gaXRlbUxpc3QucmVjdC5lbGVtZW50LmxlZnQsXG4gICAgICAgICAgICB0b3A6XG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc2NvcGVUb3AgLVxuICAgICAgICAgICAgICAgIChsaXN0LnJlY3Qub3V0ZXIudG9wICsgbGlzdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wICsgbGlzdC5yZWN0LmVsZW1lbnQuc2Nyb2xsVG9wKSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGZpbGUgZHJvcCBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAgdmFyIHRvZ2dsZURyb3AgPSBmdW5jdGlvbiB0b2dnbGVEcm9wKHJvb3QpIHtcbiAgICAgICAgdmFyIGlzQWxsb3dlZCA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19EUk9QJyk7XG4gICAgICAgIHZhciBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgICAgIHZhciBlbmFibGVkID0gaXNBbGxvd2VkICYmICFpc0Rpc2FibGVkO1xuICAgICAgICBpZiAoZW5hYmxlZCAmJiAhcm9vdC5yZWYuaG9wcGVyKSB7XG4gICAgICAgICAgICB2YXIgaG9wcGVyID0gY3JlYXRlSG9wcGVyKFxuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyBxdWljayB2YWxpZGF0aW9uIG9mIGRyb3BwZWQgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZURyb3BGaWxlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QucXVlcnkoJ0dFVF9CRUZPUkVfRFJPUF9GSUxFJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhbGwgaXRlbXMgc2hvdWxkIGJlIHZhbGlkYXRlZCBieSBhbGwgZmlsdGVycyBhcyB2YWxpZFxuICAgICAgICAgICAgICAgICAgICB2YXIgZHJvcFZhbGlkYXRpb24gPSByb290LnF1ZXJ5KCdHRVRfRFJPUF9WQUxJREFUSU9OJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkcm9wVmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpdGVtcy5ldmVyeShmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVycygnQUxMT1dfSE9QUEVSX0lURU0nLCBpdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiByb290LnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmV2ZXJ5KGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pICYmIGJlZm9yZURyb3BGaWxlKGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJdGVtczogZnVuY3Rpb24gZmlsdGVySXRlbXMoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZ25vcmVkRmlsZXMgPSByb290LnF1ZXJ5KCdHRVRfSUdOT1JFRF9GSUxFUycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRmlsZShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlnbm9yZWRGaWxlcy5pbmNsdWRlcyhpdGVtLm5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoZXNEcm9wc09uUGFnZTogcm9vdC5xdWVyeSgnR0VUX0RST1BfT05fUEFHRScpLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlc0Ryb3BPbkVsZW1lbnQ6IHJvb3QucXVlcnkoJ0dFVF9EUk9QX09OX0VMRU1FTlQnKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBob3BwZXIub25sb2FkID0gZnVuY3Rpb24oaXRlbXMsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGl0ZW0gY2hpbGRyZW4gZWxlbWVudHMgYW5kIHNvcnQgYmFzZWQgb24gbGlzdCBzb3J0XG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSByb290LnJlZi5saXN0LmNoaWxkVmlld3NbMF07XG4gICAgICAgICAgICAgICAgdmFyIHZpc2libGVDaGlsZHJlbiA9IGxpc3QuY2hpbGRWaWV3cy5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gcm9vdFxuICAgICAgICAgICAgICAgICAgICAucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpYmxlQ2hpbGRyZW4uZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaXRlbS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0FERF9JVEVNUycsIGl0ZW1zLCB7IGRpc3BhdGNoOiByb290LmRpc3BhdGNoIH0pLnRoZW4oZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIGZpbGVzIGRvbid0IGZpdCBzbyBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2VlZHNNYXhGaWxlcyhyb290LCBxdWV1ZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnb1xuICAgICAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcXVldWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogZ2V0RHJhZ0luZGV4KHJvb3QucmVmLmxpc3QsIGNoaWxkcmVuLCBwb3NpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuRFJPUCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRFJPUCcsIHsgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xuXG4gICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0VORF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBob3BwZXIub25kcmFnc3RhcnQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9TVEFSVF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBob3BwZXIub25kcmFnID0gZGVib3VuY2UoZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRFJBRycsIHsgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGhvcHBlci5vbmRyYWdlbmQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9FTkRfRFJBRycsIHsgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcm9vdC5yZWYuaG9wcGVyID0gaG9wcGVyO1xuXG4gICAgICAgICAgICByb290LnJlZi5kcmlwID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcoZHJpcCkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFlbmFibGVkICYmIHJvb3QucmVmLmhvcHBlcikge1xuICAgICAgICAgICAgcm9vdC5yZWYuaG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJvb3QucmVmLmhvcHBlciA9IG51bGw7XG4gICAgICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyhyb290LnJlZi5kcmlwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBicm93c2UgZnVuY3Rpb25hbGl0eVxuICAgICAqL1xuICAgIHZhciB0b2dnbGVCcm93c2UgPSBmdW5jdGlvbiB0b2dnbGVCcm93c2Uocm9vdCwgcHJvcHMpIHtcbiAgICAgICAgdmFyIGlzQWxsb3dlZCA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19CUk9XU0UnKTtcbiAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICAgICAgdmFyIGVuYWJsZWQgPSBpc0FsbG93ZWQgJiYgIWlzRGlzYWJsZWQ7XG4gICAgICAgIGlmIChlbmFibGVkICYmICFyb290LnJlZi5icm93c2VyKSB7XG4gICAgICAgICAgICByb290LnJlZi5icm93c2VyID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoXG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIsXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZChpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0FERF9JVEVNUycsIGl0ZW1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoOiByb290LmRpc3BhdGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgZmlsZXMgZG9uJ3QgZml0IHNvIHN0b3AgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhjZWVkc01heEZpbGVzKHJvb3QsIHF1ZXVlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpdGVtcyFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnQUREX0lURU1TJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHF1ZXVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLkJST1dTRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCFlbmFibGVkICYmIHJvb3QucmVmLmJyb3dzZXIpIHtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHJvb3QucmVmLmJyb3dzZXIpO1xuICAgICAgICAgICAgcm9vdC5yZWYuYnJvd3NlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgcGFzdGUgZnVuY3Rpb25hbGl0eVxuICAgICAqL1xuICAgIHZhciB0b2dnbGVQYXN0ZSA9IGZ1bmN0aW9uIHRvZ2dsZVBhc3RlKHJvb3QpIHtcbiAgICAgICAgdmFyIGlzQWxsb3dlZCA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19QQVNURScpO1xuICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgICAgICB2YXIgZW5hYmxlZCA9IGlzQWxsb3dlZCAmJiAhaXNEaXNhYmxlZDtcbiAgICAgICAgaWYgKGVuYWJsZWQgJiYgIXJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgICAgICAgcm9vdC5yZWYucGFzdGVyID0gY3JlYXRlUGFzdGVyKCk7XG4gICAgICAgICAgICByb290LnJlZi5wYXN0ZXIub25sb2FkID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdBRERfSVRFTVMnLCBpdGVtcywgeyBkaXNwYXRjaDogcm9vdC5kaXNwYXRjaCB9KS50aGVuKGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGVzZSBmaWxlcyBkb24ndCBmaXQgc28gc3RvcCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmIChleGNlZWRzTWF4RmlsZXMocm9vdCwgcXVldWUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGl0ZW1zIVxuICAgICAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcXVldWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuUEFTVEUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghZW5hYmxlZCAmJiByb290LnJlZi5wYXN0ZXIpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLnBhc3Rlci5kZXN0cm95KCk7XG4gICAgICAgICAgICByb290LnJlZi5wYXN0ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJvdXRlIGFjdGlvbnNcbiAgICAgKi9cbiAgICB2YXIgcm91dGUkNSA9IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX1NFVF9BTExPV19CUk9XU0U6IGZ1bmN0aW9uIERJRF9TRVRfQUxMT1dfQlJPV1NFKF9yZWY1KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcztcbiAgICAgICAgICAgIHRvZ2dsZUJyb3dzZShyb290LCBwcm9wcyk7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9TRVRfQUxMT1dfRFJPUDogZnVuY3Rpb24gRElEX1NFVF9BTExPV19EUk9QKF9yZWY2KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3Q7XG4gICAgICAgICAgICB0b2dnbGVEcm9wKHJvb3QpO1xuICAgICAgICB9LFxuICAgICAgICBESURfU0VUX0FMTE9XX1BBU1RFOiBmdW5jdGlvbiBESURfU0VUX0FMTE9XX1BBU1RFKF9yZWY3KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3Q7XG4gICAgICAgICAgICB0b2dnbGVQYXN0ZShyb290KTtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NFVF9ESVNBQkxFRDogZnVuY3Rpb24gRElEX1NFVF9ESVNBQkxFRChfcmVmOCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290LFxuICAgICAgICAgICAgICAgIHByb3BzID0gX3JlZjgucHJvcHM7XG4gICAgICAgICAgICB0b2dnbGVEcm9wKHJvb3QpO1xuICAgICAgICAgICAgdG9nZ2xlUGFzdGUocm9vdCk7XG4gICAgICAgICAgICB0b2dnbGVCcm93c2Uocm9vdCwgcHJvcHMpO1xuICAgICAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZGlzYWJsZWQgPSAnZGlzYWJsZWQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgcm9vdC5lbGVtZW50LmRhdGFzZXQuZGlzYWJsZWQ7IDw9IHRoaXMgZG9lcyBub3Qgd29yayBvbiBpT1MgMTBcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWRpc2FibGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgcm9vdCA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBuYW1lOiAncm9vdCcsXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoX3JlZjkpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjkucm9vdDtcbiAgICAgICAgICAgIGlmIChyb290LnJlZi5tZWFzdXJlKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5yZWYubWVhc3VyZUhlaWdodCA9IHJvb3QucmVmLm1lYXN1cmUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGU6IGNyZWF0ZSRlLFxuICAgICAgICB3cml0ZTogd3JpdGUkOSxcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShfcmVmMTApIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjEwLnJvb3Q7XG4gICAgICAgICAgICBpZiAocm9vdC5yZWYucGFzdGVyKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5yZWYucGFzdGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb290LnJlZi5ob3BwZXIpIHtcbiAgICAgICAgICAgICAgICByb290LnJlZi5ob3BwZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnQpO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVzdGFydCcsIHByZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICAgIHN0eWxlczogWydoZWlnaHQnXSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZXMgdGhlIGFwcFxuICAgIHZhciBjcmVhdGVBcHAgPSBmdW5jdGlvbiBjcmVhdGVBcHAoKSB7XG4gICAgICAgIHZhciBpbml0aWFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIC8vIGxldCBlbGVtZW50XG4gICAgICAgIHZhciBvcmlnaW5hbEVsZW1lbnQgPSBudWxsO1xuXG4gICAgICAgIC8vIGdldCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0gZ2V0T3B0aW9ucygpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgZGF0YSBzdG9yZSwgdGhpcyB3aWxsIGNvbnRhaW4gYWxsIG91ciBhcHAgaW5mb1xuICAgICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZShcbiAgICAgICAgICAgIC8vIGluaXRpYWwgc3RhdGUgKHNob3VsZCBiZSBzZXJpYWxpemFibGUpXG4gICAgICAgICAgICBjcmVhdGVJbml0aWFsU3RhdGUoZGVmYXVsdE9wdGlvbnMpLFxuXG4gICAgICAgICAgICAvLyBxdWVyaWVzXG4gICAgICAgICAgICBbcXVlcmllcywgY3JlYXRlT3B0aW9uUXVlcmllcyhkZWZhdWx0T3B0aW9ucyldLFxuXG4gICAgICAgICAgICAvLyBhY3Rpb24gaGFuZGxlcnNcbiAgICAgICAgICAgIFthY3Rpb25zLCBjcmVhdGVPcHRpb25BY3Rpb25zKGRlZmF1bHRPcHRpb25zKV1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBzZXQgaW5pdGlhbCBvcHRpb25zXG4gICAgICAgIHN0b3JlLmRpc3BhdGNoKCdTRVRfT1BUSU9OUycsIHsgb3B0aW9uczogaW5pdGlhbE9wdGlvbnMgfSk7XG5cbiAgICAgICAgLy8ga2ljayB0aHJlYWQgaWYgdmlzaWJpbGl0eSBjaGFuZ2VzXG4gICAgICAgIHZhciB2aXNpYmlsaXR5SGFuZGxlciA9IGZ1bmN0aW9uIHZpc2liaWxpdHlIYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikgcmV0dXJuO1xuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ0tJQ0snKTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHZpc2liaWxpdHlIYW5kbGVyKTtcblxuICAgICAgICAvLyByZS1yZW5kZXIgb24gd2luZG93IHJlc2l6ZSBzdGFydCBhbmQgZmluaXNoXG4gICAgICAgIHZhciByZXNpemVEb25lVGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgaXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgaXNSZXNpemluZ0hvcml6b250YWxseSA9IGZhbHNlO1xuICAgICAgICB2YXIgaW5pdGlhbFdpbmRvd1dpZHRoID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgICAgIHZhciByZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gcmVzaXplSGFuZGxlcigpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXNpemluZykge1xuICAgICAgICAgICAgICAgIGlzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc2l6ZURvbmVUaW1lcik7XG4gICAgICAgICAgICByZXNpemVEb25lVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpbml0aWFsV2luZG93V2lkdGggPSBudWxsO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzaXppbmdIb3Jpem9udGFsbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNSZXNpemluZ0hvcml6b250YWxseSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnRElEX1NUT1BfUkVTSVpFJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUhhbmRsZXIpO1xuXG4gICAgICAgIC8vIHJlbmRlciBpbml0aWFsIHZpZXdcbiAgICAgICAgdmFyIHZpZXcgPSByb290KHN0b3JlLCB7IGlkOiBnZXRVbmlxdWVJZCgpIH0pO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBSSVZBVEUgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy9cbiAgICAgICAgdmFyIGlzUmVzdGluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBmYWxzZTtcblxuICAgICAgICB2YXIgcmVhZFdyaXRlQXBpID0ge1xuICAgICAgICAgICAgLy8gbmVjZXNzYXJ5IGZvciB1cGRhdGUgbG9vcFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlYWRzIGZyb20gZG9tIChuZXZlciBjYWxsIG1hbnVhbGx5KVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3JlYWQ6IGZ1bmN0aW9uIF9yZWFkKCkge1xuICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgd2UncmUgcmVzaXppbmcgaG9yaXpvbnRhbGx5XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc2VlIGlmIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIGJ5IG1lYXN1cmluZyByb290IHJlY3RcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXNpemluZykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbml0aWFsV2luZG93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxXaW5kb3dXaWR0aCA9IGN1cnJlbnRXaW5kb3dXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNpemluZ0hvcml6b250YWxseSAmJiBjdXJyZW50V2luZG93V2lkdGggIT09IGluaXRpYWxXaW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ0RJRF9TVEFSVF9SRVNJWkUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVzaXppbmdIb3Jpem9udGFsbHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzSGlkZGVuICYmIGlzUmVzdGluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0ZXN0IGlmIGlzIG5vIGxvbmdlciBoaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgaXNSZXN0aW5nID0gdmlldy5lbGVtZW50Lm9mZnNldFBhcmVudCA9PT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiByZXN0aW5nLCBubyBuZWVkIHRvIHJlYWQgYXMgbnVtYmVycyB3aWxsIHN0aWxsIGFsbCBiZSBjb3JyZWN0XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdGluZykgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVhZCB2aWV3IGRhdGFcbiAgICAgICAgICAgICAgICB2aWV3Ll9yZWFkKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBpcyBoaWRkZW4gd2UgbmVlZCB0byBrbm93IHNvIHdlIGV4aXQgcmVzdCBtb2RlIHdoZW4gcmV2ZWFsZWRcbiAgICAgICAgICAgICAgICBpc0hpZGRlbiA9IHZpZXcucmVjdC5lbGVtZW50LmhpZGRlbjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV3JpdGVzIHRvIGRvbSAobmV2ZXIgY2FsbCBtYW51YWxseSlcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF93cml0ZTogZnVuY3Rpb24gX3dyaXRlKHRzKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGFsbCBhY3Rpb25zIGZyb20gc3RvcmVcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9ucyA9IHN0b3JlXG4gICAgICAgICAgICAgICAgICAgIC5wcm9jZXNzQWN0aW9uUXVldWUoKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgc2V0IGFjdGlvbnMgKHRoZXNlIHdpbGwgYXV0b21hdGljYWxseSB0cmlnZ2VyIERJRF9TRVQpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIS9eU0VUXy8udGVzdChhY3Rpb24udHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgd2FzIGlkbGluZyBhbmQgbm8gYWN0aW9ucyBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0aW5nICYmICFhY3Rpb25zLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gc29tZSBhY3Rpb25zIG1pZ2h0IHRyaWdnZXIgZXZlbnRzXG4gICAgICAgICAgICAgICAgcm91dGVBY3Rpb25zVG9FdmVudHMoYWN0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHZpZXdcbiAgICAgICAgICAgICAgICBpc1Jlc3RpbmcgPSB2aWV3Ll93cml0ZSh0cywgYWN0aW9ucywgaXNSZXNpemluZ0hvcml6b250YWxseSk7XG5cbiAgICAgICAgICAgICAgICAvLyB3aWxsIGNsZWFuIHVwIGFsbCBhcmNoaXZlZCBpdGVtc1xuICAgICAgICAgICAgICAgIHJlbW92ZVJlbGVhc2VkSXRlbXMoc3RvcmUucXVlcnkoJ0dFVF9JVEVNUycpKTtcblxuICAgICAgICAgICAgICAgIC8vIG5vdyBpZGxpbmdcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLnByb2Nlc3NEaXNwYXRjaFF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBFWFBPU0UgRVZFTlRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy9cbiAgICAgICAgdmFyIGNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gY3JlYXRlRXZlbnQobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgZGVmYXVsdCBldmVudFxuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbmFtZSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gbm8gZGF0YSB0byBhZGRcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNvcHkgcmVsZXZhbnQgcHJvcHNcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgnZXJyb3InKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5lcnJvciA9IGRhdGEuZXJyb3IgPyBPYmplY3QuYXNzaWduKHt9LCBkYXRhLmVycm9yKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0YXR1cyA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5maWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Lm91dHB1dCA9IGRhdGEuZmlsZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IHNvdXJjZSBpcyBhdmFpbGFibGUsIGVsc2UgYWRkIGl0ZW0gaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZmlsZSA9IGRhdGEuc291cmNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5pdGVtIHx8IGRhdGEuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBkYXRhLml0ZW0gPyBkYXRhLml0ZW0gOiBzdG9yZS5xdWVyeSgnR0VUX0lURU0nLCBkYXRhLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZmlsZSA9IGl0ZW0gPyBjcmVhdGVJdGVtQVBJKGl0ZW0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtYXAgYWxsIGl0ZW1zIGluIGEgcG9zc2libGUgaXRlbXMgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5pdGVtcyA9IGRhdGEuaXRlbXMubWFwKGNyZWF0ZUl0ZW1BUEkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBwcm9ncmVzcyBldmVudCBhZGQgdGhlIHByb2dyZXNzIGFtb3VudFxuICAgICAgICAgICAgICAgIGlmICgvcHJvZ3Jlc3MvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJvZ3Jlc3MgPSBkYXRhLnByb2dyZXNzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNvcHkgcmVsZXZhbnQgcHJvcHNcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgnb3JpZ2luJykgJiYgZGF0YS5oYXNPd25Qcm9wZXJ0eSgndGFyZ2V0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQub3JpZ2luID0gZGF0YS5vcmlnaW47XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGRhdGEudGFyZ2V0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV2ZW50Um91dGVzID0ge1xuICAgICAgICAgICAgRElEX0RFU1RST1k6IGNyZWF0ZUV2ZW50KCdkZXN0cm95JyksXG5cbiAgICAgICAgICAgIERJRF9JTklUOiBjcmVhdGVFdmVudCgnaW5pdCcpLFxuXG4gICAgICAgICAgICBESURfVEhST1dfTUFYX0ZJTEVTOiBjcmVhdGVFdmVudCgnd2FybmluZycpLFxuXG4gICAgICAgICAgICBESURfSU5JVF9JVEVNOiBjcmVhdGVFdmVudCgnaW5pdGZpbGUnKSxcbiAgICAgICAgICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6IGNyZWF0ZUV2ZW50KCdhZGRmaWxlc3RhcnQnKSxcbiAgICAgICAgICAgIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTOiBjcmVhdGVFdmVudCgnYWRkZmlsZXByb2dyZXNzJyksXG4gICAgICAgICAgICBESURfTE9BRF9JVEVNOiBjcmVhdGVFdmVudCgnYWRkZmlsZScpLFxuXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiBbY3JlYXRlRXZlbnQoJ2Vycm9yJyksIGNyZWF0ZUV2ZW50KCdhZGRmaWxlJyldLFxuXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiBbY3JlYXRlRXZlbnQoJ2Vycm9yJyksIGNyZWF0ZUV2ZW50KCdhZGRmaWxlJyldLFxuXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ3JlbW92ZWZpbGUnKV0sXG5cbiAgICAgICAgICAgIERJRF9QUkVQQVJFX09VVFBVVDogY3JlYXRlRXZlbnQoJ3ByZXBhcmVmaWxlJyksXG5cbiAgICAgICAgICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZXN0YXJ0JyksXG4gICAgICAgICAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlcHJvZ3Jlc3MnKSxcbiAgICAgICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZWFib3J0JyksXG4gICAgICAgICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGUnKSxcbiAgICAgICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkdfQUxMOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVzJyksXG4gICAgICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlcmV2ZXJ0JyksXG5cbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1I6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlJyldLFxuXG4gICAgICAgICAgICBESURfUkVNT1ZFX0lURU06IGNyZWF0ZUV2ZW50KCdyZW1vdmVmaWxlJyksXG5cbiAgICAgICAgICAgIERJRF9VUERBVEVfSVRFTVM6IGNyZWF0ZUV2ZW50KCd1cGRhdGVmaWxlcycpLFxuXG4gICAgICAgICAgICBESURfQUNUSVZBVEVfSVRFTTogY3JlYXRlRXZlbnQoJ2FjdGl2YXRlZmlsZScpLFxuXG4gICAgICAgICAgICBESURfUkVPUkRFUl9JVEVNUzogY3JlYXRlRXZlbnQoJ3Jlb3JkZXJmaWxlcycpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBleHBvc2VFdmVudCA9IGZ1bmN0aW9uIGV4cG9zZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgZXZlbnQgb2JqZWN0IHRvIGJlIGRpc3BhdGNoZWRcbiAgICAgICAgICAgIHZhciBkZXRhaWwgPSBPYmplY3QuYXNzaWduKHsgcG9uZDogZXhwb3J0cyB9LCBldmVudCk7XG4gICAgICAgICAgICBkZWxldGUgZGV0YWlsLnR5cGU7XG4gICAgICAgICAgICB2aWV3LmVsZW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOicgKyBldmVudC50eXBlLCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50IGluZm9cbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWwsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnQgYmVoYXZpb3VyXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLCAvLyB0cmlnZ2VycyBsaXN0ZW5lcnMgb3V0c2lkZSBvZiBzaGFkb3cgcm9vdFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBldmVudCBvYmplY3QgdG8gcGFyYW1zIHVzZWQgZm9yIGBvbigpYCBldmVudCBoYW5kbGVycyBhbmQgY2FsbGJhY2tzIGBvbmluaXQoKWBcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gaWYgaXMgcG9zc2libGUgZXJyb3IgZXZlbnQsIG1ha2UgaXQgdGhlIGZpcnN0IHBhcmFtXG4gICAgICAgICAgICBpZiAoZXZlbnQuaGFzT3duUHJvcGVydHkoJ2Vycm9yJykpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChldmVudC5lcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpbGUgaXMgYWx3YXlzIHNlY3Rpb25cbiAgICAgICAgICAgIGlmIChldmVudC5oYXNPd25Qcm9wZXJ0eSgnZmlsZScpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goZXZlbnQuZmlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFwcGVuZCBvdGhlciBwcm9wc1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gWyd0eXBlJywgJ2Vycm9yJywgJ2ZpbGUnXTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGV2ZW50KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZmlsdGVyZWQuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLnB1c2goZXZlbnRba2V5XSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIG9uKHR5cGUsICgpID0+IHsgfSlcbiAgICAgICAgICAgIGV4cG9ydHMuZmlyZS5hcHBseShleHBvcnRzLCBbZXZlbnQudHlwZV0uY29uY2F0KHBhcmFtcykpO1xuXG4gICAgICAgICAgICAvLyBvbmluaXQgPSAoKSA9PiB7fVxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBzdG9yZS5xdWVyeSgnR0VUX09OJyArIGV2ZW50LnR5cGUudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodm9pZCAwLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByb3V0ZUFjdGlvbnNUb0V2ZW50cyA9IGZ1bmN0aW9uIHJvdXRlQWN0aW9uc1RvRXZlbnRzKGFjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghYWN0aW9ucy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICAgIGFjdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRSb3V0ZXNbYWN0aW9uLnR5cGVdO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3V0ZXMgPSBldmVudFJvdXRlc1thY3Rpb24udHlwZV07XG4gICAgICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHJvdXRlcykgPyByb3V0ZXMgOiBbcm91dGVzXSkuZm9yRWFjaChmdW5jdGlvbihyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpc24ndCBmYW50YXN0aWMsIGJ1dCBiZWNhdXNlIG9mIHRoZSBzdGFja2luZyBvZiBzZXR0aW1lb3V0cyBwbHVnaW5zIGNhbiBoYW5kbGUgdGhlIGRpZF9sb2FkIGJlZm9yZSB0aGUgZGlkX2luaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RJRF9JTklUX0lURU0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlRXZlbnQocm91dGUoYWN0aW9uLmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlRXZlbnQocm91dGUoYWN0aW9uLmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUFVCTElDIEFQSSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vXG4gICAgICAgIHZhciBzZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2goJ1NFVF9PUFRJT05TJywgeyBvcHRpb25zOiBvcHRpb25zIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRGaWxlID0gZnVuY3Rpb24gZ2V0RmlsZShxdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU0nLCBxdWVyeSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHByZXBhcmVGaWxlID0gZnVuY3Rpb24gcHJlcGFyZUZpbGUocXVlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BSRVBBUkUnLCB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiBmdW5jdGlvbiBmYWlsdXJlKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFkZEZpbGUgPSBmdW5jdGlvbiBhZGRGaWxlKHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGFkZEZpbGVzKFt7IHNvdXJjZTogc291cmNlLCBvcHRpb25zOiBvcHRpb25zIH1dLCB7IGluZGV4OiBvcHRpb25zLmluZGV4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShpdGVtcyAmJiBpdGVtc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGlzRmlsZVBvbmRGaWxlID0gZnVuY3Rpb24gaXNGaWxlUG9uZEZpbGUob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmZpbGUgJiYgb2JqLmlkO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZW1vdmVGaWxlID0gZnVuY3Rpb24gcmVtb3ZlRmlsZShxdWVyeSwgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gaWYgb25seSBwYXNzZWQgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcgJiYgIWlzRmlsZVBvbmRGaWxlKHF1ZXJ5KSAmJiAhb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVxdWVzdCBpdGVtIHJlbW92YWxcbiAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgcXVlcnk6IHF1ZXJ5IH0pKTtcblxuICAgICAgICAgICAgLy8gc2VlIGlmIGl0ZW0gaGFzIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgcmV0dXJuIHN0b3JlLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU0nLCBxdWVyeSkgPT09IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFkZEZpbGVzID0gZnVuY3Rpb24gYWRkRmlsZXMoKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgICAgICAgICAgICAgIC8vIHVzZXIgcGFzc2VkIGEgc291cmNlcyBhcnJheVxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaC5hcHBseShzb3VyY2VzLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBhcmdzWzFdIHx8IHt9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2VyIHBhc3NlZCBzb3VyY2VzIGFzIGFyZ3VtZW50cywgbGFzdCBvbmUgbWlnaHQgYmUgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RBcmd1bWVudCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0QXJndW1lbnQgPT09ICdvYmplY3QnICYmICEobGFzdEFyZ3VtZW50IGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgYXJncy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgcmVzdCB0byBzb3VyY2VzXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaC5hcHBseShzb3VyY2VzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnQUREX0lURU1TJywge1xuICAgICAgICAgICAgICAgICAgICBpdGVtczogc291cmNlcyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG9wdGlvbnMuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5BUEksXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IHJlamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRGaWxlcyA9IGZ1bmN0aW9uIGdldEZpbGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHByb2Nlc3NGaWxlID0gZnVuY3Rpb24gcHJvY2Vzc0ZpbGUocXVlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiBmdW5jdGlvbiBmYWlsdXJlKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHByZXBhcmVGaWxlcyA9IGZ1bmN0aW9uIHByZXBhcmVGaWxlcygpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDtcbiAgICAgICAgICAgICAgICBfa2V5MiA8IF9sZW4yO1xuICAgICAgICAgICAgICAgIF9rZXkyKytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBxdWVyaWVzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gcXVlcmllcy5sZW5ndGggPyBxdWVyaWVzIDogZ2V0RmlsZXMoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChpdGVtcy5tYXAocHJlcGFyZUZpbGUpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJvY2Vzc0ZpbGVzID0gZnVuY3Rpb24gcHJvY2Vzc0ZpbGVzKCkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwO1xuICAgICAgICAgICAgICAgIF9rZXkzIDwgX2xlbjM7XG4gICAgICAgICAgICAgICAgX2tleTMrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHF1ZXJpZXMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gICAgICAgICAgICBpZiAoIXF1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVzID0gZ2V0RmlsZXMoKS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgIShpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5JRExFICYmIGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxPQ0FMKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgIT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lORyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgIT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgIT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1JcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChmaWxlcy5tYXAocHJvY2Vzc0ZpbGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChxdWVyaWVzLm1hcChwcm9jZXNzRmlsZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZW1vdmVGaWxlcyA9IGZ1bmN0aW9uIHJlbW92ZUZpbGVzKCkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwO1xuICAgICAgICAgICAgICAgIF9rZXk0IDwgX2xlbjQ7XG4gICAgICAgICAgICAgICAgX2tleTQrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcXVlcmllcyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcblxuICAgICAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXNbcXVlcmllcy5sZW5ndGggLSAxXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gcXVlcmllcy5wb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZmlsZXMgPSBnZXRGaWxlcygpO1xuXG4gICAgICAgICAgICBpZiAoIXF1ZXJpZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICAgICAgZmlsZXMubWFwKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVGaWxlKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIHdoZW4gcmVtb3ZpbmcgYnkgaW5kZXggdGhlIGluZGV4ZXMgc2hpZnQgYWZ0ZXIgZWFjaCBmaWxlIHJlbW92YWwgc28gd2UgbmVlZCB0byBjb252ZXJ0IGluZGV4ZXMgdG8gaWRzXG4gICAgICAgICAgICB2YXIgbWFwcGVkUXVlcmllcyA9IHF1ZXJpZXNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc051bWJlcihxdWVyeSkgPyAoZmlsZXNbcXVlcnldID8gZmlsZXNbcXVlcnldLmlkIDogbnVsbCkgOiBxdWVyeTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbWFwcGVkUXVlcmllcy5tYXAoZnVuY3Rpb24ocSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVGaWxlKHEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV4cG9ydHMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG5cbiAgICAgICAgICAgIG9uKCksXG4gICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgcmVhZFdyaXRlQXBpLFxuICAgICAgICAgICAge30sXG5cbiAgICAgICAgICAgIGNyZWF0ZU9wdGlvbkFQSShzdG9yZSwgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE92ZXJyaWRlIG9wdGlvbnMgZGVmaW5lZCBpbiBvcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2V0T3B0aW9uczogc2V0T3B0aW9ucyxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIExvYWQgdGhlIGdpdmVuIGZpbGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc291cmNlIC0gdGhlIHNvdXJjZSBvZiB0aGUgZmlsZSAoZWl0aGVyIGEgRmlsZSwgYmFzZTY0IGRhdGEgdXJpIG9yIHVybClcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIG9iamVjdCwgeyBpbmRleDogMCB9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYWRkRmlsZTogYWRkRmlsZSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIExvYWQgdGhlIGdpdmVuIGZpbGVzXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHNvdXJjZXMgLSB0aGUgc291cmNlcyBvZiB0aGUgZmlsZXMgdG8gbG9hZFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb2JqZWN0LCB7IGluZGV4OiAwIH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBhZGRGaWxlczogYWRkRmlsZXMsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBmaWxlIG9iamVjdHMgbWF0Y2hpbmcgdGhlIGdpdmVuIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGdldEZpbGU6IGdldEZpbGUsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBVcGxvYWQgZmlsZSB3aXRoIGdpdmVuIG5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHByb2Nlc3NGaWxlOiBwcm9jZXNzRmlsZSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlcXVlc3QgcHJlcGFyZSBvdXRwdXQgZm9yIGZpbGUgd2l0aCBnaXZlbiBuYW1lXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgIH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwcmVwYXJlRmlsZTogcHJlcGFyZUZpbGUsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIGEgZmlsZSBieSBpdHMgbmFtZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBxdWVyeSB7IHN0cmluZywgbnVtYmVyLCBudWxsICB9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVtb3ZlRmlsZTogcmVtb3ZlRmlsZSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE1vdmVzIGEgZmlsZSB0byBhIG5ldyBsb2NhdGlvbiBpbiB0aGUgZmlsZXMgbGlzdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG1vdmVGaWxlOiBmdW5jdGlvbiBtb3ZlRmlsZShxdWVyeSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKCdNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBxdWVyeSwgaW5kZXg6IGluZGV4IH0pO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIGFsbCBmaWxlcyAod3JhcHBlZCBpbiBwdWJsaWMgYXBpKVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGdldEZpbGVzOiBnZXRGaWxlcyxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFN0YXJ0cyB1cGxvYWRpbmcgYWxsIGZpbGVzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZpbGVzOiBwcm9jZXNzRmlsZXMsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDbGVhcnMgYWxsIGZpbGVzIGZyb20gdGhlIGZpbGVzIGxpc3RcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZW1vdmVGaWxlczogcmVtb3ZlRmlsZXMsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTdGFydHMgcHJlcGFyaW5nIG91dHB1dCBvZiBhbGwgZmlsZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwcmVwYXJlRmlsZXM6IHByZXBhcmVGaWxlcyxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFNvcnQgbGlzdCBvZiBmaWxlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2goJ1NPUlQnLCB7IGNvbXBhcmU6IGNvbXBhcmUgfSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEJyb3dzZSB0aGUgZmlsZSBzeXN0ZW0gZm9yIGEgZmlsZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGJyb3dzZTogZnVuY3Rpb24gYnJvd3NlKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkcyB0byBiZSB0cmlnZ2VyIGRpcmVjdGx5IGFzIHVzZXIgYWN0aW9uIG5lZWRzIHRvIGJlIHRyYWNlYWJsZSAoaXMgbm90IHRyYWNlYWJsZSBpbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHZpZXcuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPWZpbGVdJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBEZXN0cm95cyB0aGUgYXBwXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBkZXN0cnVjdGlvblxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLmZpcmUoJ2Rlc3Ryb3knLCB2aWV3LmVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgYWN0aXZlIHByb2Nlc3NlcyAoZmlsZSB1cGxvYWRzLCBmZXRjaGVzLCBzdHVmZiBsaWtlIHRoYXQpXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb3Agb3ZlciBpdGVtcyBhbmQgZGVwZW5kaW5nIG9uIHN0YXRlcyBjYWxsIGFib3J0IGZvciBvbmdvaW5nIHByb2Nlc3Nlc1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnQUJPUlRfQUxMJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGVzdHJveSB2aWV3XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuX2Rlc3Ryb3koKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIGxpc3RlbmluZyB0byByZXNpemVcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgbGlzdGVuaW5nIHRvIHRoZSB2aXNpYmxpdHljaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHZpc2liaWxpdHlIYW5kbGVyKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkaXNwYXRjaCBkZXN0cm95XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfREVTVFJPWScpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJbnNlcnRzIHRoZSBwbHVnaW4gYmVmb3JlIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlJDEoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0QmVmb3JlKHZpZXcuZWxlbWVudCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEluc2VydHMgdGhlIHBsdWdpbiBhZnRlciB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpbnNlcnRBZnRlcjogZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIkMShlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnNlcnRBZnRlcih2aWV3LmVsZW1lbnQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBcHBlbmRzIHRoZSBwbHVnaW4gdG8gdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYXBwZW5kVG86IGZ1bmN0aW9uIGFwcGVuZFRvKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuYXBwZW5kQ2hpbGQodmlldy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVwbGFjZXMgYW4gZWxlbWVudCB3aXRoIHRoZSBhcHBcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXBsYWNlRWxlbWVudDogZnVuY3Rpb24gcmVwbGFjZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgdGhlIGFwcCBiZWZvcmUgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlKHZpZXcuZWxlbWVudCwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1lbWJlciBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlc3RvcmVzIHRoZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVzdG9yZUVsZW1lbnQ6IGZ1bmN0aW9uIHJlc3RvcmVFbGVtZW50KCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBubyBlbGVtZW50IHRvIHJlc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRBZnRlcihvcmlnaW5hbEVsZW1lbnQsIHZpZXcuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG91ciBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHZpZXcuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFwcCByb290IGlzIGF0dGFjaGVkIHRvIGdpdmVuIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlzQXR0YWNoZWRUbzogZnVuY3Rpb24gaXNBdHRhY2hlZFRvKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXcuZWxlbWVudCA9PT0gZWxlbWVudCB8fCBvcmlnaW5hbEVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIHJvb3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldy5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBvbmQgc3RhdHVzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLnF1ZXJ5KCdHRVRfU1RBVFVTJyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBEb25lIVxuICAgICAgICBzdG9yZS5kaXNwYXRjaCgnRElEX0lOSVQnKTtcblxuICAgICAgICAvLyBjcmVhdGUgYWN0dWFsIGFwaSBvYmplY3RcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdChleHBvcnRzKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUFwcE9iamVjdCA9IGZ1bmN0aW9uIGNyZWF0ZUFwcE9iamVjdCgpIHtcbiAgICAgICAgdmFyIGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge307XG4gICAgICAgIGZvcmluKGdldE9wdGlvbnMoKSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XSA9IHZhbHVlWzBdO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXQgYXBwIG9wdGlvbnNcbiAgICAgICAgdmFyIGFwcCA9IGNyZWF0ZUFwcChcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAge30sXG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgICAgIGN1c3RvbU9wdGlvbnNcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyByZXR1cm4gdGhlIHBsdWdpbiBpbnN0YW5jZVxuICAgICAgICByZXR1cm4gYXBwO1xuICAgIH07XG5cbiAgICB2YXIgbG93ZXJDYXNlRmlyc3RMZXR0ZXIgPSBmdW5jdGlvbiBsb3dlckNhc2VGaXJzdExldHRlcihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbiAgICB9O1xuXG4gICAgdmFyIGF0dHJpYnV0ZU5hbWVUb1Byb3BlcnR5TmFtZSA9IGZ1bmN0aW9uIGF0dHJpYnV0ZU5hbWVUb1Byb3BlcnR5TmFtZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0b0NhbWVscyhhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoL15kYXRhLS8sICcnKSk7XG4gICAgfTtcblxuICAgIHZhciBtYXBPYmplY3QgPSBmdW5jdGlvbiBtYXBPYmplY3Qob2JqZWN0LCBwcm9wZXJ0eU1hcCkge1xuICAgICAgICAvLyByZW1vdmUgdW53YW50ZWRcbiAgICAgICAgZm9yaW4ocHJvcGVydHlNYXAsIGZ1bmN0aW9uKHNlbGVjdG9yLCBtYXBwaW5nKSB7XG4gICAgICAgICAgICBmb3JpbihvYmplY3QsIGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSByZWdleHAgc2hvcnRjdXRcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JSZWdFeHAgPSBuZXcgUmVnRXhwKHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgICAgIC8vIHRlc3RzIGlmXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBzZWxlY3RvclJlZ0V4cC50ZXN0KHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIC8vIG5vIG1hdGNoLCBza2lwXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgbWFwcGluZywgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGlzIGFsd2F5cyByZW1vdmVkXG4gICAgICAgICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgb25seSByZW1vdmUsIHdlIGRvbmUhXG4gICAgICAgICAgICAgICAgaWYgKG1hcHBpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHZhbHVlIHRvIG5ldyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhtYXBwaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbbWFwcGluZ10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdG8gZ3JvdXBcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBtYXBwaW5nLmdyb3VwO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChtYXBwaW5nKSAmJiAhb2JqZWN0W2dyb3VwXSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbZ3JvdXBdID0ge307XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqZWN0W2dyb3VwXVtsb3dlckNhc2VGaXJzdExldHRlcihwcm9wZXJ0eS5yZXBsYWNlKHNlbGVjdG9yUmVnRXhwLCAnJykpXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGRvIHN1Ym1hcHBpbmdcbiAgICAgICAgICAgIGlmIChtYXBwaW5nLm1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBtYXBPYmplY3Qob2JqZWN0W21hcHBpbmcuZ3JvdXBdLCBtYXBwaW5nLm1hcHBpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEF0dHJpYnV0ZXNBc09iamVjdCA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNBc09iamVjdChub2RlKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVNYXBwaW5nID1cbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgIC8vIHR1cm4gYXR0cmlidXRlcyBpbnRvIG9iamVjdFxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBmb3Jpbihub2RlLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2gobm9kZS5hdHRyaWJ1dGVzW2luZGV4XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGUubmFtZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uKG9iaiwgYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cihub2RlLCBhdHRyaWJ1dGUubmFtZSk7XG5cbiAgICAgICAgICAgICAgICBvYmpbYXR0cmlidXRlTmFtZVRvUHJvcGVydHlOYW1lKGF0dHJpYnV0ZS5uYW1lKV0gPVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gYXR0cmlidXRlLm5hbWUgPyB0cnVlIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sIHt9KTtcblxuICAgICAgICAvLyBkbyBtYXBwaW5nIG9mIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICAgIG1hcE9iamVjdChvdXRwdXQsIGF0dHJpYnV0ZU1hcHBpbmcpO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBcHBBdEVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVBcHBBdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgLy8gaG93IGF0dHJpYnV0ZXMgb2YgdGhlIGlucHV0IGVsZW1lbnQgYXJlIG1hcHBlZCB0byB0aGUgb3B0aW9ucyBmb3IgdGhlIHBsdWdpblxuICAgICAgICB2YXIgYXR0cmlidXRlTWFwcGluZyA9IHtcbiAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSB0byBvdGhlciBuYW1lXG4gICAgICAgICAgICAnXmNsYXNzJCc6ICdjbGFzc05hbWUnLFxuICAgICAgICAgICAgJ15tdWx0aXBsZSQnOiAnYWxsb3dNdWx0aXBsZScsXG4gICAgICAgICAgICAnXmNhcHR1cmUkJzogJ2NhcHR1cmVNZXRob2QnLFxuICAgICAgICAgICAgJ153ZWJraXRkaXJlY3RvcnkkJzogJ2FsbG93RGlyZWN0b3JpZXNPbmx5JyxcblxuICAgICAgICAgICAgLy8gZ3JvdXAgdW5kZXIgc2luZ2xlIHByb3BlcnR5XG4gICAgICAgICAgICAnXnNlcnZlcic6IHtcbiAgICAgICAgICAgICAgICBncm91cDogJ3NlcnZlcicsXG4gICAgICAgICAgICAgICAgbWFwcGluZzoge1xuICAgICAgICAgICAgICAgICAgICAnXnByb2Nlc3MnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICdecmV2ZXJ0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6ICdyZXZlcnQnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICdeZmV0Y2gnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogJ2ZldGNoJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAnXnJlc3RvcmUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogJ3Jlc3RvcmUnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICdebG9hZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiAnbG9hZCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGRvbid0IGluY2x1ZGUgaW4gb2JqZWN0XG4gICAgICAgICAgICAnXnR5cGUkJzogZmFsc2UsXG4gICAgICAgICAgICAnXmZpbGVzJCc6IGZhbHNlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZCBhZGRpdGlvbmFsIG9wdGlvbiB0cmFuc2xhdG9yc1xuICAgICAgICBhcHBseUZpbHRlcnMoJ1NFVF9BVFRSSUJVVEVfVE9fT1BUSU9OX01BUCcsIGF0dHJpYnV0ZU1hcHBpbmcpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBmaW5hbCBvcHRpb25zIG9iamVjdCBieSBzZXR0aW5nIG9wdGlvbnMgb2JqZWN0IGFuZCB0aGVuIG92ZXJyaWRpbmcgb3B0aW9ucyBzdXBwbGllZCBvbiBlbGVtZW50XG4gICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZU9wdGlvbnMgPSBnZXRBdHRyaWJ1dGVzQXNPYmplY3QoXG4gICAgICAgICAgICBlbGVtZW50Lm5vZGVOYW1lID09PSAnRklFTERTRVQnID8gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPWZpbGVdJykgOiBlbGVtZW50LFxuICAgICAgICAgICAgYXR0cmlidXRlTWFwcGluZ1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIG1lcmdlIHdpdGggb3B0aW9ucyBvYmplY3RcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlT3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChhdHRyaWJ1dGVPcHRpb25zW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChtZXJnZWRPcHRpb25zW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZE9wdGlvbnNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lcmdlZE9wdGlvbnNba2V5XSwgYXR0cmlidXRlT3B0aW9uc1trZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9uc1trZXldID0gYXR0cmlidXRlT3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiBwYXJlbnQgaXMgYSBmaWVsZHNldCwgZ2V0IGZpbGVzIGZyb20gcGFyZW50IGJ5IHNlbGVjdGluZyBhbGwgaW5wdXQgZmllbGRzIHRoYXQgYXJlIG5vdCBmaWxlIHVwbG9hZCBmaWVsZHNcbiAgICAgICAgLy8gdGhlc2Ugd2lsbCB0aGVuIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZSBpbml0aWFsIGZpbGVzXG4gICAgICAgIG1lcmdlZE9wdGlvbnMuZmlsZXMgPSAob3B0aW9ucy5maWxlcyB8fCBbXSkuY29uY2F0KFxuICAgICAgICAgICAgQXJyYXkuZnJvbShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0Om5vdChbdHlwZT1maWxlXSknKSkubWFwKGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBpbnB1dC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaW5wdXQuZGF0YXNldC50eXBlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGJ1aWxkIHBsdWdpblxuICAgICAgICB2YXIgYXBwID0gY3JlYXRlQXBwT2JqZWN0KG1lcmdlZE9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGFkZCBhbHJlYWR5IHNlbGVjdGVkIGZpbGVzXG4gICAgICAgIGlmIChlbGVtZW50LmZpbGVzKSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKGVsZW1lbnQuZmlsZXMpLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgIGFwcC5hZGRGaWxlKGZpbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNlIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICBhcHAucmVwbGFjZUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgLy8gZXhwb3NlXG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgfTtcblxuICAgIC8vIGlmIGFuIGVsZW1lbnQgaXMgcGFzc2VkLCB3ZSBjcmVhdGUgdGhlIGluc3RhbmNlIGF0IHRoYXQgZWxlbWVudCwgaWYgbm90LCB3ZSBqdXN0IGNyZWF0ZSBhbiB1cCBvYmplY3RcbiAgICB2YXIgY3JlYXRlQXBwJDEgPSBmdW5jdGlvbiBjcmVhdGVBcHAoKSB7XG4gICAgICAgIHJldHVybiBpc05vZGUoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKVxuICAgICAgICAgICAgPyBjcmVhdGVBcHBBdEVsZW1lbnQuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpXG4gICAgICAgICAgICA6IGNyZWF0ZUFwcE9iamVjdC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHZhciBQUklWQVRFX01FVEhPRFMgPSBbJ2ZpcmUnLCAnX3JlYWQnLCAnX3dyaXRlJ107XG5cbiAgICB2YXIgY3JlYXRlQXBwQVBJID0gZnVuY3Rpb24gY3JlYXRlQXBwQVBJKGFwcCkge1xuICAgICAgICB2YXIgYXBpID0ge307XG5cbiAgICAgICAgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdChhcHAsIGFwaSwgUFJJVkFURV9NRVRIT0RTKTtcblxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBwbGFjZWhvbGRlcnMgaW4gZ2l2ZW4gc3RyaW5nIHdpdGggcmVwbGFjZW1lbnRzXG4gICAgICogQHBhcmFtIHN0cmluZyAtIFwiRm9vIHtiYXJ9XCJcIlxuICAgICAqIEBwYXJhbSByZXBsYWNlbWVudHMgLSB7IFwiYmFyXCI6IDEwIH1cbiAgICAgKi9cbiAgICB2YXIgcmVwbGFjZUluU3RyaW5nID0gZnVuY3Rpb24gcmVwbGFjZUluU3RyaW5nKHN0cmluZywgcmVwbGFjZW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKD86eyhbYS16QS1aXSspfSkvZywgZnVuY3Rpb24obWF0Y2gsIGdyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnRzW2dyb3VwXTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVXb3JrZXIgPSBmdW5jdGlvbiBjcmVhdGVXb3JrZXIoZm4pIHtcbiAgICAgICAgdmFyIHdvcmtlckJsb2IgPSBuZXcgQmxvYihbJygnLCBmbi50b1N0cmluZygpLCAnKSgpJ10sIHtcbiAgICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHdvcmtlclVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwod29ya2VyQmxvYik7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVSTCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYW5zZmVyOiBmdW5jdGlvbiB0cmFuc2ZlcihtZXNzYWdlLCBjYikge30sXG4gICAgICAgICAgICBwb3N0OiBmdW5jdGlvbiBwb3N0KG1lc3NhZ2UsIGNiLCB0cmFuc2Zlckxpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXG4gICAgICAgICAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKGUuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXJMaXN0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXJtaW5hdGU6IGZ1bmN0aW9uIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJVUkwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGxvYWRJbWFnZSA9IGZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciByZW5hbWVGaWxlID0gZnVuY3Rpb24gcmVuYW1lRmlsZShmaWxlLCBuYW1lKSB7XG4gICAgICAgIHZhciByZW5hbWVkRmlsZSA9IGZpbGUuc2xpY2UoMCwgZmlsZS5zaXplLCBmaWxlLnR5cGUpO1xuICAgICAgICByZW5hbWVkRmlsZS5sYXN0TW9kaWZpZWREYXRlID0gZmlsZS5sYXN0TW9kaWZpZWREYXRlO1xuICAgICAgICByZW5hbWVkRmlsZS5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIHJlbmFtZWRGaWxlO1xuICAgIH07XG5cbiAgICB2YXIgY29weUZpbGUgPSBmdW5jdGlvbiBjb3B5RmlsZShmaWxlKSB7XG4gICAgICAgIHJldHVybiByZW5hbWVGaWxlKGZpbGUsIGZpbGUubmFtZSk7XG4gICAgfTtcblxuICAgIC8vIGFscmVhZHkgcmVnaXN0ZXJlZCBwbHVnaW5zIChjYW4ndCByZWdpc3RlciB0d2ljZSlcbiAgICB2YXIgcmVnaXN0ZXJlZFBsdWdpbnMgPSBbXTtcblxuICAgIC8vIHBhc3MgdXRpbHMgdG8gcGx1Z2luXG4gICAgdmFyIGNyZWF0ZUFwcFBsdWdpbiA9IGZ1bmN0aW9uIGNyZWF0ZUFwcFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICAgIGlmIChyZWdpc3RlcmVkUGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1lbWJlciB0aGlzIHBsdWdpblxuICAgICAgICByZWdpc3RlcmVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG5cbiAgICAgICAgLy8gc2V0dXAhXG4gICAgICAgIHZhciBwbHVnaW5PdXRsaW5lID0gcGx1Z2luKHtcbiAgICAgICAgICAgIGFkZEZpbHRlcjogYWRkRmlsdGVyLFxuICAgICAgICAgICAgdXRpbHM6IHtcbiAgICAgICAgICAgICAgICBUeXBlOiBUeXBlLFxuICAgICAgICAgICAgICAgIGZvcmluOiBmb3JpbixcbiAgICAgICAgICAgICAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgICAgICAgICAgICAgaXNGaWxlOiBpc0ZpbGUsXG4gICAgICAgICAgICAgICAgdG9OYXR1cmFsRmlsZVNpemU6IHRvTmF0dXJhbEZpbGVTaXplLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VJblN0cmluZzogcmVwbGFjZUluU3RyaW5nLFxuICAgICAgICAgICAgICAgIGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZTogZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbjogZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uLFxuICAgICAgICAgICAgICAgIGd1ZXNzdGltYXRlTWltZVR5cGU6IGd1ZXNzdGltYXRlTWltZVR5cGUsXG4gICAgICAgICAgICAgICAgZ2V0RmlsZUZyb21CbG9iOiBnZXRGaWxlRnJvbUJsb2IsXG4gICAgICAgICAgICAgICAgZ2V0RmlsZW5hbWVGcm9tVVJMOiBnZXRGaWxlbmFtZUZyb21VUkwsXG4gICAgICAgICAgICAgICAgY3JlYXRlUm91dGU6IGNyZWF0ZVJvdXRlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZVdvcmtlcjogY3JlYXRlV29ya2VyLFxuICAgICAgICAgICAgICAgIGNyZWF0ZVZpZXc6IGNyZWF0ZVZpZXcsXG4gICAgICAgICAgICAgICAgY3JlYXRlSXRlbUFQSTogY3JlYXRlSXRlbUFQSSxcbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2U6IGxvYWRJbWFnZSxcbiAgICAgICAgICAgICAgICBjb3B5RmlsZTogY29weUZpbGUsXG4gICAgICAgICAgICAgICAgcmVuYW1lRmlsZTogcmVuYW1lRmlsZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVCbG9iOiBjcmVhdGVCbG9iLFxuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW46IGFwcGx5RmlsdGVyQ2hhaW4sXG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nOiBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICAgICBmaWxlQWN0aW9uQnV0dG9uOiBmaWxlQWN0aW9uQnV0dG9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIHBsdWdpbiBvcHRpb25zIHRvIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICBleHRlbmREZWZhdWx0T3B0aW9ucyhwbHVnaW5PdXRsaW5lLm9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvLyBmZWF0dXJlIGRldGVjdGlvbiB1c2VkIGJ5IHN1cHBvcnRlZCgpIG1ldGhvZFxuICAgIHZhciBpc09wZXJhTWluaSA9IGZ1bmN0aW9uIGlzT3BlcmFNaW5pKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5vcGVyYW1pbmkpID09PSAnW29iamVjdCBPcGVyYU1pbmldJztcbiAgICB9O1xuICAgIHZhciBoYXNQcm9taXNlcyA9IGZ1bmN0aW9uIGhhc1Byb21pc2VzKCkge1xuICAgICAgICByZXR1cm4gJ1Byb21pc2UnIGluIHdpbmRvdztcbiAgICB9O1xuICAgIHZhciBoYXNCbG9iU2xpY2UgPSBmdW5jdGlvbiBoYXNCbG9iU2xpY2UoKSB7XG4gICAgICAgIHJldHVybiAnc2xpY2UnIGluIEJsb2IucHJvdG90eXBlO1xuICAgIH07XG4gICAgdmFyIGhhc0NyZWF0ZU9iamVjdFVSTCA9IGZ1bmN0aW9uIGhhc0NyZWF0ZU9iamVjdFVSTCgpIHtcbiAgICAgICAgcmV0dXJuICdVUkwnIGluIHdpbmRvdyAmJiAnY3JlYXRlT2JqZWN0VVJMJyBpbiB3aW5kb3cuVVJMO1xuICAgIH07XG4gICAgdmFyIGhhc1Zpc2liaWxpdHkgPSBmdW5jdGlvbiBoYXNWaXNpYmlsaXR5KCkge1xuICAgICAgICByZXR1cm4gJ3Zpc2liaWxpdHlTdGF0ZScgaW4gZG9jdW1lbnQ7XG4gICAgfTtcbiAgICB2YXIgaGFzVGltaW5nID0gZnVuY3Rpb24gaGFzVGltaW5nKCkge1xuICAgICAgICByZXR1cm4gJ3BlcmZvcm1hbmNlJyBpbiB3aW5kb3c7XG4gICAgfTsgLy8gaU9TIDgueFxuICAgIHZhciBoYXNDU1NTdXBwb3J0cyA9IGZ1bmN0aW9uIGhhc0NTU1N1cHBvcnRzKCkge1xuICAgICAgICByZXR1cm4gJ3N1cHBvcnRzJyBpbiAod2luZG93LkNTUyB8fCB7fSk7XG4gICAgfTsgLy8gdXNlIHRvIGRldGVjdCBTYWZhcmkgOStcbiAgICB2YXIgaXNJRTExID0gZnVuY3Rpb24gaXNJRTExKCkge1xuICAgICAgICByZXR1cm4gL01TSUV8VHJpZGVudC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfTtcblxuICAgIHZhciBzdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFJ1bnMgaW1tZWRpYXRlbHkgYW5kIHRoZW4gcmVtZW1iZXJzIHJlc3VsdCBmb3Igc3Vic2VxdWVudCBjYWxsc1xuICAgICAgICB2YXIgaXNTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgLy8gSGFzIHRvIGJlIGEgYnJvd3NlclxuICAgICAgICAgICAgaXNCcm93c2VyKCkgJiZcbiAgICAgICAgICAgIC8vIENhbid0IHJ1biBvbiBPcGVyYSBNaW5pIGR1ZSB0byBsYWNrIG9mIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgICFpc09wZXJhTWluaSgpICYmXG4gICAgICAgICAgICAvLyBSZXF1aXJlIHRoZXNlIEFQSXMgdG8gZmVhdHVyZSBkZXRlY3QgYSBtb2Rlcm4gYnJvd3NlclxuICAgICAgICAgICAgaGFzVmlzaWJpbGl0eSgpICYmXG4gICAgICAgICAgICBoYXNQcm9taXNlcygpICYmXG4gICAgICAgICAgICBoYXNCbG9iU2xpY2UoKSAmJlxuICAgICAgICAgICAgaGFzQ3JlYXRlT2JqZWN0VVJMKCkgJiZcbiAgICAgICAgICAgIGhhc1RpbWluZygpICYmXG4gICAgICAgICAgICAvLyBkb2Vzbid0IG5lZWQgQ1NTU3VwcG9ydHMgYnV0IGlzIGEgZ29vZCB3YXkgdG8gZGV0ZWN0IFNhZmFyaSA5KyAod2UgZG8gd2FudCB0byBzdXBwb3J0IElFMTEgdGhvdWdoKVxuICAgICAgICAgICAgKGhhc0NTU1N1cHBvcnRzKCkgfHwgaXNJRTExKCkpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgLyoqXG4gICAgICogUGx1Z2luIGludGVybmFsIHN0YXRlIChvdmVyIGFsbCBpbnN0YW5jZXMpXG4gICAgICovXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAvLyBhY3RpdmUgYXBwIGluc3RhbmNlcywgdXNlZCB0byByZWRyYXcgdGhlIGFwcHMgYW5kIHRvIGZpbmQgdGhlIGxhdGVyXG4gICAgICAgIGFwcHM6IFtdLFxuICAgIH07XG5cbiAgICAvLyBwbHVnaW4gbmFtZVxuICAgIHZhciBuYW1lID0gJ2ZpbGVwb25kJztcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBQbHVnaW4gbWV0aG9kc1xuICAgICAqL1xuICAgIHZhciBmbiA9IGZ1bmN0aW9uIGZuKCkge307XG4gICAgZXhwb3J0cy5TdGF0dXMgPSB7fTtcbiAgICBleHBvcnRzLkZpbGVTdGF0dXMgPSB7fTtcbiAgICBleHBvcnRzLkZpbGVPcmlnaW4gPSB7fTtcbiAgICBleHBvcnRzLk9wdGlvblR5cGVzID0ge307XG4gICAgZXhwb3J0cy5jcmVhdGUgPSBmbjtcbiAgICBleHBvcnRzLmRlc3Ryb3kgPSBmbjtcbiAgICBleHBvcnRzLnBhcnNlID0gZm47XG4gICAgZXhwb3J0cy5maW5kID0gZm47XG4gICAgZXhwb3J0cy5yZWdpc3RlclBsdWdpbiA9IGZuO1xuICAgIGV4cG9ydHMuZ2V0T3B0aW9ucyA9IGZuO1xuICAgIGV4cG9ydHMuc2V0T3B0aW9ucyA9IGZuO1xuXG4gICAgLy8gaWYgbm90IHN1cHBvcnRlZCwgbm8gQVBJXG4gICAgaWYgKHN1cHBvcnRlZCgpKSB7XG4gICAgICAgIC8vIHN0YXJ0IHBhaW50ZXIgYW5kIGZpcmUgbG9hZCBldmVudFxuICAgICAgICBjcmVhdGVQYWludGVyKFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYXBwcy5mb3JFYWNoKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBwLl9yZWFkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24odHMpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hcHBzLmZvckVhY2goZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHAuX3dyaXRlKHRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBmaXJlIGxvYWRlZCBldmVudCBzbyB3ZSBrbm93IHdoZW4gRmlsZVBvbmQgaXMgYXZhaWxhYmxlXG4gICAgICAgIHZhciBkaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICAgICAgICAgICAgLy8gbGV0IG90aGVycyBrbm93IHdlIGhhdmUgYXJlYSByZWFkeVxuICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOmxvYWRlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWQ6IHN1cHBvcnRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZTogZXhwb3J0cy5jcmVhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0cm95OiBleHBvcnRzLmRlc3Ryb3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZTogZXhwb3J0cy5wYXJzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmQ6IGV4cG9ydHMuZmluZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUGx1Z2luOiBleHBvcnRzLnJlZ2lzdGVyUGx1Z2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uczogZXhwb3J0cy5zZXRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBjbGVhbiB1cCBldmVudFxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRpc3BhdGNoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgICAvLyBtb3ZlIHRvIGJhY2sgb2YgZXhlY3V0aW9uIHF1ZXVlLCBGaWxlUG9uZCBzaG91bGQgaGF2ZSBiZWVuIGV4cG9ydGVkIGJ5IHRoZW5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBkaXNwYXRjaCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGVzIHRoZSBPcHRpb25UeXBlcyBvYmplY3QgYmFzZWQgb24gdGhlIGN1cnJlbnQgb3B0aW9uc1xuICAgICAgICB2YXIgdXBkYXRlT3B0aW9uVHlwZXMgPSBmdW5jdGlvbiB1cGRhdGVPcHRpb25UeXBlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JpbihnZXRPcHRpb25zKCksIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLk9wdGlvblR5cGVzW2tleV0gPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGV4cG9ydHMuU3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgU3RhdHVzKTtcbiAgICAgICAgZXhwb3J0cy5GaWxlT3JpZ2luID0gT2JqZWN0LmFzc2lnbih7fSwgRmlsZU9yaWdpbik7XG4gICAgICAgIGV4cG9ydHMuRmlsZVN0YXR1cyA9IE9iamVjdC5hc3NpZ24oe30sIEl0ZW1TdGF0dXMpO1xuXG4gICAgICAgIGV4cG9ydHMuT3B0aW9uVHlwZXMgPSB7fTtcbiAgICAgICAgdXBkYXRlT3B0aW9uVHlwZXMoKTtcblxuICAgICAgICAvLyBjcmVhdGUgbWV0aG9kLCBjcmVhdGVzIGFwcHMgYW5kIGFkZHMgdGhlbSB0byB0aGUgYXBwIGFycmF5XG4gICAgICAgIGV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgICAgICAgdmFyIGFwcCA9IGNyZWF0ZUFwcCQxLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGFwcC5vbignZGVzdHJveScsIGV4cG9ydHMuZGVzdHJveSk7XG4gICAgICAgICAgICBzdGF0ZS5hcHBzLnB1c2goYXBwKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBcHBBUEkoYXBwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkZXN0cm95cyBhcHBzIGFuZCByZW1vdmVzIHRoZW0gZnJvbSB0aGUgYXBwIGFycmF5XG4gICAgICAgIGV4cG9ydHMuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koaG9vaykge1xuICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIHRoZSBhcHAgd2FzIGRlc3Ryb3llZCBzdWNjZXNzZnVsbHlcbiAgICAgICAgICAgIHZhciBpbmRleFRvUmVtb3ZlID0gc3RhdGUuYXBwcy5maW5kSW5kZXgoZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcC5pc0F0dGFjaGVkVG8oaG9vayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbmRleFRvUmVtb3ZlID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBhcHBzXG4gICAgICAgICAgICAgICAgdmFyIGFwcCA9IHN0YXRlLmFwcHMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBkb20gZWxlbWVudFxuICAgICAgICAgICAgICAgIGFwcC5yZXN0b3JlRWxlbWVudCgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwYXJzZXMgdGhlIGdpdmVuIGNvbnRleHQgZm9yIHBsdWdpbnMgKGRvZXMgbm90IGluY2x1ZGUgdGhlIGNvbnRleHQgZWxlbWVudCBpdHNlbGYpXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBnZXQgYWxsIHBvc3NpYmxlIGhvb2tzXG4gICAgICAgICAgICB2YXIgbWF0Y2hlZEhvb2tzID0gQXJyYXkuZnJvbShjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgbmFtZSkpO1xuXG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGFscmVhZHkgYWN0aXZlIGhvb2tzXG4gICAgICAgICAgICB2YXIgbmV3SG9va3MgPSBtYXRjaGVkSG9va3MuZmlsdGVyKGZ1bmN0aW9uKG5ld0hvb2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXN0YXRlLmFwcHMuZmluZChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcC5pc0F0dGFjaGVkVG8obmV3SG9vayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBpbnN0YW5jZSBmb3IgZWFjaCBob29rXG4gICAgICAgICAgICByZXR1cm4gbmV3SG9va3MubWFwKGZ1bmN0aW9uKGhvb2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5jcmVhdGUoaG9vayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZXR1cm5zIGFuIGFwcCBiYXNlZCBvbiB0aGUgZ2l2ZW4gZWxlbWVudCBob29rXG4gICAgICAgIGV4cG9ydHMuZmluZCA9IGZ1bmN0aW9uIGZpbmQoaG9vaykge1xuICAgICAgICAgICAgdmFyIGFwcCA9IHN0YXRlLmFwcHMuZmluZChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwLmlzQXR0YWNoZWRUbyhob29rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFhcHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBcHBBUEkoYXBwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhZGRzIGEgcGx1Z2luIGV4dGVuc2lvblxuICAgICAgICBleHBvcnRzLnJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4oKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZWdpc3RlciBwbHVnaW5zXG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2goY3JlYXRlQXBwUGx1Z2luKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIE9wdGlvblR5cGVzLCBlYWNoIHBsdWdpbiBtaWdodCBoYXZlIGV4dGVuZGVkIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICAgIHVwZGF0ZU9wdGlvblR5cGVzKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZXhwb3J0cy5nZXRPcHRpb25zID0gZnVuY3Rpb24gZ2V0T3B0aW9ucyQxKCkge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICAgIGZvcmluKGdldE9wdGlvbnMoKSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG9wdHNba2V5XSA9IHZhbHVlWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgICAgfTtcblxuICAgICAgICBleHBvcnRzLnNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zJDEob3B0cykge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIHBsdWdpbnNcbiAgICAgICAgICAgICAgICBzdGF0ZS5hcHBzLmZvckVhY2goZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcC5zZXRPcHRpb25zKG9wdHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGUgZGVmYXVsdHNcbiAgICAgICAgICAgICAgICBzZXRPcHRpb25zKG9wdHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXR1cm4gbmV3IG9wdGlvbnNcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmdldE9wdGlvbnMoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filepond/dist/filepond.js\n");

/***/ }),

/***/ "./node_modules/filepond/dist/filepond.min.css":
/*!*****************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.min.css ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5taW4uY3NzIiwibWFwcGluZ3MiOiI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kL2Rpc3QvZmlsZXBvbmQubWluLmNzcz9kYWZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filepond/dist/filepond.min.css\n");

/***/ }),

/***/ "./assets/ts/field/gallery.ts":
/*!************************************!*\
  !*** ./assets/ts/field/gallery.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _options_variables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../options/variables */ \"./assets/ts/options/variables.ts\");\n/* harmony import */ var _module_modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../module/modal */ \"./assets/ts/module/modal.ts\");\n\n\ndocument.addEventListener('click', (event) => {\n    const target = event.target;\n    const btnRemoveCard = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._CARD.remove);\n    const elCard = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._CARD.card);\n    const elList = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._GALLERY.list);\n    const btnDeleteSelected = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._GALLERY.actions.delete);\n    const btnCancel = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._GALLERY.actions.cancel);\n    const btnAdd = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._GALLERY.actions.add);\n    const typeGallery = elList === null || elList === void 0 ? void 0 : elList.getAttribute('data-type');\n    if (!elList) {\n        return;\n    }\n    if (btnRemoveCard || elCard || btnDeleteSelected || btnCancel || btnAdd) {\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    /**\n     * Remove card from gallery\n     */\n    if (btnRemoveCard && elCard) {\n        elCard.remove();\n        handleMultipleDelete(elList);\n    }\n    /**\n     * Select card from gallery\n     */\n    if (elCard && !btnRemoveCard) {\n        if (!elCard.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._GALLERY.list + '[data-type=\"field\"]')) {\n            return;\n        }\n        const checkbox = elCard.querySelector('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._CARD.checkbox);\n        if (checkbox) {\n            checkbox.checked = !checkbox.checked;\n            handleMultipleDelete(elList);\n        }\n    }\n    /**\n     * Delete selected cards\n     */\n    if (btnDeleteSelected) {\n        const cards = elList.querySelectorAll('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._CARD.card);\n        cards.forEach((card) => {\n            const checkbox = card.querySelector('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._CARD.checkbox);\n            if (!checkbox.checked) {\n                card.remove();\n            }\n        });\n        handleMultipleDelete(elList);\n    }\n    /**\n     * Cancel delete selected cards\n     */\n    if (btnCancel) {\n        const checkboxes = elList.querySelectorAll('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._CARD.checkbox);\n        checkboxes.forEach((checkbox) => {\n            checkbox.checked = true;\n        });\n        handleMultipleDelete(elList);\n    }\n    /**\n     * Open modal library\n     */\n    if (btnAdd) {\n        (0,_module_modal__WEBPACK_IMPORTED_MODULE_1__.handlerOpenModalLibrary)(elList, getCheckedCards(elList));\n    }\n});\nfunction checkingUnSelectedCard(wrapper) {\n    let selected = false;\n    const checkboxes = wrapper.querySelectorAll('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._CARD.checkbox);\n    checkboxes.forEach((checkbox) => {\n        if (!checkbox.checked) {\n            selected = true;\n        }\n    });\n    return selected;\n}\nfunction handleMultipleDelete(wrapper) {\n    if (checkingUnSelectedCard(wrapper)) {\n        wrapper.classList.add('is-multiple_delete');\n    }\n    else {\n        wrapper.classList.remove('is-multiple_delete');\n    }\n}\nfunction getCheckedCards(wrapper) {\n    let selected = [];\n    const checkboxes = wrapper.querySelectorAll('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._CARD.checkbox);\n    checkboxes.forEach((checkbox) => {\n        selected.push(Number(checkbox.value));\n    });\n    return selected;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixDQUFDLEdBQUcsR0FBRyxxREFBSyxDQUFDLFFBQVEsQ0FBaUMsQ0FBQztJQUVsRyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7UUFDNUIsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDMUMsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLFFBQVEsQ0FBQztBQUNwQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9hc3NldHMvdHMvZmllbGQvZ2FsbGVyeS50cz9iZmZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7X0NBUkQsIF9HQUxMRVJZfSBmcm9tIFwiLi4vb3B0aW9ucy92YXJpYWJsZXNcIjtcbmltcG9ydCB7aGFuZGxlck9wZW5Nb2RhbExpYnJhcnl9IGZyb20gXCIuLi9tb2R1bGUvbW9kYWxcIjtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgRWxlbWVudDtcbiAgICBjb25zdCBidG5SZW1vdmVDYXJkID0gdGFyZ2V0LmNsb3Nlc3QoJy4nICsgX0NBUkQucmVtb3ZlKTtcbiAgICBjb25zdCBlbENhcmQgPSB0YXJnZXQuY2xvc2VzdCgnLicgKyBfQ0FSRC5jYXJkKTtcbiAgICBjb25zdCBlbExpc3QgPSA8SFRNTEVsZW1lbnQ+IHRhcmdldC5jbG9zZXN0KCcuJyArIF9HQUxMRVJZLmxpc3QpO1xuICAgIGNvbnN0IGJ0bkRlbGV0ZVNlbGVjdGVkID0gdGFyZ2V0LmNsb3Nlc3QoJy4nICsgX0dBTExFUlkuYWN0aW9ucy5kZWxldGUpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICAgIGNvbnN0IGJ0bkNhbmNlbCA9IHRhcmdldC5jbG9zZXN0KCcuJyArIF9HQUxMRVJZLmFjdGlvbnMuY2FuY2VsKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICBjb25zdCBidG5BZGQgPSB0YXJnZXQuY2xvc2VzdCgnLicgKyBfR0FMTEVSWS5hY3Rpb25zLmFkZCkgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgY29uc3QgdHlwZUdhbGxlcnkgPSBlbExpc3Q/LmdldEF0dHJpYnV0ZSgnZGF0YS10eXBlJyk7XG5cbiAgICBpZighZWxMaXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZihidG5SZW1vdmVDYXJkIHx8IGVsQ2FyZCB8fCBidG5EZWxldGVTZWxlY3RlZCB8fCBidG5DYW5jZWwgfHwgYnRuQWRkKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjYXJkIGZyb20gZ2FsbGVyeVxuICAgICAqL1xuICAgIGlmKGJ0blJlbW92ZUNhcmQgJiYgZWxDYXJkKSB7XG4gICAgICAgIGVsQ2FyZC5yZW1vdmUoKTtcbiAgICAgICAgaGFuZGxlTXVsdGlwbGVEZWxldGUoZWxMaXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgY2FyZCBmcm9tIGdhbGxlcnlcbiAgICAgKi9cbiAgICBpZihlbENhcmQgJiYgIWJ0blJlbW92ZUNhcmQpIHtcbiAgICAgICAgaWYoIWVsQ2FyZC5jbG9zZXN0KCcuJyArIF9HQUxMRVJZLmxpc3QgKyAnW2RhdGEtdHlwZT1cImZpZWxkXCJdJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoZWNrYm94ID0gZWxDYXJkLnF1ZXJ5U2VsZWN0b3IoJy4nICsgX0NBUkQuY2hlY2tib3gpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgIGlmKGNoZWNrYm94KSB7XG4gICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gIWNoZWNrYm94LmNoZWNrZWQ7XG4gICAgICAgICAgICBoYW5kbGVNdWx0aXBsZURlbGV0ZShlbExpc3QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHNlbGVjdGVkIGNhcmRzXG4gICAgICovXG4gICAgaWYoYnRuRGVsZXRlU2VsZWN0ZWQpIHtcbiAgICAgICAgY29uc3QgY2FyZHMgPSBlbExpc3QucXVlcnlTZWxlY3RvckFsbCgnLicgKyBfQ0FSRC5jYXJkKTtcbiAgICAgICAgY2FyZHMuZm9yRWFjaCgoY2FyZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tib3ggPSBjYXJkLnF1ZXJ5U2VsZWN0b3IoJy4nICsgX0NBUkQuY2hlY2tib3gpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmKCFjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgY2FyZC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaGFuZGxlTXVsdGlwbGVEZWxldGUoZWxMaXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgZGVsZXRlIHNlbGVjdGVkIGNhcmRzXG4gICAgICovXG4gICAgaWYoYnRuQ2FuY2VsKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSBlbExpc3QucXVlcnlTZWxlY3RvckFsbCgnLicgKyBfQ0FSRC5jaGVja2JveCkgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgICAgICAgY2hlY2tib3hlcy5mb3JFYWNoKChjaGVja2JveCkgPT4ge1xuICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGhhbmRsZU11bHRpcGxlRGVsZXRlKGVsTGlzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiBtb2RhbCBsaWJyYXJ5XG4gICAgICovXG4gICAgaWYoYnRuQWRkKSB7XG4gICAgICAgIGhhbmRsZXJPcGVuTW9kYWxMaWJyYXJ5KGVsTGlzdCwgZ2V0Q2hlY2tlZENhcmRzKGVsTGlzdCkpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBjaGVja2luZ1VuU2VsZWN0ZWRDYXJkKHdyYXBwZXI6IEhUTUxFbGVtZW50KSA6IGJvb2xlYW4ge1xuICAgIGxldCBzZWxlY3RlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgX0NBUkQuY2hlY2tib3gpIGFzIE5vZGVMaXN0T2Y8SFRNTElucHV0RWxlbWVudD47XG5cbiAgICBjaGVja2JveGVzLmZvckVhY2goKGNoZWNrYm94KSA9PiB7XG4gICAgICAgIGlmKCFjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzZWxlY3RlZDtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTXVsdGlwbGVEZWxldGUod3JhcHBlcjogSFRNTEVsZW1lbnQpIDogdm9pZCB7XG4gICAgaWYoY2hlY2tpbmdVblNlbGVjdGVkQ2FyZCh3cmFwcGVyKSkge1xuICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2lzLW11bHRpcGxlX2RlbGV0ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnaXMtbXVsdGlwbGVfZGVsZXRlJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGVja2VkQ2FyZHMod3JhcHBlcjogSFRNTEVsZW1lbnQpIDogbnVtYmVyW10ge1xuICAgIGxldCBzZWxlY3RlZDogbnVtYmVyW10gPSBbXTtcbiAgICBjb25zdCBjaGVja2JveGVzID0gd3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIF9DQVJELmNoZWNrYm94KSBhcyBOb2RlTGlzdE9mPEhUTUxJbnB1dEVsZW1lbnQ+O1xuXG4gICAgY2hlY2tib3hlcy5mb3JFYWNoKChjaGVja2JveCkgPT4ge1xuICAgICAgICBzZWxlY3RlZC5wdXNoKE51bWJlcihjaGVja2JveC52YWx1ZSkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlbGVjdGVkO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/ts/field/gallery.ts\n");

/***/ }),

/***/ "./assets/ts/field/library.ts":
/*!************************************!*\
  !*** ./assets/ts/field/library.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _module_delete__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../module/delete */ \"./assets/ts/module/delete.ts\");\n/* harmony import */ var _options_variables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options/variables */ \"./assets/ts/options/variables.ts\");\n/* harmony import */ var _handler_api_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../handler/api/list */ \"./assets/ts/handler/api/list.ts\");\n/* harmony import */ var _template_card__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../template/card */ \"./assets/ts/template/card.ts\");\n\n\n\n\ndocument.addEventListener('click', (event) => {\n    const target = event.target;\n    const elList = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_1__._LIBRARY.list);\n    const elCard = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_1__._CARD.card);\n    const btnRemoveCard = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_1__._CARD.remove);\n    const btnLoadMore = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_1__._LIBRARY.actions.load_more);\n    if (btnRemoveCard || btnLoadMore) {\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    if (btnRemoveCard) {\n        (0,_module_delete__WEBPACK_IMPORTED_MODULE_0__.handlerOpenModalDelete)(elCard);\n    }\n    if (btnLoadMore) {\n        const page = Number(elList.getAttribute('data-page'));\n        const limit = Number(elList.getAttribute('data-limit'));\n        const itemsEl = elList.querySelector('.lm-library__items');\n        btnLoadMore.classList.add('is-loading');\n        (0,_handler_api_list__WEBPACK_IMPORTED_MODULE_2__.handlerList)(limit, page).then((response) => {\n            itemsEl.insertAdjacentHTML('beforeend', response.data.map((item) => {\n                return (0,_template_card__WEBPACK_IMPORTED_MODULE_3__.card)(item);\n            }).join(''));\n            if (response.data.length < limit) {\n                btnLoadMore.style.display = 'none';\n            }\n            elList.setAttribute('data-page', (page + 1).toString());\n            btnLoadMore.classList.remove('is-loading');\n        }).catch((error) => { });\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvZmllbGQvbGlicmFyeS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RDtBQUNIO0FBQ0w7QUFDVjtBQUV0QyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7SUFDekMsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQWlCLENBQUM7SUFFdkMsTUFBTSxNQUFNLEdBQWlCLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFHLHdEQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDakUsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcscURBQUssQ0FBQyxJQUFJLENBQWdCLENBQUM7SUFDL0QsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcscURBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN6RCxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsR0FBRyx3REFBUSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQXNCLENBQUM7SUFFMUYsSUFBRyxhQUFhLElBQUksV0FBVyxFQUFFO1FBQzdCLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN2QixLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7S0FDM0I7SUFFRCxJQUFHLGFBQWEsRUFBRTtRQUNkLHNFQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ2xDO0lBRUQsSUFBRyxXQUFXLEVBQUU7UUFDWixNQUFNLElBQUksR0FBSSxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQ3ZELE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7UUFDeEQsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLGFBQWEsQ0FBQyxvQkFBb0IsQ0FBZ0IsQ0FBQztRQUMxRSxXQUFXLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUV4Qyw4REFBVyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRTtZQUN2QyxPQUFPLENBQUMsa0JBQWtCLENBQUMsV0FBVyxFQUNsQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO2dCQUN2QixPQUFPLG9EQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdEIsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFakIsSUFBRyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLEVBQUU7Z0JBQzdCLFdBQVcsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQzthQUN0QztZQUVELE1BQU0sQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDeEQsV0FBVyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDL0MsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsR0FBRSxDQUFDLENBQUMsQ0FBQztLQUMzQjtBQUVMLENBQUMsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9hc3NldHMvdHMvZmllbGQvbGlicmFyeS50cz9mY2NhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aGFuZGxlck9wZW5Nb2RhbERlbGV0ZX0gZnJvbSBcIi4uL21vZHVsZS9kZWxldGVcIjtcbmltcG9ydCB7X0NBUkQsIF9MSUJSQVJZfSBmcm9tIFwiLi4vb3B0aW9ucy92YXJpYWJsZXNcIjtcbmltcG9ydCB7aGFuZGxlckxpc3R9IGZyb20gXCIuLi9oYW5kbGVyL2FwaS9saXN0XCI7XG5pbXBvcnQge2NhcmR9IGZyb20gXCIuLi90ZW1wbGF0ZS9jYXJkXCI7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEVsZW1lbnQ7XG5cbiAgICBjb25zdCBlbExpc3QgPSA8SFRNTEVsZW1lbnQ+IHRhcmdldC5jbG9zZXN0KCcuJyArIF9MSUJSQVJZLmxpc3QpO1xuICAgIGNvbnN0IGVsQ2FyZCA9IHRhcmdldC5jbG9zZXN0KCcuJyArIF9DQVJELmNhcmQpIGFzIEhUTUxFbGVtZW50O1xuICAgIGNvbnN0IGJ0blJlbW92ZUNhcmQgPSB0YXJnZXQuY2xvc2VzdCgnLicgKyBfQ0FSRC5yZW1vdmUpO1xuICAgIGNvbnN0IGJ0bkxvYWRNb3JlID0gdGFyZ2V0LmNsb3Nlc3QoJy4nICsgX0xJQlJBUlkuYWN0aW9ucy5sb2FkX21vcmUpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuXG4gICAgaWYoYnRuUmVtb3ZlQ2FyZCB8fCBidG5Mb2FkTW9yZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBpZihidG5SZW1vdmVDYXJkKSB7XG4gICAgICAgIGhhbmRsZXJPcGVuTW9kYWxEZWxldGUoZWxDYXJkKTtcbiAgICB9XG5cbiAgICBpZihidG5Mb2FkTW9yZSkge1xuICAgICAgICBjb25zdCBwYWdlID0gIE51bWJlcihlbExpc3QuZ2V0QXR0cmlidXRlKCdkYXRhLXBhZ2UnKSk7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gTnVtYmVyKGVsTGlzdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGltaXQnKSk7XG4gICAgICAgIGNvbnN0IGl0ZW1zRWwgPSBlbExpc3QucXVlcnlTZWxlY3RvcignLmxtLWxpYnJhcnlfX2l0ZW1zJykgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIGJ0bkxvYWRNb3JlLmNsYXNzTGlzdC5hZGQoJ2lzLWxvYWRpbmcnKTtcblxuICAgICAgICBoYW5kbGVyTGlzdChsaW1pdCwgcGFnZSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGl0ZW1zRWwuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXJkKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpKTtcblxuICAgICAgICAgICAgaWYocmVzcG9uc2UuZGF0YS5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGJ0bkxvYWRNb3JlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsTGlzdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFnZScsIChwYWdlICsgMSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBidG5Mb2FkTW9yZS5jbGFzc0xpc3QucmVtb3ZlKCdpcy1sb2FkaW5nJyk7XG4gICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge30pO1xuICAgIH1cblxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./assets/ts/field/library.ts\n");

/***/ }),

/***/ "./assets/ts/field/media.ts":
/*!**********************************!*\
  !*** ./assets/ts/field/media.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _options_variables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../options/variables */ \"./assets/ts/options/variables.ts\");\n/* harmony import */ var _module_modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../module/modal */ \"./assets/ts/module/modal.ts\");\n\n\ndocument.addEventListener('click', (event) => {\n    const target = event.target;\n    const btnSelect = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._MEDIA.actions.select);\n    const btnDelete = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._MEDIA.actions.delete);\n    const elField = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._MEDIA.field);\n    if (!elField) {\n        return;\n    }\n    const elInput = elField.querySelector('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._MEDIA.value);\n    const elPreview = elField.querySelector('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._MEDIA.preview);\n    /**\n     * Open modal library\n     */\n    if (btnSelect) {\n        (0,_module_modal__WEBPACK_IMPORTED_MODULE_1__.handlerOpenModalLibrary)(elField, [Number(elInput.value)]);\n    }\n    /**\n     * Delete selected media\n     */\n    if (btnDelete) {\n        elField.classList.remove('is-active');\n        elInput.value = '';\n        const elPreviewImage = elPreview.querySelector('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._MEDIA.image);\n        if (elPreviewImage) {\n            elPreviewImage.remove();\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvZmllbGQvbWVkaWEudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQTZEO0FBQ0w7QUFFeEQsUUFBUSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFO0lBQ3pDLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFpQixDQUFDO0lBRXZDLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFHLHNEQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBc0IsQ0FBQztJQUNuRixNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsR0FBRyxzREFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQXNCLENBQUM7SUFDbkYsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsc0RBQU0sQ0FBQyxLQUFLLENBQWdCLENBQUM7SUFFbEUsSUFBRyxDQUFDLE9BQU8sRUFBRTtRQUNULE9BQU87S0FDVjtJQUVELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsR0FBRyxHQUFHLHNEQUFNLENBQUMsS0FBSyxDQUFxQixDQUFDO0lBQzlFLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsR0FBRyxHQUFHLHNEQUFNLENBQUMsT0FBTyxDQUFnQixDQUFDO0lBRTdFOztPQUVHO0lBQ0gsSUFBRyxTQUFTLEVBQUU7UUFDVixzRUFBdUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUM3RDtJQUVEOztPQUVHO0lBQ0gsSUFBRyxTQUFTLEVBQUU7UUFDVixPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN0QyxPQUFPLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUVuQixNQUFNLGNBQWMsR0FBRyxTQUFTLENBQUMsYUFBYSxDQUFDLEdBQUcsR0FBRyxzREFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRW5FLElBQUcsY0FBYyxFQUFFO1lBQ2YsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQzNCO0tBQ0o7QUFDTCxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vYXNzZXRzL3RzL2ZpZWxkL21lZGlhLnRzP2MzNDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtfQ0FSRCwgX0dBTExFUlksIF9NRURJQX0gZnJvbSBcIi4uL29wdGlvbnMvdmFyaWFibGVzXCI7XG5pbXBvcnQge2hhbmRsZXJPcGVuTW9kYWxMaWJyYXJ5fSBmcm9tIFwiLi4vbW9kdWxlL21vZGFsXCI7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEVsZW1lbnQ7XG5cbiAgICBjb25zdCBidG5TZWxlY3QgPSB0YXJnZXQuY2xvc2VzdCgnLicgKyBfTUVESUEuYWN0aW9ucy5zZWxlY3QpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICAgIGNvbnN0IGJ0bkRlbGV0ZSA9IHRhcmdldC5jbG9zZXN0KCcuJyArIF9NRURJQS5hY3Rpb25zLmRlbGV0ZSkgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgY29uc3QgZWxGaWVsZCA9IHRhcmdldC5jbG9zZXN0KCcuJyArIF9NRURJQS5maWVsZCkgYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICBpZighZWxGaWVsZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZWxJbnB1dCA9IGVsRmllbGQucXVlcnlTZWxlY3RvcignLicgKyBfTUVESUEudmFsdWUpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgY29uc3QgZWxQcmV2aWV3ID0gZWxGaWVsZC5xdWVyeVNlbGVjdG9yKCcuJyArIF9NRURJQS5wcmV2aWV3KSBhcyBIVE1MRWxlbWVudDtcblxuICAgIC8qKlxuICAgICAqIE9wZW4gbW9kYWwgbGlicmFyeVxuICAgICAqL1xuICAgIGlmKGJ0blNlbGVjdCkge1xuICAgICAgICBoYW5kbGVyT3Blbk1vZGFsTGlicmFyeShlbEZpZWxkLCBbTnVtYmVyKGVsSW5wdXQudmFsdWUpXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHNlbGVjdGVkIG1lZGlhXG4gICAgICovXG4gICAgaWYoYnRuRGVsZXRlKSB7XG4gICAgICAgIGVsRmllbGQuY2xhc3NMaXN0LnJlbW92ZSgnaXMtYWN0aXZlJyk7XG4gICAgICAgIGVsSW5wdXQudmFsdWUgPSAnJztcblxuICAgICAgICBjb25zdCBlbFByZXZpZXdJbWFnZSA9IGVsUHJldmlldy5xdWVyeVNlbGVjdG9yKCcuJyArIF9NRURJQS5pbWFnZSk7XG5cbiAgICAgICAgaWYoZWxQcmV2aWV3SW1hZ2UpIHtcbiAgICAgICAgICAgIGVsUHJldmlld0ltYWdlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./assets/ts/field/media.ts\n");

/***/ }),

/***/ "./assets/ts/field/upload.ts":
/*!***********************************!*\
  !*** ./assets/ts/field/upload.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _options_variables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../options/variables */ \"./assets/ts/options/variables.ts\");\n/* harmony import */ var _module_upload__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../module/upload */ \"./assets/ts/module/upload.ts\");\n\n\ndocument.addEventListener('click', (event) => {\n    const target = event.target;\n    const elUpload = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_0__._UPLOAD.actions.modal_upload);\n    const elField = target.closest('.lm-field');\n    if (elUpload) {\n        (0,_module_upload__WEBPACK_IMPORTED_MODULE_1__.handlerOpenModalUpload)(elField);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvZmllbGQvdXBsb2FkLnRzIiwibWFwcGluZ3MiOiI7OztBQUE2QztBQUNXO0FBRXhELFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtJQUN6QyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBaUIsQ0FBQztJQUN2QyxNQUFNLFFBQVEsR0FBaUIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsdURBQU8sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDbEYsTUFBTSxPQUFPLEdBQWlCLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7SUFFMUQsSUFBRyxRQUFRLEVBQUU7UUFDVCxzRUFBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNuQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9hc3NldHMvdHMvZmllbGQvdXBsb2FkLnRzP2ZkOWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtfVVBMT0FEfSBmcm9tIFwiLi4vb3B0aW9ucy92YXJpYWJsZXNcIjtcbmltcG9ydCB7aGFuZGxlck9wZW5Nb2RhbFVwbG9hZH0gZnJvbSBcIi4uL21vZHVsZS91cGxvYWRcIjtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgRWxlbWVudDtcbiAgICBjb25zdCBlbFVwbG9hZCA9IDxIVE1MRWxlbWVudD4gdGFyZ2V0LmNsb3Nlc3QoJy4nICsgX1VQTE9BRC5hY3Rpb25zLm1vZGFsX3VwbG9hZCk7XG4gICAgY29uc3QgZWxGaWVsZCA9IDxIVE1MRWxlbWVudD4gdGFyZ2V0LmNsb3Nlc3QoJy5sbS1maWVsZCcpO1xuXG4gICAgaWYoZWxVcGxvYWQpIHtcbiAgICAgICAgaGFuZGxlck9wZW5Nb2RhbFVwbG9hZChlbEZpZWxkKTtcbiAgICB9XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/ts/field/upload.ts\n");

/***/ }),

/***/ "./assets/ts/handler/api/list.ts":
/*!***************************************!*\
  !*** ./assets/ts/handler/api/list.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handlerList: () => (/* binding */ handlerList)\n/* harmony export */ });\n/* harmony import */ var _options_variables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../options/variables */ \"./assets/ts/options/variables.ts\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst handlerList = (limit = 10, page = 1, ids = []) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const response = yield axios__WEBPACK_IMPORTED_MODULE_1___default().get(_options_variables__WEBPACK_IMPORTED_MODULE_0__._API.list, {\n            params: {\n                limit: limit,\n                page: page,\n                ids: ids\n            }\n        });\n        return response.data;\n    }\n    catch (error) {\n        return error;\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvaGFuZGxlci9hcGkvbGlzdC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTZDO0FBQ25CO0FBRW5CLE1BQU0sV0FBVyxHQUFHLENBQU8sS0FBSyxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsQ0FBQyxFQUFFLE1BQWdCLEVBQUUsRUFBRSxFQUFFO0lBQzFFLElBQUk7UUFDQSxNQUFNLFFBQVEsR0FBRyxNQUFNLGdEQUFTLENBQUMsb0RBQUksQ0FBQyxJQUFJLEVBQUU7WUFDeEMsTUFBTSxFQUFFO2dCQUNKLEtBQUssRUFBRSxLQUFLO2dCQUNaLElBQUksRUFBRSxJQUFJO2dCQUNWLEdBQUcsRUFBRSxHQUFHO2FBQ1g7U0FDSixDQUFDLENBQUM7UUFFSCxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUM7S0FDeEI7SUFBQyxPQUFPLEtBQUssRUFBRTtRQUNaLE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0FBQ0wsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9hc3NldHMvdHMvaGFuZGxlci9hcGkvbGlzdC50cz81Zjg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7X0FQSX0gZnJvbSBcIi4uLy4uL29wdGlvbnMvdmFyaWFibGVzXCI7XG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVyTGlzdCA9IGFzeW5jIChsaW1pdCA9IDEwLCBwYWdlID0gMSwgaWRzOiBudW1iZXJbXSA9IFtdKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoX0FQSS5saXN0LCB7XG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgICAgICAgICAgcGFnZTogcGFnZSxcbiAgICAgICAgICAgICAgICBpZHM6IGlkc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/ts/handler/api/list.ts\n");

/***/ }),

/***/ "./assets/ts/handler/api/remove.ts":
/*!*****************************************!*\
  !*** ./assets/ts/handler/api/remove.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handlerRemove: () => (/* binding */ handlerRemove)\n/* harmony export */ });\n/* harmony import */ var _options_variables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../options/variables */ \"./assets/ts/options/variables.ts\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst handlerRemove = (id) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const response = yield axios__WEBPACK_IMPORTED_MODULE_1___default().get(_options_variables__WEBPACK_IMPORTED_MODULE_0__._API.remove, {\n            params: {\n                id: id\n            }\n        });\n        return response.data;\n    }\n    catch (error) {\n        return error;\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvaGFuZGxlci9hcGkvcmVtb3ZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFDbkI7QUFFbkIsTUFBTSxhQUFhLEdBQUcsQ0FBTyxFQUFFLEVBQUUsRUFBRTtJQUN0QyxJQUFJO1FBQ0EsTUFBTSxRQUFRLEdBQUcsTUFBTSxnREFBUyxDQUFDLG9EQUFJLENBQUMsTUFBTSxFQUFFO1lBQzFDLE1BQU0sRUFBRTtnQkFDSixFQUFFLEVBQUUsRUFBRTthQUNUO1NBQ0osQ0FBQyxDQUFDO1FBRUgsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDO0tBQ3hCO0lBQUMsT0FBTyxLQUFLLEVBQUU7UUFDWixPQUFPLEtBQUssQ0FBQztLQUNoQjtBQUNMLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vYXNzZXRzL3RzL2hhbmRsZXIvYXBpL3JlbW92ZS50cz9jNDQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7X0FQSX0gZnJvbSBcIi4uLy4uL29wdGlvbnMvdmFyaWFibGVzXCI7XG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVyUmVtb3ZlID0gYXN5bmMgKGlkKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoX0FQSS5yZW1vdmUsIHtcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/ts/handler/api/remove.ts\n");

/***/ }),

/***/ "./assets/ts/media-bundle.ts":
/*!***********************************!*\
  !*** ./assets/ts/media-bundle.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '../css/manager.css'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _field_gallery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./field/gallery */ \"./assets/ts/field/gallery.ts\");\n/* harmony import */ var _field_media__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./field/media */ \"./assets/ts/field/media.ts\");\n/* harmony import */ var _field_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./field/library */ \"./assets/ts/field/library.ts\");\n/* harmony import */ var _field_upload__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./field/upload */ \"./assets/ts/field/upload.ts\");\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvbWVkaWEtYnVuZGxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QjtBQUVIO0FBQ0Y7QUFDRTtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9hc3NldHMvdHMvbWVkaWEtYnVuZGxlLnRzP2JlMTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuLi9jc3MvbWFuYWdlci5jc3MnO1xuXG5pbXBvcnQgJy4vZmllbGQvZ2FsbGVyeSc7XG5pbXBvcnQgJy4vZmllbGQvbWVkaWEnO1xuaW1wb3J0ICcuL2ZpZWxkL2xpYnJhcnknO1xuaW1wb3J0ICcuL2ZpZWxkL3VwbG9hZCc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/ts/media-bundle.ts\n");

/***/ }),

/***/ "./assets/ts/module/delete.ts":
/*!************************************!*\
  !*** ./assets/ts/module/delete.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handlerOpenModalDelete: () => (/* binding */ handlerOpenModalDelete)\n/* harmony export */ });\n/* harmony import */ var basiclightbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! basiclightbox */ \"./node_modules/basiclightbox/dist/basicLightbox.min.js\");\n/* harmony import */ var basiclightbox__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(basiclightbox__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _template_modal_delete__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../template/modal-delete */ \"./assets/ts/template/modal-delete.ts\");\n/* harmony import */ var _options_variables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options/variables */ \"./assets/ts/options/variables.ts\");\n/* harmony import */ var _handler_api_remove__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../handler/api/remove */ \"./assets/ts/handler/api/remove.ts\");\n\n\n\n\nlet modal;\nlet field;\n/**\n * Open modal delete\n */\nfunction handlerOpenModalDelete(fieldHandler) {\n    field = fieldHandler;\n    modal = basiclightbox__WEBPACK_IMPORTED_MODULE_0__.create((0,_template_modal_delete__WEBPACK_IMPORTED_MODULE_1__.modalDelete)(), {\n        onShow: (instance) => { },\n        onClose: (instance) => { }\n    });\n    modal.show();\n}\ndocument.addEventListener('click', (event) => {\n    const target = event.target;\n    const btnCancel = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_2__._MODAL_DELETE.actions.cancel);\n    const btnDelete = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_2__._MODAL_DELETE.actions.delete);\n    /**\n     * Close modal without delete\n     */\n    if (btnCancel) {\n        modal.close();\n    }\n    /**\n     * Delete media from library\n     */\n    if (btnDelete) {\n        const input = field.querySelector('.' + _options_variables__WEBPACK_IMPORTED_MODULE_2__._CARD.checkbox);\n        if (!input) {\n            return;\n        }\n        (0,_handler_api_remove__WEBPACK_IMPORTED_MODULE_3__.handlerRemove)(input.value).then(r => {\n            field.remove();\n            modal.close();\n        });\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvbW9kdWxlL2RlbGV0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0M7QUFDTTtBQUNLO0FBQ047QUFFcEQsSUFBSSxLQUFtQyxDQUFDO0FBQ3hDLElBQUksS0FBa0IsQ0FBQztBQUV2Qjs7R0FFRztBQUNJLFNBQVMsc0JBQXNCLENBQUMsWUFBeUI7SUFDNUQsS0FBSyxHQUFHLFlBQVksQ0FBQztJQUVyQixLQUFLLEdBQUcsaURBQW9CLENBQUMsbUVBQVcsRUFBRSxFQUFFO1FBQ3hDLE1BQU0sRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFFLEdBQUcsQ0FBQztRQUN6QixPQUFPLEVBQUUsQ0FBQyxRQUFRLEVBQUUsRUFBRSxHQUFHLENBQUM7S0FDN0IsQ0FBQyxDQUFDO0lBRUgsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ2pCLENBQUM7QUFFRCxRQUFRLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7SUFDekMsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQWlCLENBQUM7SUFFdkMsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsNkRBQWEsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDckUsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsNkRBQWEsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7SUFFckU7O09BRUc7SUFDSCxJQUFHLFNBQVMsRUFBRTtRQUNWLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztLQUNqQjtJQUVEOztPQUVHO0lBQ0gsSUFBRyxTQUFTLEVBQUU7UUFDVixNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLEdBQUcsR0FBRyxxREFBSyxDQUFDLFFBQVEsQ0FBcUIsQ0FBQztRQUU1RSxJQUFHLENBQUMsS0FBSyxFQUFFO1lBQ1AsT0FBTztTQUNWO1FBRUQsa0VBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ2hDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNmLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNsQixDQUFDLENBQUMsQ0FBQztLQUNOO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL2Fzc2V0cy90cy9tb2R1bGUvZGVsZXRlLnRzP2JhNGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYmFzaWNMaWdodGJveCBmcm9tICdiYXNpY2xpZ2h0Ym94JztcbmltcG9ydCB7bW9kYWxEZWxldGV9IGZyb20gJy4uL3RlbXBsYXRlL21vZGFsLWRlbGV0ZSc7XG5pbXBvcnQge19DQVJELCBfTU9EQUxfREVMRVRFfSBmcm9tIFwiLi4vb3B0aW9ucy92YXJpYWJsZXNcIjtcbmltcG9ydCB7aGFuZGxlclJlbW92ZX0gZnJvbSAnLi4vaGFuZGxlci9hcGkvcmVtb3ZlJztcblxubGV0IG1vZGFsIDogYmFzaWNMaWdodGJveC5CYXNpY0xpZ2h0Ym94O1xubGV0IGZpZWxkOiBIVE1MRWxlbWVudDtcblxuLyoqXG4gKiBPcGVuIG1vZGFsIGRlbGV0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlck9wZW5Nb2RhbERlbGV0ZShmaWVsZEhhbmRsZXI6IEhUTUxFbGVtZW50KSA6IGJhc2ljTGlnaHRib3guQmFzaWNMaWdodGJveCB7XG4gICAgZmllbGQgPSBmaWVsZEhhbmRsZXI7XG5cbiAgICBtb2RhbCA9IGJhc2ljTGlnaHRib3guY3JlYXRlKG1vZGFsRGVsZXRlKCksIHtcbiAgICAgICAgb25TaG93OiAoaW5zdGFuY2UpID0+IHsgfSxcbiAgICAgICAgb25DbG9zZTogKGluc3RhbmNlKSA9PiB7IH1cbiAgICB9KTtcblxuICAgIG1vZGFsLnNob3coKTtcbn1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgRWxlbWVudDtcblxuICAgIGNvbnN0IGJ0bkNhbmNlbCA9IHRhcmdldC5jbG9zZXN0KCcuJyArIF9NT0RBTF9ERUxFVEUuYWN0aW9ucy5jYW5jZWwpO1xuICAgIGNvbnN0IGJ0bkRlbGV0ZSA9IHRhcmdldC5jbG9zZXN0KCcuJyArIF9NT0RBTF9ERUxFVEUuYWN0aW9ucy5kZWxldGUpO1xuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgbW9kYWwgd2l0aG91dCBkZWxldGVcbiAgICAgKi9cbiAgICBpZihidG5DYW5jZWwpIHtcbiAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgbWVkaWEgZnJvbSBsaWJyYXJ5XG4gICAgICovXG4gICAgaWYoYnRuRGVsZXRlKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZmllbGQucXVlcnlTZWxlY3RvcignLicgKyBfQ0FSRC5jaGVja2JveCkgYXMgSFRNTElucHV0RWxlbWVudDtcblxuICAgICAgICBpZighaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZXJSZW1vdmUoaW5wdXQudmFsdWUpLnRoZW4ociA9PiB7XG4gICAgICAgICAgICBmaWVsZC5yZW1vdmUoKTtcbiAgICAgICAgICAgIG1vZGFsLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/ts/module/delete.ts\n");

/***/ }),

/***/ "./assets/ts/module/modal.ts":
/*!***********************************!*\
  !*** ./assets/ts/module/modal.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handlerOpenModalLibrary: () => (/* binding */ handlerOpenModalLibrary)\n/* harmony export */ });\n/* harmony import */ var basiclightbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! basiclightbox */ \"./node_modules/basiclightbox/dist/basicLightbox.min.js\");\n/* harmony import */ var basiclightbox__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(basiclightbox__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _template_modal_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../template/modal-library */ \"./assets/ts/template/modal-library.ts\");\n/* harmony import */ var _template_card__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../template/card */ \"./assets/ts/template/card.ts\");\n/* harmony import */ var _handler_api_list__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../handler/api/list */ \"./assets/ts/handler/api/list.ts\");\n/* harmony import */ var _options_variables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../options/variables */ \"./assets/ts/options/variables.ts\");\n\n\n\n\n\nlet excludeIds = [];\nlet field;\nlet modal;\nlet library;\nfunction handlerOpenModalLibrary(fieldHandler, ids = []) {\n    const bodyEl = document.querySelector('body');\n    excludeIds = ids;\n    field = fieldHandler;\n    const modalHandler = basiclightbox__WEBPACK_IMPORTED_MODULE_0__.create((0,_template_modal_library__WEBPACK_IMPORTED_MODULE_1__.modalLibrary)(), {\n        onShow: (instance) => {\n            bodyEl.classList.add('is-scroll');\n            const element = instance.element();\n            const elModal = element.querySelector('.lm-modal');\n            const itemsEl = element.querySelector('.lm-gallery__items');\n            const elList = element.querySelector('.lm-gallery');\n            const page = Number(elList.getAttribute('data-page'));\n            const limit = Number(elList.getAttribute('data-limit'));\n            library = elList;\n            (0,_handler_api_list__WEBPACK_IMPORTED_MODULE_3__.handlerList)(limit, page, ids).then((response) => {\n                itemsEl.innerHTML = response.data.map((item) => {\n                    return (0,_template_card__WEBPACK_IMPORTED_MODULE_2__.card)(item);\n                }).join('');\n                elList.setAttribute('data-page', (page + 1).toString());\n                elModal.classList.remove('is-loading');\n            }).catch((error) => { });\n        },\n        onClose: (instance) => {\n            bodyEl.classList.remove('is-scroll');\n        }\n    });\n    modal = modalHandler;\n    modalHandler.show();\n    return modalHandler;\n}\ndocument.addEventListener('click', (event) => {\n    const target = event.target;\n    const elList = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._MODAL_LIBRARY.list);\n    const btnSelect = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._MODAL_LIBRARY.actions.select);\n    const btnLoadMore = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._MODAL_LIBRARY.actions.load_more);\n    const elCard = target.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._CARD.card);\n    if (!elList) {\n        return;\n    }\n    if (btnSelect || btnLoadMore) {\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    /**\n     * Choice card from library\n     */\n    if (elCard) {\n        if (!elCard.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._GALLERY.list + '[data-type=\"library\"]')) {\n            return;\n        }\n        const multiple = field.getAttribute('data-multiple');\n        const checkbox = elCard.querySelector('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._CARD.checkbox);\n        if (checkbox) {\n            if (multiple && multiple == \"true\") {\n                checkbox.checked = !checkbox.checked;\n                handleMultipleSelect(elList);\n            }\n            else {\n                handleSingleSelect(elList);\n                checkbox.checked = !checkbox.checked;\n            }\n        }\n    }\n    /**\n     * Select media from library\n     */\n    if (btnSelect) {\n        const fieldItems = field.querySelector('.lm-gallery__items');\n        const nameField = field.getAttribute('data-name-field');\n        if (fieldItems && nameField) {\n            getSelectedCards().forEach((item) => {\n                const checkbox = item.querySelector('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._CARD.checkbox);\n                checkbox.checked = true;\n                checkbox.setAttribute('name', nameField);\n                fieldItems.insertAdjacentElement('afterbegin', item);\n            });\n        }\n        else {\n            const preview = field.querySelector('.lm-media__preview');\n            const fieldInput = field.querySelector('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._MEDIA.value);\n            if (preview) {\n                preview.innerHTML = getSelectedCards().map((item) => {\n                    const img = item.querySelector('img');\n                    if (!img || !img.getAttribute('src'))\n                        return;\n                    return '<img src=\"' + img.getAttribute('src') + '\" class=\"lm-media__image\">';\n                }).join('');\n                field.classList.add('is-active');\n            }\n            if (fieldInput) {\n                fieldInput.value = getSelectedCards().map((item) => {\n                    const input = item.querySelector('input');\n                    if (!input || !input.value)\n                        return;\n                    return input.value;\n                }).join('');\n                handlerUpdateCard(fieldInput);\n            }\n        }\n        modal.close();\n    }\n    /**\n     * Load more media from library\n     */\n    if (btnLoadMore) {\n        const page = Number(elList.getAttribute('data-page'));\n        const limit = Number(elList.getAttribute('data-limit'));\n        const itemsEl = elList.querySelector('.lm-gallery__items');\n        btnLoadMore.classList.add('is-loading');\n        (0,_handler_api_list__WEBPACK_IMPORTED_MODULE_3__.handlerList)(limit, page, excludeIds).then((response) => {\n            itemsEl.insertAdjacentHTML('beforeend', response.data.map((item) => {\n                return (0,_template_card__WEBPACK_IMPORTED_MODULE_2__.card)(item);\n            }).join(''));\n            if (response.data.length < limit) {\n                btnLoadMore.style.display = 'none';\n            }\n            elList.setAttribute('data-page', (page + 1).toString());\n            btnLoadMore.classList.remove('is-loading');\n        }).catch((error) => { });\n    }\n});\nfunction getSelectedCards() {\n    let selected = [];\n    const checkboxes = library.querySelectorAll('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._CARD.checkbox + ':checked');\n    checkboxes.forEach((checkbox) => {\n        const card = checkbox.closest('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._CARD.card);\n        selected.push(card);\n    });\n    return selected;\n}\nfunction checkingSelectedCard(wrapper) {\n    let selected = false;\n    const checkboxes = wrapper.querySelectorAll('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._CARD.checkbox);\n    checkboxes.forEach((checkbox) => {\n        if (checkbox.checked) {\n            selected = true;\n        }\n    });\n    return selected;\n}\nfunction handleMultipleSelect(wrapper) {\n    if (checkingSelectedCard(wrapper)) {\n        wrapper.classList.add('is-multiple_select');\n    }\n    else {\n        wrapper.classList.remove('is-multiple_select');\n    }\n}\nfunction handleSingleSelect(wrapper) {\n    const list = wrapper.querySelectorAll('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._CARD.card);\n    list.forEach((card) => {\n        const checkbox = card.querySelector('.' + _options_variables__WEBPACK_IMPORTED_MODULE_4__._CARD.checkbox);\n        checkbox.checked = false;\n    });\n    wrapper.classList.add('is-multiple_select');\n}\nfunction handlerUpdateCard(input) {\n    setTimeout(() => {\n        const card = input.closest('.card');\n        if (!card) {\n            return;\n        }\n        const divForm = card.parentElement;\n        const divDivForm = divForm.parentElement;\n        if (divDivForm) {\n            divDivForm.dispatchEvent(new Event('change'));\n        }\n    }, 300);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VUFBVSxHQUFpQixPQUFPLENBQUMsYUFBYSxDQUFDO1FBRXZELElBQUcsVUFBVSxFQUFFO1lBQ1gsVUFBVSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1NBQ2pEO0lBQ0wsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ1osQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vYXNzZXRzL3RzL21vZHVsZS9tb2RhbC50cz8yYTk0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGJhc2ljTGlnaHRib3ggZnJvbSAnYmFzaWNsaWdodGJveCc7XG5pbXBvcnQge21vZGFsTGlicmFyeX0gZnJvbSAnLi4vdGVtcGxhdGUvbW9kYWwtbGlicmFyeSc7XG5pbXBvcnQge2NhcmR9IGZyb20gXCIuLi90ZW1wbGF0ZS9jYXJkXCI7XG5pbXBvcnQge2hhbmRsZXJMaXN0fSBmcm9tIFwiLi4vaGFuZGxlci9hcGkvbGlzdFwiO1xuaW1wb3J0IHtfQ0FSRCwgX0dBTExFUlksIF9NT0RBTF9MSUJSQVJZLCBfTUVESUF9IGZyb20gXCIuLi9vcHRpb25zL3ZhcmlhYmxlc1wiO1xuXG5sZXQgZXhjbHVkZUlkcyA6IG51bWJlcltdID0gW107XG5sZXQgZmllbGQ6IEhUTUxFbGVtZW50O1xubGV0IG1vZGFsIDogYmFzaWNMaWdodGJveC5CYXNpY0xpZ2h0Ym94O1xubGV0IGxpYnJhcnkgOiBIVE1MRWxlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZXJPcGVuTW9kYWxMaWJyYXJ5KGZpZWxkSGFuZGxlcjogSFRNTEVsZW1lbnQsIGlkcyA6IG51bWJlcltdID0gW10pIDogYmFzaWNMaWdodGJveC5CYXNpY0xpZ2h0Ym94IHtcbiAgICBjb25zdCBib2R5RWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykgYXMgSFRNTEJvZHlFbGVtZW50O1xuICAgIGV4Y2x1ZGVJZHMgPSBpZHM7XG4gICAgZmllbGQgPSBmaWVsZEhhbmRsZXI7XG5cbiAgICBjb25zdCBtb2RhbEhhbmRsZXIgPSBiYXNpY0xpZ2h0Ym94LmNyZWF0ZShtb2RhbExpYnJhcnkoKSwge1xuICAgICAgICBvblNob3c6IChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgYm9keUVsLmNsYXNzTGlzdC5hZGQoJ2lzLXNjcm9sbCcpO1xuXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gaW5zdGFuY2UuZWxlbWVudCgpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgZWxNb2RhbCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignLmxtLW1vZGFsJykgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBpdGVtc0VsID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubG0tZ2FsbGVyeV9faXRlbXMnKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGVsTGlzdCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignLmxtLWdhbGxlcnknKSBhcyBIVE1MRWxlbWVudDtcblxuICAgICAgICAgICAgY29uc3QgcGFnZSA9ICBOdW1iZXIoZWxMaXN0LmdldEF0dHJpYnV0ZSgnZGF0YS1wYWdlJykpO1xuICAgICAgICAgICAgY29uc3QgbGltaXQgPSBOdW1iZXIoZWxMaXN0LmdldEF0dHJpYnV0ZSgnZGF0YS1saW1pdCcpKTtcblxuICAgICAgICAgICAgbGlicmFyeSA9IGVsTGlzdDtcblxuICAgICAgICAgICAgaGFuZGxlckxpc3QobGltaXQsIHBhZ2UsIGlkcykudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtc0VsLmlubmVySFRNTCA9IHJlc3BvbnNlLmRhdGEubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXJkKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuXG4gICAgICAgICAgICAgICAgZWxMaXN0LnNldEF0dHJpYnV0ZSgnZGF0YS1wYWdlJywgKHBhZ2UgKyAxKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBlbE1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWxvYWRpbmcnKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge30pO1xuICAgICAgICB9LFxuICAgICAgICBvbkNsb3NlOiAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgIGJvZHlFbC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1zY3JvbGwnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kYWwgPSBtb2RhbEhhbmRsZXI7XG5cbiAgICBtb2RhbEhhbmRsZXIuc2hvdygpO1xuXG4gICAgcmV0dXJuIG1vZGFsSGFuZGxlcjtcbn1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgRWxlbWVudDtcblxuICAgIGNvbnN0IGVsTGlzdCA9IDxIVE1MRWxlbWVudD4gdGFyZ2V0LmNsb3Nlc3QoJy4nICsgX01PREFMX0xJQlJBUlkubGlzdCk7XG4gICAgY29uc3QgYnRuU2VsZWN0ID0gdGFyZ2V0LmNsb3Nlc3QoJy4nICsgX01PREFMX0xJQlJBUlkuYWN0aW9ucy5zZWxlY3QpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICAgIGNvbnN0IGJ0bkxvYWRNb3JlID0gdGFyZ2V0LmNsb3Nlc3QoJy4nICsgX01PREFMX0xJQlJBUlkuYWN0aW9ucy5sb2FkX21vcmUpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICAgIGNvbnN0IGVsQ2FyZCA9IHRhcmdldC5jbG9zZXN0KCcuJyArIF9DQVJELmNhcmQpO1xuXG4gICAgaWYoIWVsTGlzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoYnRuU2VsZWN0IHx8IGJ0bkxvYWRNb3JlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENob2ljZSBjYXJkIGZyb20gbGlicmFyeVxuICAgICAqL1xuICAgIGlmKGVsQ2FyZCkge1xuICAgICAgICBpZighZWxDYXJkLmNsb3Nlc3QoJy4nICsgX0dBTExFUlkubGlzdCArICdbZGF0YS10eXBlPVwibGlicmFyeVwiXScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtdWx0aXBsZSA9IGZpZWxkLmdldEF0dHJpYnV0ZSgnZGF0YS1tdWx0aXBsZScpO1xuXG4gICAgICAgIGNvbnN0IGNoZWNrYm94ID0gZWxDYXJkLnF1ZXJ5U2VsZWN0b3IoJy4nICsgX0NBUkQuY2hlY2tib3gpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICAgICAgaWYoY2hlY2tib3gpIHtcbiAgICAgICAgICAgIGlmKG11bHRpcGxlICYmIG11bHRpcGxlID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9ICFjaGVja2JveC5jaGVja2VkO1xuICAgICAgICAgICAgICAgIGhhbmRsZU11bHRpcGxlU2VsZWN0KGVsTGlzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZVNpbmdsZVNlbGVjdChlbExpc3QpO1xuICAgICAgICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSAhY2hlY2tib3guY2hlY2tlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBtZWRpYSBmcm9tIGxpYnJhcnlcbiAgICAgKi9cbiAgICBpZihidG5TZWxlY3QpIHtcbiAgICAgICAgY29uc3QgZmllbGRJdGVtcyA9IGZpZWxkLnF1ZXJ5U2VsZWN0b3IoJy5sbS1nYWxsZXJ5X19pdGVtcycpO1xuICAgICAgICBjb25zdCBuYW1lRmllbGQgPSBmaWVsZC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmFtZS1maWVsZCcpO1xuXG4gICAgICAgIGlmKGZpZWxkSXRlbXMgJiYgbmFtZUZpZWxkKSB7XG4gICAgICAgICAgICBnZXRTZWxlY3RlZENhcmRzKCkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrYm94ID0gaXRlbS5xdWVyeVNlbGVjdG9yKCcuJyArIF9DQVJELmNoZWNrYm94KSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoZWNrYm94LnNldEF0dHJpYnV0ZSgnbmFtZScsIG5hbWVGaWVsZCk7XG5cbiAgICAgICAgICAgICAgICBmaWVsZEl0ZW1zLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJiZWdpbicsIGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aWV3ID0gZmllbGQucXVlcnlTZWxlY3RvcignLmxtLW1lZGlhX19wcmV2aWV3JykgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBmaWVsZElucHV0ID0gZmllbGQucXVlcnlTZWxlY3RvcignLicgKyBfTUVESUEudmFsdWUpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmKHByZXZpZXcpIHtcbiAgICAgICAgICAgICAgICBwcmV2aWV3LmlubmVySFRNTCA9IGdldFNlbGVjdGVkQ2FyZHMoKS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nID0gaXRlbS5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoIWltZyB8fCAhaW1nLmdldEF0dHJpYnV0ZSgnc3JjJykpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8aW1nIHNyYz1cIicgKyBpbWcuZ2V0QXR0cmlidXRlKCdzcmMnKSArICdcIiBjbGFzcz1cImxtLW1lZGlhX19pbWFnZVwiPic7XG4gICAgICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgZmllbGQuY2xhc3NMaXN0LmFkZCgnaXMtYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGZpZWxkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBmaWVsZElucHV0LnZhbHVlID0gZ2V0U2VsZWN0ZWRDYXJkcygpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGl0ZW0ucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoIWlucHV0IHx8ICFpbnB1dC52YWx1ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgaGFuZGxlclVwZGF0ZUNhcmQoZmllbGRJbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgbW9yZSBtZWRpYSBmcm9tIGxpYnJhcnlcbiAgICAgKi9cbiAgICBpZihidG5Mb2FkTW9yZSkge1xuICAgICAgICBjb25zdCBwYWdlID0gIE51bWJlcihlbExpc3QuZ2V0QXR0cmlidXRlKCdkYXRhLXBhZ2UnKSk7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gTnVtYmVyKGVsTGlzdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGltaXQnKSk7XG4gICAgICAgIGNvbnN0IGl0ZW1zRWwgPSBlbExpc3QucXVlcnlTZWxlY3RvcignLmxtLWdhbGxlcnlfX2l0ZW1zJykgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIGJ0bkxvYWRNb3JlLmNsYXNzTGlzdC5hZGQoJ2lzLWxvYWRpbmcnKTtcblxuICAgICAgICBoYW5kbGVyTGlzdChsaW1pdCwgcGFnZSwgZXhjbHVkZUlkcykudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGl0ZW1zRWwuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXJkKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpKTtcblxuICAgICAgICAgICAgaWYocmVzcG9uc2UuZGF0YS5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGJ0bkxvYWRNb3JlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsTGlzdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFnZScsIChwYWdlICsgMSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBidG5Mb2FkTW9yZS5jbGFzc0xpc3QucmVtb3ZlKCdpcy1sb2FkaW5nJyk7XG4gICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge30pO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRTZWxlY3RlZENhcmRzKCkgOiBIVE1MRWxlbWVudFtdIHtcbiAgICBsZXQgc2VsZWN0ZWQ6IEhUTUxFbGVtZW50W10gPSBbXTtcbiAgICBjb25zdCBjaGVja2JveGVzID0gbGlicmFyeS5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIF9DQVJELmNoZWNrYm94ICsgJzpjaGVja2VkJykgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcblxuICAgIGNoZWNrYm94ZXMuZm9yRWFjaCgoY2hlY2tib3gpID0+IHtcbiAgICAgICAgY29uc3QgY2FyZCA9IGNoZWNrYm94LmNsb3Nlc3QoJy4nICsgX0NBUkQuY2FyZCkgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIHNlbGVjdGVkLnB1c2goY2FyZCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2VsZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNraW5nU2VsZWN0ZWRDYXJkKHdyYXBwZXI6IEhUTUxFbGVtZW50KSA6IGJvb2xlYW4ge1xuICAgIGxldCBzZWxlY3RlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgX0NBUkQuY2hlY2tib3gpIGFzIE5vZGVMaXN0T2Y8SFRNTElucHV0RWxlbWVudD47XG5cbiAgICBjaGVja2JveGVzLmZvckVhY2goKGNoZWNrYm94KSA9PiB7XG4gICAgICAgIGlmKGNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlbGVjdGVkO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNdWx0aXBsZVNlbGVjdCh3cmFwcGVyOiBIVE1MRWxlbWVudCkgOiB2b2lkIHtcbiAgICBpZihjaGVja2luZ1NlbGVjdGVkQ2FyZCh3cmFwcGVyKSkge1xuICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2lzLW11bHRpcGxlX3NlbGVjdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnaXMtbXVsdGlwbGVfc2VsZWN0Jyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGVTZWxlY3Qod3JhcHBlcjogSFRNTEVsZW1lbnQpIDogdm9pZCB7XG4gICAgY29uc3QgbGlzdCA9IHdyYXBwZXIucXVlcnlTZWxlY3RvckFsbCgnLicgKyBfQ0FSRC5jYXJkKTtcblxuICAgIGxpc3QuZm9yRWFjaCgoY2FyZCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja2JveCA9IGNhcmQucXVlcnlTZWxlY3RvcignLicgKyBfQ0FSRC5jaGVja2JveCkgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdpcy1tdWx0aXBsZV9zZWxlY3QnKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlclVwZGF0ZUNhcmQoaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpOiB2b2lkIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgY2FyZCA9IDxIVE1MRWxlbWVudD4gaW5wdXQuY2xvc2VzdCgnLmNhcmQnKTtcblxuICAgICAgICBpZighY2FyZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGl2Rm9ybSA9IDxIVE1MRWxlbWVudD4gY2FyZC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBjb25zdCBkaXZEaXZGb3JtID0gPEhUTUxFbGVtZW50PiBkaXZGb3JtLnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgICAgaWYoZGl2RGl2Rm9ybSkge1xuICAgICAgICAgICAgZGl2RGl2Rm9ybS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuICAgICAgICB9XG4gICAgfSwgMzAwKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/ts/module/modal.ts\n");

/***/ }),

/***/ "./assets/ts/module/upload.ts":
/*!************************************!*\
  !*** ./assets/ts/module/upload.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handlerOpenModalUpload: () => (/* binding */ handlerOpenModalUpload)\n/* harmony export */ });\n/* harmony import */ var basiclightbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! basiclightbox */ \"./node_modules/basiclightbox/dist/basicLightbox.min.js\");\n/* harmony import */ var basiclightbox__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(basiclightbox__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _template_modal_upload__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../template/modal-upload */ \"./assets/ts/template/modal-upload.ts\");\n/* harmony import */ var _options_variables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options/variables */ \"./assets/ts/options/variables.ts\");\n/* harmony import */ var _template_card__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../template/card */ \"./assets/ts/template/card.ts\");\n/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! filepond */ \"./node_modules/filepond/dist/filepond.js\");\n/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(filepond__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var filepond_plugin_file_metadata__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! filepond-plugin-file-metadata */ \"./node_modules/filepond-plugin-file-metadata/dist/filepond-plugin-file-metadata.js\");\n/* harmony import */ var filepond_plugin_file_metadata__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_file_metadata__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var filepond_dist_filepond_min_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! filepond/dist/filepond.min.css */ \"./node_modules/filepond/dist/filepond.min.css\");\n\n\n\n\n\n\n\nfilepond__WEBPACK_IMPORTED_MODULE_4__.registerPlugin((filepond_plugin_file_metadata__WEBPACK_IMPORTED_MODULE_5___default()));\nlet modal;\nlet field;\n/**\n * Open modal delete\n */\nfunction handlerOpenModalUpload(fieldHandler) {\n    field = fieldHandler;\n    modal = basiclightbox__WEBPACK_IMPORTED_MODULE_0__.create((0,_template_modal_upload__WEBPACK_IMPORTED_MODULE_1__.modalUpload)(), {\n        onShow: (instance) => {\n            const element = instance.element();\n            const elFile = element.querySelector('.' + _options_variables__WEBPACK_IMPORTED_MODULE_2__._UPLOAD.file);\n            handlerInitFilePond(elFile);\n        },\n        onClose: (instance) => { }\n    });\n    modal.show();\n}\nfunction handlerInitFilePond(input) {\n    return filepond__WEBPACK_IMPORTED_MODULE_4__.create(input, {\n        allowRevert: false,\n        server: {\n            process: {\n                url: _options_variables__WEBPACK_IMPORTED_MODULE_2__._API.add,\n                method: 'POST',\n                withCredentials: false,\n                onload: (response) => {\n                    response = JSON.parse(response);\n                    const elItems = field.querySelector('.lm-field__items');\n                    elItems.insertAdjacentHTML('afterbegin', response.data.map((item) => {\n                        return (0,_template_card__WEBPACK_IMPORTED_MODULE_3__.card)(item);\n                    }).join(''));\n                    return 126;\n                }\n            }\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvbW9kdWxlL3VwbG9hZC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUErQztBQUNNO0FBQ0Y7QUFDYjtBQUNEO0FBQ2tDO0FBQy9CO0FBRXhDLG9EQUF1QixDQUNuQixzRUFBMEIsQ0FDN0IsQ0FBQztBQUVGLElBQUksS0FBbUMsQ0FBQztBQUN4QyxJQUFJLEtBQWtCLENBQUM7QUFFdkI7O0dBRUc7QUFDSSxTQUFTLHNCQUFzQixDQUFDLFlBQXlCO0lBQzVELEtBQUssR0FBRyxZQUFZLENBQUM7SUFFckIsS0FBSyxHQUFHLGlEQUFvQixDQUFDLG1FQUFXLEVBQUUsRUFBRTtRQUN4QyxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUUsRUFBRTtZQUNqQixNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxFQUFpQixDQUFDO1lBQ2xELE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsR0FBRyxHQUFHLHVEQUFPLENBQUMsSUFBSSxDQUFxQixDQUFDO1lBRTdFLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRWhDLENBQUM7UUFDRCxPQUFPLEVBQUUsQ0FBQyxRQUFRLEVBQUUsRUFBRSxHQUFHLENBQUM7S0FDN0IsQ0FBQyxDQUFDO0lBRUgsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ2pCLENBQUM7QUFFRCxTQUFTLG1CQUFtQixDQUFDLEtBQXVCO0lBQ2hELE9BQU8sNENBQWUsQ0FBQyxLQUFLLEVBQUU7UUFDMUIsV0FBVyxFQUFFLEtBQUs7UUFDbEIsTUFBTSxFQUFFO1lBQ0osT0FBTyxFQUFFO2dCQUNMLEdBQUcsRUFBRSxvREFBSSxDQUFDLEdBQUc7Z0JBQ2IsTUFBTSxFQUFFLE1BQU07Z0JBQ2QsZUFBZSxFQUFFLEtBQUs7Z0JBQ3RCLE1BQU0sRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFFO29CQUNqQixRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDaEMsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxrQkFBa0IsQ0FBZ0IsQ0FBQztvQkFFdkUsT0FBTyxDQUFDLGtCQUFrQixDQUFDLFlBQVksRUFDbkMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTt3QkFDdkIsT0FBTyxvREFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUN0QixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFFakIsT0FBTyxHQUFHLENBQUM7Z0JBQ2YsQ0FBQzthQUNKO1NBQ0o7S0FDSixDQUFDLENBQUM7QUFDUCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9hc3NldHMvdHMvbW9kdWxlL3VwbG9hZC50cz9kZmUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGJhc2ljTGlnaHRib3ggZnJvbSAnYmFzaWNsaWdodGJveCc7XG5pbXBvcnQge21vZGFsVXBsb2FkfSBmcm9tICcuLi90ZW1wbGF0ZS9tb2RhbC11cGxvYWQnO1xuaW1wb3J0IHtfVVBMT0FELCBfQVBJfSBmcm9tIFwiLi4vb3B0aW9ucy92YXJpYWJsZXNcIjtcbmltcG9ydCB7Y2FyZH0gZnJvbSBcIi4uL3RlbXBsYXRlL2NhcmRcIjtcbmltcG9ydCAqIGFzIEZpbGVQb25kIGZyb20gJ2ZpbGVwb25kJztcbmltcG9ydCBGaWxlUG9uZFBsdWdpbkZpbGVNZXRhZGF0YSBmcm9tICdmaWxlcG9uZC1wbHVnaW4tZmlsZS1tZXRhZGF0YSc7XG5pbXBvcnQgJ2ZpbGVwb25kL2Rpc3QvZmlsZXBvbmQubWluLmNzcyc7XG5cbkZpbGVQb25kLnJlZ2lzdGVyUGx1Z2luKFxuICAgIEZpbGVQb25kUGx1Z2luRmlsZU1ldGFkYXRhXG4pO1xuXG5sZXQgbW9kYWwgOiBiYXNpY0xpZ2h0Ym94LkJhc2ljTGlnaHRib3g7XG5sZXQgZmllbGQ6IEhUTUxFbGVtZW50O1xuXG4vKipcbiAqIE9wZW4gbW9kYWwgZGVsZXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVyT3Blbk1vZGFsVXBsb2FkKGZpZWxkSGFuZGxlcjogSFRNTEVsZW1lbnQpIDogYmFzaWNMaWdodGJveC5CYXNpY0xpZ2h0Ym94IHtcbiAgICBmaWVsZCA9IGZpZWxkSGFuZGxlcjtcblxuICAgIG1vZGFsID0gYmFzaWNMaWdodGJveC5jcmVhdGUobW9kYWxVcGxvYWQoKSwge1xuICAgICAgICBvblNob3c6IChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLmVsZW1lbnQoKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGVsRmlsZSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignLicgKyBfVVBMT0FELmZpbGUpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIGhhbmRsZXJJbml0RmlsZVBvbmQoZWxGaWxlKTtcblxuICAgICAgICB9LFxuICAgICAgICBvbkNsb3NlOiAoaW5zdGFuY2UpID0+IHsgfVxuICAgIH0pO1xuXG4gICAgbW9kYWwuc2hvdygpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVySW5pdEZpbGVQb25kKGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA6IEZpbGVQb25kLkZpbGVQb25kIHtcbiAgICByZXR1cm4gRmlsZVBvbmQuY3JlYXRlKGlucHV0LCB7XG4gICAgICAgIGFsbG93UmV2ZXJ0OiBmYWxzZSxcbiAgICAgICAgc2VydmVyOiB7XG4gICAgICAgICAgICBwcm9jZXNzOiB7XG4gICAgICAgICAgICAgICAgdXJsOiBfQVBJLmFkZCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9ubG9hZDogKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsSXRlbXMgPSBmaWVsZC5xdWVyeVNlbGVjdG9yKCcubG0tZmllbGRfX2l0ZW1zJykgYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgZWxJdGVtcy5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyYmVnaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FyZChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTI2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./assets/ts/module/upload.ts\n");

/***/ }),

/***/ "./assets/ts/options/variables.ts":
/*!****************************************!*\
  !*** ./assets/ts/options/variables.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _API: () => (/* binding */ _API),\n/* harmony export */   _CARD: () => (/* binding */ _CARD),\n/* harmony export */   _GALLERY: () => (/* binding */ _GALLERY),\n/* harmony export */   _LIBRARY: () => (/* binding */ _LIBRARY),\n/* harmony export */   _MEDIA: () => (/* binding */ _MEDIA),\n/* harmony export */   _MODAL_DELETE: () => (/* binding */ _MODAL_DELETE),\n/* harmony export */   _MODAL_LIBRARY: () => (/* binding */ _MODAL_LIBRARY),\n/* harmony export */   _UPLOAD: () => (/* binding */ _UPLOAD)\n/* harmony export */ });\n/**\n * Variables for API\n */\nconst _API = {\n    list: '/bundle/looly/media-bundle/list',\n    add: '/bundle/looly/media-bundle/add',\n    remove: '/bundle/looly/media-bundle/remove',\n};\n/**\n * Variables for card media\n */\nconst _CARD = {\n    list: 'lm-gallery',\n    card: 'lm-card-media',\n    checkbox: 'lm-card-media__checkbox',\n    remove: 'lm-card-media__remove'\n};\n/**\n * Variables for gallery field\n */\nconst _GALLERY = {\n    list: 'lm-gallery',\n    actions: {\n        add: 'lm-gallery__action--add',\n        cancel: 'lm-gallery__action--cancel',\n        delete: 'lm-gallery__action--delete_selected',\n        select: 'lm-gallery__action--select',\n        load_more: 'lm-gallery__action--load_more'\n    }\n};\n/**\n * Variables for media field\n */\nconst _MEDIA = {\n    field: 'lm-media',\n    value: 'lm-media__input',\n    preview: 'lm-media__preview',\n    image: 'lm-media__image',\n    actions: {\n        select: 'lm-media__action--select',\n        delete: 'lm-media__action--delete',\n    }\n};\nconst _LIBRARY = {\n    list: 'lm-library',\n    actions: {\n        upload: '',\n        load_more: 'lm-library__action--load_more'\n    }\n};\n/**\n * Variables for library modal\n */\nconst _MODAL_LIBRARY = {\n    list: 'lm-gallery',\n    actions: {\n        select: 'lm-gallery__action--select',\n        load_more: 'lm-gallery__action--load_more',\n    }\n};\n/**\n * Variables for library modal\n */\nconst _MODAL_DELETE = {\n    actions: {\n        cancel: 'lm-modal-delete--cancel',\n        delete: 'lm-modal-delete--delete',\n    }\n};\nconst _UPLOAD = {\n    file: 'lm-file_upload',\n    actions: {\n        modal_upload: 'lm-action--modal_upload'\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvb3B0aW9ucy92YXJpYWJsZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNJLE1BQU0sSUFBSSxHQUFHO0lBQ2hCLElBQUksRUFBRSxpQ0FBaUM7SUFDdkMsR0FBRyxFQUFFLGdDQUFnQztJQUNyQyxNQUFNLEVBQUUsbUNBQW1DO0NBQzlDO0FBRUQ7O0dBRUc7QUFDSSxNQUFNLEtBQUssR0FBRztJQUNqQixJQUFJLEVBQUUsWUFBWTtJQUNsQixJQUFJLEVBQUUsZUFBZTtJQUNyQixRQUFRLEVBQUUseUJBQXlCO0lBQ25DLE1BQU0sRUFBRSx1QkFBdUI7Q0FDbEM7QUFFRDs7R0FFRztBQUNJLE1BQU0sUUFBUSxHQUFHO0lBQ3BCLElBQUksRUFBRSxZQUFZO0lBQ2xCLE9BQU8sRUFBRTtRQUNMLEdBQUcsRUFBRSx5QkFBeUI7UUFDOUIsTUFBTSxFQUFFLDRCQUE0QjtRQUNwQyxNQUFNLEVBQUUscUNBQXFDO1FBQzdDLE1BQU0sRUFBRSw0QkFBNEI7UUFDcEMsU0FBUyxFQUFFLCtCQUErQjtLQUM3QztDQUNKO0FBRUQ7O0dBRUc7QUFDSSxNQUFNLE1BQU0sR0FBRztJQUNsQixLQUFLLEVBQUUsVUFBVTtJQUNqQixLQUFLLEVBQUUsaUJBQWlCO0lBQ3hCLE9BQU8sRUFBRSxtQkFBbUI7SUFDNUIsS0FBSyxFQUFFLGlCQUFpQjtJQUN4QixPQUFPLEVBQUU7UUFDTCxNQUFNLEVBQUUsMEJBQTBCO1FBQ2xDLE1BQU0sRUFBRSwwQkFBMEI7S0FDckM7Q0FDSjtBQUVNLE1BQU0sUUFBUSxHQUFHO0lBQ3BCLElBQUksRUFBRSxZQUFZO0lBQ2xCLE9BQU8sRUFBRTtRQUNMLE1BQU0sRUFBRSxFQUFFO1FBQ1YsU0FBUyxFQUFFLCtCQUErQjtLQUM3QztDQUNKO0FBRUQ7O0dBRUc7QUFDSSxNQUFNLGNBQWMsR0FBRztJQUMxQixJQUFJLEVBQUUsWUFBWTtJQUNsQixPQUFPLEVBQUU7UUFDTCxNQUFNLEVBQUUsNEJBQTRCO1FBQ3BDLFNBQVMsRUFBRSwrQkFBK0I7S0FDN0M7Q0FDSjtBQUVEOztHQUVHO0FBQ0ksTUFBTSxhQUFhLEdBQUc7SUFDekIsT0FBTyxFQUFFO1FBQ0wsTUFBTSxFQUFFLHlCQUF5QjtRQUNqQyxNQUFNLEVBQUUseUJBQXlCO0tBQ3BDO0NBQ0o7QUFFTSxNQUFNLE9BQU8sR0FBRztJQUNuQixJQUFJLEVBQUUsZ0JBQWdCO0lBQ3RCLE9BQU8sRUFBRTtRQUNMLFlBQVksRUFBRSx5QkFBeUI7S0FDMUM7Q0FDSiIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vYXNzZXRzL3RzL29wdGlvbnMvdmFyaWFibGVzLnRzPzM0NTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBWYXJpYWJsZXMgZm9yIEFQSVxuICovXG5leHBvcnQgY29uc3QgX0FQSSA9IHtcbiAgICBsaXN0OiAnL2J1bmRsZS9sb29seS9tZWRpYS1idW5kbGUvbGlzdCcsXG4gICAgYWRkOiAnL2J1bmRsZS9sb29seS9tZWRpYS1idW5kbGUvYWRkJyxcbiAgICByZW1vdmU6ICcvYnVuZGxlL2xvb2x5L21lZGlhLWJ1bmRsZS9yZW1vdmUnLFxufVxuXG4vKipcbiAqIFZhcmlhYmxlcyBmb3IgY2FyZCBtZWRpYVxuICovXG5leHBvcnQgY29uc3QgX0NBUkQgPSB7XG4gICAgbGlzdDogJ2xtLWdhbGxlcnknLFxuICAgIGNhcmQ6ICdsbS1jYXJkLW1lZGlhJyxcbiAgICBjaGVja2JveDogJ2xtLWNhcmQtbWVkaWFfX2NoZWNrYm94JyxcbiAgICByZW1vdmU6ICdsbS1jYXJkLW1lZGlhX19yZW1vdmUnXG59XG5cbi8qKlxuICogVmFyaWFibGVzIGZvciBnYWxsZXJ5IGZpZWxkXG4gKi9cbmV4cG9ydCBjb25zdCBfR0FMTEVSWSA9IHtcbiAgICBsaXN0OiAnbG0tZ2FsbGVyeScsXG4gICAgYWN0aW9uczoge1xuICAgICAgICBhZGQ6ICdsbS1nYWxsZXJ5X19hY3Rpb24tLWFkZCcsXG4gICAgICAgIGNhbmNlbDogJ2xtLWdhbGxlcnlfX2FjdGlvbi0tY2FuY2VsJyxcbiAgICAgICAgZGVsZXRlOiAnbG0tZ2FsbGVyeV9fYWN0aW9uLS1kZWxldGVfc2VsZWN0ZWQnLFxuICAgICAgICBzZWxlY3Q6ICdsbS1nYWxsZXJ5X19hY3Rpb24tLXNlbGVjdCcsXG4gICAgICAgIGxvYWRfbW9yZTogJ2xtLWdhbGxlcnlfX2FjdGlvbi0tbG9hZF9tb3JlJ1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYXJpYWJsZXMgZm9yIG1lZGlhIGZpZWxkXG4gKi9cbmV4cG9ydCBjb25zdCBfTUVESUEgPSB7XG4gICAgZmllbGQ6ICdsbS1tZWRpYScsXG4gICAgdmFsdWU6ICdsbS1tZWRpYV9faW5wdXQnLFxuICAgIHByZXZpZXc6ICdsbS1tZWRpYV9fcHJldmlldycsXG4gICAgaW1hZ2U6ICdsbS1tZWRpYV9faW1hZ2UnLFxuICAgIGFjdGlvbnM6IHtcbiAgICAgICAgc2VsZWN0OiAnbG0tbWVkaWFfX2FjdGlvbi0tc2VsZWN0JyxcbiAgICAgICAgZGVsZXRlOiAnbG0tbWVkaWFfX2FjdGlvbi0tZGVsZXRlJyxcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBfTElCUkFSWSA9IHtcbiAgICBsaXN0OiAnbG0tbGlicmFyeScsXG4gICAgYWN0aW9uczoge1xuICAgICAgICB1cGxvYWQ6ICcnLFxuICAgICAgICBsb2FkX21vcmU6ICdsbS1saWJyYXJ5X19hY3Rpb24tLWxvYWRfbW9yZSdcbiAgICB9XG59XG5cbi8qKlxuICogVmFyaWFibGVzIGZvciBsaWJyYXJ5IG1vZGFsXG4gKi9cbmV4cG9ydCBjb25zdCBfTU9EQUxfTElCUkFSWSA9IHtcbiAgICBsaXN0OiAnbG0tZ2FsbGVyeScsXG4gICAgYWN0aW9uczoge1xuICAgICAgICBzZWxlY3Q6ICdsbS1nYWxsZXJ5X19hY3Rpb24tLXNlbGVjdCcsXG4gICAgICAgIGxvYWRfbW9yZTogJ2xtLWdhbGxlcnlfX2FjdGlvbi0tbG9hZF9tb3JlJyxcbiAgICB9XG59XG5cbi8qKlxuICogVmFyaWFibGVzIGZvciBsaWJyYXJ5IG1vZGFsXG4gKi9cbmV4cG9ydCBjb25zdCBfTU9EQUxfREVMRVRFID0ge1xuICAgIGFjdGlvbnM6IHtcbiAgICAgICAgY2FuY2VsOiAnbG0tbW9kYWwtZGVsZXRlLS1jYW5jZWwnLFxuICAgICAgICBkZWxldGU6ICdsbS1tb2RhbC1kZWxldGUtLWRlbGV0ZScsXG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgX1VQTE9BRCA9IHtcbiAgICBmaWxlOiAnbG0tZmlsZV91cGxvYWQnLFxuICAgIGFjdGlvbnM6IHtcbiAgICAgICAgbW9kYWxfdXBsb2FkOiAnbG0tYWN0aW9uLS1tb2RhbF91cGxvYWQnXG4gICAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/ts/options/variables.ts\n");

/***/ }),

/***/ "./assets/ts/template/card.ts":
/*!************************************!*\
  !*** ./assets/ts/template/card.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   card: () => (/* binding */ card)\n/* harmony export */ });\nconst card = (data) => {\n    if (!data.fullPath || !data.slug)\n        return;\n    return `\n        <div class=\"lm-card-media\">\n            <input class=\"lm-card-media__checkbox\" type=\"checkbox\" id=\"${data.slug}\" name=\"__\" value=\"${data.id}\">\n            <label for=\"${data.slug}\" class=\"lm-card-media__label\">\n                 <button class=\"lm-card-media__remove\"></button>\n                 <img src=\"${data.thumbnail}\" class=\"lm-item__image\">\n            </label>\n        </div>\n    `;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvdGVtcGxhdGUvY2FyZC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBT08sTUFBTSxJQUFJLEdBQUcsQ0FBQyxJQUFVLEVBQUUsRUFBRTtJQUMvQixJQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJO1FBQUUsT0FBTztJQUV4QyxPQUFPOzt5RUFFOEQsSUFBSSxDQUFDLElBQUksc0JBQXNCLElBQUksQ0FBQyxFQUFFOzBCQUNyRixJQUFJLENBQUMsSUFBSTs7NkJBRU4sSUFBSSxDQUFDLFNBQVM7OztLQUd0QyxDQUFDO0FBQ04sQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9hc3NldHMvdHMvdGVtcGxhdGUvY2FyZC50cz82YjY3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW50ZXJmYWNlIERhdGEge1xuICAgIGZ1bGxQYXRoPzogc3RyaW5nO1xuICAgIHNsdWc/OiBzdHJpbmc7XG4gICAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgY29uc3QgY2FyZCA9IChkYXRhOiBEYXRhKSA9PiB7XG4gICAgaWYoIWRhdGEuZnVsbFBhdGggfHwgIWRhdGEuc2x1ZykgcmV0dXJuO1xuXG4gICAgcmV0dXJuIGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImxtLWNhcmQtbWVkaWFcIj5cbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImxtLWNhcmQtbWVkaWFfX2NoZWNrYm94XCIgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCIke2RhdGEuc2x1Z31cIiBuYW1lPVwiX19cIiB2YWx1ZT1cIiR7ZGF0YS5pZH1cIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCIke2RhdGEuc2x1Z31cIiBjbGFzcz1cImxtLWNhcmQtbWVkaWFfX2xhYmVsXCI+XG4gICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJsbS1jYXJkLW1lZGlhX19yZW1vdmVcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCIke2RhdGEudGh1bWJuYWlsfVwiIGNsYXNzPVwibG0taXRlbV9faW1hZ2VcIj5cbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvZGl2PlxuICAgIGA7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/ts/template/card.ts\n");

/***/ }),

/***/ "./assets/ts/template/modal-delete.ts":
/*!********************************************!*\
  !*** ./assets/ts/template/modal-delete.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   modalDelete: () => (/* binding */ modalDelete)\n/* harmony export */ });\nconst modalDelete = () => {\n    return `\n        <div class=\"lm-modal lm-modal-delete\">\n            <div class=\"lm-modal__body\">  \n                <h5 class=\"lm-modal__title\">Do you want to delete this media?</h5>\n                \n                <div class=\"lm-modal__actions\">\n                    <button class=\"btn lm-modal-delete--cancel\">Cancel</button>\n                    <button class=\"btn btn-danger lm-modal-delete--delete\">Delete</button>\n                </div>\n            </div>\n        </div>\n    `;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvdGVtcGxhdGUvbW9kYWwtZGVsZXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNLFdBQVcsR0FBRyxHQUFHLEVBQUU7SUFDNUIsT0FBTzs7Ozs7Ozs7Ozs7S0FXTixDQUFDO0FBQ04sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL01lZGlhQnVuZGxlLy4vYXNzZXRzL3RzL3RlbXBsYXRlL21vZGFsLWRlbGV0ZS50cz81NjdjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBtb2RhbERlbGV0ZSA9ICgpID0+IHtcbiAgICByZXR1cm4gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwibG0tbW9kYWwgbG0tbW9kYWwtZGVsZXRlXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG0tbW9kYWxfX2JvZHlcIj4gIFxuICAgICAgICAgICAgICAgIDxoNSBjbGFzcz1cImxtLW1vZGFsX190aXRsZVwiPkRvIHlvdSB3YW50IHRvIGRlbGV0ZSB0aGlzIG1lZGlhPzwvaDU+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxtLW1vZGFsX19hY3Rpb25zXCI+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gbG0tbW9kYWwtZGVsZXRlLS1jYW5jZWxcIj5DYW5jZWw8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tZGFuZ2VyIGxtLW1vZGFsLWRlbGV0ZS0tZGVsZXRlXCI+RGVsZXRlPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgYDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/ts/template/modal-delete.ts\n");

/***/ }),

/***/ "./assets/ts/template/modal-library.ts":
/*!*********************************************!*\
  !*** ./assets/ts/template/modal-library.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   modalLibrary: () => (/* binding */ modalLibrary)\n/* harmony export */ });\nconst modalLibrary = () => {\n    return `\n        <div class=\"lm-modal lm-modal-library is-loading\">\n            <div class=\"lm-modal__body\">  \n                <div class=\"lm-gallery lm-field\" data-type=\"library\" data-page=\"1\" data-limit=\"24\">  \n                    <div class=\"lm-gallery__wrapper\">\n                        <div class=\"lm-gallery__panel\">\n                            <h6 class=\"lm-gallery__title\">Media Library</h6>\n                            <div class=\"lm-gallery__actions\">\n                                <button class=\" btn lm-action--modal_upload\">Upload file</button>\n                                <button type=\"button\" class=\"btn btn-primary lm-gallery__action lm-gallery__action--select\">Select</button>\n                                <button type=\"button\" class=\"btn btn-primary lm-gallery__action lm-gallery__action--add\"><i class=\"fa-solid fa-plus\"></i></button>\n                                <button type=\"button\" class=\"btn lm-gallery__action lm-gallery__action--cancel\">Cancel</button>\n                                <button type=\"button\" class=\"btn btn-danger lm-gallery__action lm-gallery__action--delete_selected\">Delete selected</button>\n                            </div>\n                        </div>\n                        <div class=\"lm-gallery__items lm-field__items\"></div>\n                        <div class=\"lm-gallery__footer\">    \n                            <button type=\"button\" class=\"btn lm-gallery__action lm-gallery__action--load_more\">Load more</button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    `;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvdGVtcGxhdGUvbW9kYWwtbGlicmFyeS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTSxZQUFZLEdBQUcsR0FBRyxFQUFFO0lBQzdCLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBdUJOLENBQUM7QUFDTixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTWVkaWFCdW5kbGUvLi9hc3NldHMvdHMvdGVtcGxhdGUvbW9kYWwtbGlicmFyeS50cz81YzcxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBtb2RhbExpYnJhcnkgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImxtLW1vZGFsIGxtLW1vZGFsLWxpYnJhcnkgaXMtbG9hZGluZ1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxtLW1vZGFsX19ib2R5XCI+ICBcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG0tZ2FsbGVyeSBsbS1maWVsZFwiIGRhdGEtdHlwZT1cImxpYnJhcnlcIiBkYXRhLXBhZ2U9XCIxXCIgZGF0YS1saW1pdD1cIjI0XCI+ICBcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxtLWdhbGxlcnlfX3dyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsbS1nYWxsZXJ5X19wYW5lbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNiBjbGFzcz1cImxtLWdhbGxlcnlfX3RpdGxlXCI+TWVkaWEgTGlicmFyeTwvaDY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxtLWdhbGxlcnlfX2FjdGlvbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIiBidG4gbG0tYWN0aW9uLS1tb2RhbF91cGxvYWRcIj5VcGxvYWQgZmlsZTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBsbS1nYWxsZXJ5X19hY3Rpb24gbG0tZ2FsbGVyeV9fYWN0aW9uLS1zZWxlY3RcIj5TZWxlY3Q8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgbG0tZ2FsbGVyeV9fYWN0aW9uIGxtLWdhbGxlcnlfX2FjdGlvbi0tYWRkXCI+PGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1wbHVzXCI+PC9pPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBsbS1nYWxsZXJ5X19hY3Rpb24gbG0tZ2FsbGVyeV9fYWN0aW9uLS1jYW5jZWxcIj5DYW5jZWw8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRhbmdlciBsbS1nYWxsZXJ5X19hY3Rpb24gbG0tZ2FsbGVyeV9fYWN0aW9uLS1kZWxldGVfc2VsZWN0ZWRcIj5EZWxldGUgc2VsZWN0ZWQ8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxtLWdhbGxlcnlfX2l0ZW1zIGxtLWZpZWxkX19pdGVtc1wiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxtLWdhbGxlcnlfX2Zvb3RlclwiPiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBsbS1nYWxsZXJ5X19hY3Rpb24gbG0tZ2FsbGVyeV9fYWN0aW9uLS1sb2FkX21vcmVcIj5Mb2FkIG1vcmU8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICBgO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/ts/template/modal-library.ts\n");

/***/ }),

/***/ "./assets/ts/template/modal-upload.ts":
/*!********************************************!*\
  !*** ./assets/ts/template/modal-upload.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   modalUpload: () => (/* binding */ modalUpload)\n/* harmony export */ });\nconst modalUpload = () => {\n    return `\n        <div class=\"lm-modal lm-modal-upload\">\n            <div class=\"lm-modal__header\">\n                <h6 class=\"lm-modal__title\">Upload file</h6>\n            </div>\n            <div class=\"lm-modal__body\"> \n                <input class=\"lm-file_upload\" type=\"file\" multiple>\n            </div>\n        </div>\n    `;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvdHMvdGVtcGxhdGUvbW9kYWwtdXBsb2FkLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNLFdBQVcsR0FBRyxHQUFHLEVBQUU7SUFDNUIsT0FBTzs7Ozs7Ozs7O0tBU04sQ0FBQztBQUNOLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZWRpYUJ1bmRsZS8uL2Fzc2V0cy90cy90ZW1wbGF0ZS9tb2RhbC11cGxvYWQudHM/MjZlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgbW9kYWxVcGxvYWQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImxtLW1vZGFsIGxtLW1vZGFsLXVwbG9hZFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxtLW1vZGFsX19oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICA8aDYgY2xhc3M9XCJsbS1tb2RhbF9fdGl0bGVcIj5VcGxvYWQgZmlsZTwvaDY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsbS1tb2RhbF9fYm9keVwiPiBcbiAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJsbS1maWxlX3VwbG9hZFwiIHR5cGU9XCJmaWxlXCIgbXVsdGlwbGU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgYDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/ts/template/modal-upload.ts\n");

/***/ }),

/***/ "./node_modules/axios/package.json":
/*!*****************************************!*\
  !*** ./node_modules/axios/package.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./assets/ts/media-bundle.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});